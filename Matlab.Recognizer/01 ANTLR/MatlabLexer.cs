//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3 2015-09-27 18:23:50

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


/* 
 * [The BSD 3-Clause License]
 * Copyright (c) 2015, Samuel Suffos
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list 
 *    of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this 
 *    list of conditions and the following disclaimer in the documentation and/or other 
 *    materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its contributors may be 
 *    used to endorse or promote products derived from this software without specific 
 *    prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
 * SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED 
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 *
 */


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace Matlab.Recognizer
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
internal partial class MatlabLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int AND=4;
	public const int ASSIGN=5;
	public const int AT=6;
	public const int BANG_MODE=7;
	public const int BLOCKCOMMENT=8;
	public const int BREAK=9;
	public const int CASE=10;
	public const int CATCH=11;
	public const int CLASSDEF=12;
	public const int COLON=13;
	public const int COMMA=14;
	public const int COMMAND=15;
	public const int COMMAND_MODE=16;
	public const int CONTINUE=17;
	public const int CTRANS=18;
	public const int DEFAULTBLOCK=19;
	public const int DEFAULTBLOCK1=20;
	public const int DEFAULTBLOCK2=21;
	public const int DEFAULTBLOCK3=22;
	public const int DEFAULTBLOCK4=23;
	public const int DEFAULT_MODE=24;
	public const int DIGIT=25;
	public const int DOT=26;
	public const int ELLIPSIS=27;
	public const int ELSE=28;
	public const int ELSEIF=29;
	public const int END=30;
	public const int EOL=31;
	public const int EQ=32;
	public const int EXCLAMATION=33;
	public const int EXP=34;
	public const int FOR=35;
	public const int FUNCTION=36;
	public const int GLOBAL=37;
	public const int GT=38;
	public const int GTEQ=39;
	public const int ID=40;
	public const int IF=41;
	public const int IMAGINARY=42;
	public const int IMG=43;
	public const int LCURLY=44;
	public const int LDIV=45;
	public const int LETTER=46;
	public const int LINE=47;
	public const int LINECOMMENT=48;
	public const int LINECOMMENT1=49;
	public const int LINECOMMENT2=50;
	public const int LINECOMMENT3=51;
	public const int LPAREN=52;
	public const int LSQUARE=53;
	public const int LT=54;
	public const int LTEQ=55;
	public const int MINUS=56;
	public const int MLDIV=57;
	public const int MPOW=58;
	public const int MRDIV=59;
	public const int MTIMES=60;
	public const int NOT=61;
	public const int NOTEQ=62;
	public const int NUMBER=63;
	public const int OR=64;
	public const int OTHERWISE=65;
	public const int PARFOR=66;
	public const int PERSISTENT=67;
	public const int PLUS=68;
	public const int POINT=69;
	public const int POW=70;
	public const int QUESTION=71;
	public const int QUOTATION=72;
	public const int RCURLY=73;
	public const int RDIV=74;
	public const int REAL=75;
	public const int RETURN=76;
	public const int RPAREN=77;
	public const int RSQUARE=78;
	public const int SEMICOLON=79;
	public const int SHORTAND=80;
	public const int SHORTOR=81;
	public const int SIGN=82;
	public const int SPACES=83;
	public const int SPMD=84;
	public const int START=85;
	public const int STRING=86;
	public const int STRINGBLOCK=87;
	public const int SWITCH=88;
	public const int TIMES=89;
	public const int TRANS=90;
	public const int TRY=91;
	public const int UNKNOWN=92;
	public const int WHILE=93;
	public const int WS=94;

	// delegates
	// delegators

	public MatlabLexer()
	{
		OnCreated();
	}

	public MatlabLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public MatlabLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_START();
	partial void LeaveRule_START();

	// $ANTLR start "START"
	[GrammarRule("START")]
	private void mSTART()
	{
		EnterRule_START();
		EnterRule("START", 1);
		TraceIn("START", 1);
		try
		{
			int _type = START;
			int _channel = DefaultTokenChannel;
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:109:7: ({...}? => DEFAULT_MODE |{...}? => COMMAND_MODE |{...}? => BANG_MODE )
			int alt1=3;
			try { DebugEnterDecision(1, false);
			int LA1_1 = input.LA(1);

			if ((LA1_1=='%') && (((((!Spaces_SpacesPrecedeInLine())||(Spaces_SpacesPrecedeInLine()))&&((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))))||((Machine_InMode(Mode.Command))&&(Spaces_SpacesPrecedeInLine()))||(Machine_InMode(Mode.Bang))||((Machine_InMode(Mode.Default))&&(!Spaces_SpacesPrecedeInLine()))||((Machine_InMode(Mode.Default))&&(Spaces_SpacesPrecedeInLine()))||((Machine_InMode(Mode.Command))&&(!Spaces_SpacesPrecedeInLine())))))
			{
				int LA1_2 = input.LA(2);

				if ((((Machine_InMode(Mode.Default))&&((!Spaces_SpacesPrecedeInLine())||(Spaces_SpacesPrecedeInLine())))))
				{
					alt1 = 1;
				}
				else if ((((Machine_InMode(Mode.Command))&&((!Spaces_SpacesPrecedeInLine())||(Spaces_SpacesPrecedeInLine())))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='.') && (((Machine_InMode(Mode.Default))||((Machine_InMode(Mode.Command))&&((Text_ThreeDotsFollow())||(!Text_ThreeDotsFollow())))||((Machine_InMode(Mode.Command))&&(!Text_ThreeDotsFollow()))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if ((((Machine_InMode(Mode.Command))&&((Text_ThreeDotsFollow())||(!Text_ThreeDotsFollow())))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='\t'||LA1_1==' ') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='\r') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='\n') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='\'') && ((((Machine_InMode(Mode.Default))&&((!Quotation_TransposeIsEnabled())||(Quotation_TransposeIsEnabled())))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang))||((Machine_InMode(Mode.Default))&&(!Quotation_TransposeIsEnabled()))||((Machine_InMode(Mode.Default))&&(Quotation_TransposeIsEnabled())))))
			{
				int LA1_2 = input.LA(2);

				if (((LA1_2>='\u0000' && LA1_2<='\t')||(LA1_2>='\u000B' && LA1_2<='\f')||(LA1_2>='\u000E' && LA1_2<='\uFFFF')) && ((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if ((((Machine_InMode(Mode.Default))&&((!Quotation_TransposeIsEnabled())||(Quotation_TransposeIsEnabled())))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if (((LA1_1>='0' && LA1_1<='9')) && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if (((LA1_1>='A' && LA1_1<='Z')||(LA1_1>='a' && LA1_1<='z')) && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='+') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 9, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='-') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='*') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 11, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='/') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 12, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='\\') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 13, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='^') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 14, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='=') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 15, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='~') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 16, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='<') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 17, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='>') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 18, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='&') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 19, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='|') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 20, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1==',') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 21, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1==';') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 22, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1==':') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 23, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='(') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 24, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1==')') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 25, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='[') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 26, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1==']') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 27, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='{') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 28, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='}') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 29, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='@') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 30, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='?') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 31, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_1=='!') && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 32, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if (((LA1_1>='\u0000' && LA1_1<='\b')||(LA1_1>='\u000B' && LA1_1<='\f')||(LA1_1>='\u000E' && LA1_1<='\u001F')||(LA1_1>='\"' && LA1_1<='$')||(LA1_1>='_' && LA1_1<='`')||(LA1_1>='\u007F' && LA1_1<='\uFFFF')) && (((Machine_InMode(Mode.Default))||(Machine_InMode(Mode.Command))||(Machine_InMode(Mode.Bang)))))
			{
				int LA1_2 = input.LA(2);

				if (((Machine_InMode(Mode.Default))))
				{
					alt1 = 1;
				}
				else if (((Machine_InMode(Mode.Command))))
				{
					alt1 = 2;
				}
				else if (((Machine_InMode(Mode.Bang))))
				{
					alt1 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 1, 33, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:109:9: {...}? => DEFAULT_MODE
				{
				DebugLocation(109, 9);
				if (!((Machine_InMode(Mode.Default))))
				{
					if (state.backtracking>0) {state.failed=true; return;}
					throw new FailedPredicateException(input, "START", "Machine_InMode(Mode.Default)");
				}
				DebugLocation(109, 43);
				mDEFAULT_MODE(); if (state.failed) return;
				DebugLocation(109, 56);
				if (state.backtracking == 0)
				{
					 _type = machine_TokenType; _channel = (int)machine_TokenChannel; 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:110:9: {...}? => COMMAND_MODE
				{
				DebugLocation(110, 9);
				if (!((Machine_InMode(Mode.Command))))
				{
					if (state.backtracking>0) {state.failed=true; return;}
					throw new FailedPredicateException(input, "START", "Machine_InMode(Mode.Command)");
				}
				DebugLocation(110, 43);
				mCOMMAND_MODE(); if (state.failed) return;
				DebugLocation(110, 56);
				if (state.backtracking == 0)
				{
					 _type = machine_TokenType; _channel = (int)machine_TokenChannel; 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:111:9: {...}? => BANG_MODE
				{
				DebugLocation(111, 9);
				if (!((Machine_InMode(Mode.Bang))))
				{
					if (state.backtracking>0) {state.failed=true; return;}
					throw new FailedPredicateException(input, "START", "Machine_InMode(Mode.Bang)");
				}
				DebugLocation(111, 41);
				mBANG_MODE(); if (state.failed) return;
				DebugLocation(111, 52);
				if (state.backtracking == 0)
				{
					 _type = machine_TokenType; _channel = (int)machine_TokenChannel; 
				}

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("START", 1);
			LeaveRule("START", 1);
			LeaveRule_START();
		}
	}
	// $ANTLR end "START"

	partial void EnterRule_DEFAULT_MODE();
	partial void LeaveRule_DEFAULT_MODE();

	// $ANTLR start "DEFAULT_MODE"
	[GrammarRule("DEFAULT_MODE")]
	private void mDEFAULT_MODE()
	{
		EnterRule_DEFAULT_MODE();
		EnterRule("DEFAULT_MODE", 2);
		TraceIn("DEFAULT_MODE", 2);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:114:23: ( LINECOMMENT1 | LINECOMMENT2 | LINECOMMENT3 | BLOCKCOMMENT | ELLIPSIS | SPACES | EOL | ( STRING )=> STRING | QUOTATION | CTRANS | REAL | IMAGINARY | ID | PLUS | MINUS | MTIMES | TIMES | MRDIV | RDIV | MLDIV | LDIV | MPOW | POW | TRANS | EQ | NOTEQ | LT | LTEQ | GT | GTEQ | NOT | AND | SHORTAND | OR | SHORTOR | ASSIGN | COMMA | SEMICOLON | COLON | DOT | LPAREN | RPAREN | LSQUARE | RSQUARE | LCURLY | RCURLY | AT | QUESTION | EXCLAMATION | UNKNOWN )
			int alt2=50;
			try { DebugEnterDecision(2, false);
			try
			{
				alt2 = dfa2.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:114:25: LINECOMMENT1
				{
				DebugLocation(114, 25);
				mLINECOMMENT1(); if (state.failed) return;
				DebugLocation(114, 39);
				if (state.backtracking == 0)
				{
					 Machine_Update(LINECOMMENT, Channel.Skipped, Mode.Default); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:115:25: LINECOMMENT2
				{
				DebugLocation(115, 25);
				mLINECOMMENT2(); if (state.failed) return;
				DebugLocation(115, 39);
				if (state.backtracking == 0)
				{
					 Machine_Update(LINECOMMENT, Channel.Skipped, Mode.Default); 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:116:10: LINECOMMENT3
				{
				DebugLocation(116, 10);
				mLINECOMMENT3(); if (state.failed) return;
				DebugLocation(116, 24);
				if (state.backtracking == 0)
				{
					 Machine_Update(LINECOMMENT, Channel.Skipped, Mode.Default); 
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:117:10: BLOCKCOMMENT
				{
				DebugLocation(117, 10);
				mBLOCKCOMMENT(); if (state.failed) return;
				DebugLocation(117, 24);
				if (state.backtracking == 0)
				{
					 Machine_Update(BLOCKCOMMENT, Channel.Spaces, Mode.Default); 
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:118:10: ELLIPSIS
				{
				DebugLocation(118, 10);
				mELLIPSIS(); if (state.failed) return;
				DebugLocation(118, 21);
				if (state.backtracking == 0)
				{
					 Machine_Update(ELLIPSIS, Channel.Spaces, Mode.Default); 
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:119:10: SPACES
				{
				DebugLocation(119, 10);
				mSPACES(); if (state.failed) return;
				DebugLocation(119, 20);
				if (state.backtracking == 0)
				{
					 Machine_Update(SPACES, Channel.Spaces, Mode.Default); 
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:120:10: EOL
				{
				DebugLocation(120, 10);
				mEOL(); if (state.failed) return;
				DebugLocation(120, 18);
				if (state.backtracking == 0)
				{
					 Machine_Update(EOL, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:121:10: ( STRING )=> STRING
				{
				DebugLocation(121, 21);
				mSTRING(); if (state.failed) return;
				DebugLocation(121, 28);
				if (state.backtracking == 0)
				{
					 Machine_Update(STRING, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:122:10: QUOTATION
				{
				DebugLocation(122, 10);
				mQUOTATION(); if (state.failed) return;
				DebugLocation(122, 22);
				if (state.backtracking == 0)
				{
					 Machine_Update(QUOTATION, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:123:10: CTRANS
				{
				DebugLocation(123, 10);
				mCTRANS(); if (state.failed) return;
				DebugLocation(123, 20);
				if (state.backtracking == 0)
				{
					 Machine_Update(CTRANS, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:124:10: REAL
				{
				DebugLocation(124, 10);
				mREAL(); if (state.failed) return;
				DebugLocation(124, 18);
				if (state.backtracking == 0)
				{
					 Machine_Update(REAL, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:125:10: IMAGINARY
				{
				DebugLocation(125, 10);
				mIMAGINARY(); if (state.failed) return;
				DebugLocation(125, 22);
				if (state.backtracking == 0)
				{
					 Machine_Update(IMAGINARY, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:126:10: ID
				{
				DebugLocation(126, 10);
				mID(); if (state.failed) return;
				DebugLocation(126, 17);
				if (state.backtracking == 0)
				{
					 Machine_Update(Text, ID, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:127:10: PLUS
				{
				DebugLocation(127, 10);
				mPLUS(); if (state.failed) return;
				DebugLocation(127, 18);
				if (state.backtracking == 0)
				{
					 Machine_Update(PLUS, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:128:10: MINUS
				{
				DebugLocation(128, 10);
				mMINUS(); if (state.failed) return;
				DebugLocation(128, 19);
				if (state.backtracking == 0)
				{
					 Machine_Update(MINUS, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:129:10: MTIMES
				{
				DebugLocation(129, 10);
				mMTIMES(); if (state.failed) return;
				DebugLocation(129, 20);
				if (state.backtracking == 0)
				{
					 Machine_Update(MTIMES, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 17:
				DebugEnterAlt(17);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:130:10: TIMES
				{
				DebugLocation(130, 10);
				mTIMES(); if (state.failed) return;
				DebugLocation(130, 19);
				if (state.backtracking == 0)
				{
					 Machine_Update(TIMES, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 18:
				DebugEnterAlt(18);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:131:10: MRDIV
				{
				DebugLocation(131, 10);
				mMRDIV(); if (state.failed) return;
				DebugLocation(131, 19);
				if (state.backtracking == 0)
				{
					 Machine_Update(MRDIV, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 19:
				DebugEnterAlt(19);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:132:10: RDIV
				{
				DebugLocation(132, 10);
				mRDIV(); if (state.failed) return;
				DebugLocation(132, 18);
				if (state.backtracking == 0)
				{
					 Machine_Update(RDIV, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 20:
				DebugEnterAlt(20);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:133:10: MLDIV
				{
				DebugLocation(133, 10);
				mMLDIV(); if (state.failed) return;
				DebugLocation(133, 19);
				if (state.backtracking == 0)
				{
					 Machine_Update(MLDIV, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 21:
				DebugEnterAlt(21);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:134:10: LDIV
				{
				DebugLocation(134, 10);
				mLDIV(); if (state.failed) return;
				DebugLocation(134, 18);
				if (state.backtracking == 0)
				{
					 Machine_Update(LDIV, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 22:
				DebugEnterAlt(22);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:135:10: MPOW
				{
				DebugLocation(135, 10);
				mMPOW(); if (state.failed) return;
				DebugLocation(135, 18);
				if (state.backtracking == 0)
				{
					 Machine_Update(MPOW, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 23:
				DebugEnterAlt(23);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:136:10: POW
				{
				DebugLocation(136, 10);
				mPOW(); if (state.failed) return;
				DebugLocation(136, 18);
				if (state.backtracking == 0)
				{
					 Machine_Update(POW, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 24:
				DebugEnterAlt(24);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:137:10: TRANS
				{
				DebugLocation(137, 10);
				mTRANS(); if (state.failed) return;
				DebugLocation(137, 19);
				if (state.backtracking == 0)
				{
					 Machine_Update(TRANS, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 25:
				DebugEnterAlt(25);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:138:10: EQ
				{
				DebugLocation(138, 10);
				mEQ(); if (state.failed) return;
				DebugLocation(138, 17);
				if (state.backtracking == 0)
				{
					 Machine_Update(EQ, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 26:
				DebugEnterAlt(26);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:139:10: NOTEQ
				{
				DebugLocation(139, 10);
				mNOTEQ(); if (state.failed) return;
				DebugLocation(139, 19);
				if (state.backtracking == 0)
				{
					 Machine_Update(NOTEQ, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 27:
				DebugEnterAlt(27);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:140:10: LT
				{
				DebugLocation(140, 10);
				mLT(); if (state.failed) return;
				DebugLocation(140, 17);
				if (state.backtracking == 0)
				{
					 Machine_Update(LT, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 28:
				DebugEnterAlt(28);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:141:10: LTEQ
				{
				DebugLocation(141, 10);
				mLTEQ(); if (state.failed) return;
				DebugLocation(141, 18);
				if (state.backtracking == 0)
				{
					 Machine_Update(LTEQ, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 29:
				DebugEnterAlt(29);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:142:10: GT
				{
				DebugLocation(142, 10);
				mGT(); if (state.failed) return;
				DebugLocation(142, 17);
				if (state.backtracking == 0)
				{
					 Machine_Update(GT, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 30:
				DebugEnterAlt(30);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:143:10: GTEQ
				{
				DebugLocation(143, 10);
				mGTEQ(); if (state.failed) return;
				DebugLocation(143, 18);
				if (state.backtracking == 0)
				{
					 Machine_Update(GTEQ, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 31:
				DebugEnterAlt(31);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:144:10: NOT
				{
				DebugLocation(144, 10);
				mNOT(); if (state.failed) return;
				DebugLocation(144, 18);
				if (state.backtracking == 0)
				{
					 Machine_Update(NOT, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 32:
				DebugEnterAlt(32);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:145:10: AND
				{
				DebugLocation(145, 10);
				mAND(); if (state.failed) return;
				DebugLocation(145, 18);
				if (state.backtracking == 0)
				{
					 Machine_Update(AND, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 33:
				DebugEnterAlt(33);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:146:10: SHORTAND
				{
				DebugLocation(146, 10);
				mSHORTAND(); if (state.failed) return;
				DebugLocation(146, 21);
				if (state.backtracking == 0)
				{
					 Machine_Update(SHORTAND, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 34:
				DebugEnterAlt(34);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:147:10: OR
				{
				DebugLocation(147, 10);
				mOR(); if (state.failed) return;
				DebugLocation(147, 17);
				if (state.backtracking == 0)
				{
					 Machine_Update(OR, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 35:
				DebugEnterAlt(35);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:148:10: SHORTOR
				{
				DebugLocation(148, 10);
				mSHORTOR(); if (state.failed) return;
				DebugLocation(148, 21);
				if (state.backtracking == 0)
				{
					 Machine_Update(SHORTOR, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 36:
				DebugEnterAlt(36);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:149:10: ASSIGN
				{
				DebugLocation(149, 10);
				mASSIGN(); if (state.failed) return;
				DebugLocation(149, 20);
				if (state.backtracking == 0)
				{
					 Machine_Update(ASSIGN, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 37:
				DebugEnterAlt(37);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:150:10: COMMA
				{
				DebugLocation(150, 10);
				mCOMMA(); if (state.failed) return;
				DebugLocation(150, 19);
				if (state.backtracking == 0)
				{
					 Machine_Update(COMMA, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 38:
				DebugEnterAlt(38);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:151:10: SEMICOLON
				{
				DebugLocation(151, 10);
				mSEMICOLON(); if (state.failed) return;
				DebugLocation(151, 22);
				if (state.backtracking == 0)
				{
					 Machine_Update(SEMICOLON, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 39:
				DebugEnterAlt(39);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:152:10: COLON
				{
				DebugLocation(152, 10);
				mCOLON(); if (state.failed) return;
				DebugLocation(152, 19);
				if (state.backtracking == 0)
				{
					 Machine_Update(COLON, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 40:
				DebugEnterAlt(40);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:153:10: DOT
				{
				DebugLocation(153, 10);
				mDOT(); if (state.failed) return;
				DebugLocation(153, 18);
				if (state.backtracking == 0)
				{
					 Machine_Update(DOT, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 41:
				DebugEnterAlt(41);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:154:10: LPAREN
				{
				DebugLocation(154, 10);
				mLPAREN(); if (state.failed) return;
				DebugLocation(154, 20);
				if (state.backtracking == 0)
				{
					 Machine_Update(LPAREN, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 42:
				DebugEnterAlt(42);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:155:10: RPAREN
				{
				DebugLocation(155, 10);
				mRPAREN(); if (state.failed) return;
				DebugLocation(155, 20);
				if (state.backtracking == 0)
				{
					 Machine_Update(RPAREN, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 43:
				DebugEnterAlt(43);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:156:10: LSQUARE
				{
				DebugLocation(156, 10);
				mLSQUARE(); if (state.failed) return;
				DebugLocation(156, 21);
				if (state.backtracking == 0)
				{
					 Machine_Update(LSQUARE, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 44:
				DebugEnterAlt(44);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:157:10: RSQUARE
				{
				DebugLocation(157, 10);
				mRSQUARE(); if (state.failed) return;
				DebugLocation(157, 21);
				if (state.backtracking == 0)
				{
					 Machine_Update(RSQUARE, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 45:
				DebugEnterAlt(45);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:158:10: LCURLY
				{
				DebugLocation(158, 10);
				mLCURLY(); if (state.failed) return;
				DebugLocation(158, 20);
				if (state.backtracking == 0)
				{
					 Machine_Update(LCURLY, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 46:
				DebugEnterAlt(46);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:159:10: RCURLY
				{
				DebugLocation(159, 10);
				mRCURLY(); if (state.failed) return;
				DebugLocation(159, 20);
				if (state.backtracking == 0)
				{
					 Machine_Update(RCURLY, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 47:
				DebugEnterAlt(47);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:160:10: AT
				{
				DebugLocation(160, 10);
				mAT(); if (state.failed) return;
				DebugLocation(160, 17);
				if (state.backtracking == 0)
				{
					 Machine_Update(AT, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 48:
				DebugEnterAlt(48);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:161:10: QUESTION
				{
				DebugLocation(161, 10);
				mQUESTION(); if (state.failed) return;
				DebugLocation(161, 21);
				if (state.backtracking == 0)
				{
					 Machine_Update(QUESTION, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 49:
				DebugEnterAlt(49);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:162:10: EXCLAMATION
				{
				DebugLocation(162, 10);
				mEXCLAMATION(); if (state.failed) return;
				DebugLocation(162, 24);
				if (state.backtracking == 0)
				{
					 Machine_Update(EXCLAMATION, Channel.Default, Mode.Bang); 
				}

				}
				break;
			case 50:
				DebugEnterAlt(50);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:163:10: UNKNOWN
				{
				DebugLocation(163, 10);
				mUNKNOWN(); if (state.failed) return;
				DebugLocation(163, 21);
				if (state.backtracking == 0)
				{
					 Machine_Update(UNKNOWN, Channel.Default, Mode.Default); 
				}

				}
				break;

			}
		}
		finally
		{
			TraceOut("DEFAULT_MODE", 2);
			LeaveRule("DEFAULT_MODE", 2);
			LeaveRule_DEFAULT_MODE();
		}
	}
	// $ANTLR end "DEFAULT_MODE"

	partial void EnterRule_COMMAND_MODE();
	partial void LeaveRule_COMMAND_MODE();

	// $ANTLR start "COMMAND_MODE"
	[GrammarRule("COMMAND_MODE")]
	private void mCOMMAND_MODE()
	{
		EnterRule_COMMAND_MODE();
		EnterRule("COMMAND_MODE", 3);
		TraceIn("COMMAND_MODE", 3);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:166:23: ( LINECOMMENT1 | LINECOMMENT2 | LINECOMMENT3 | BLOCKCOMMENT | ELLIPSIS | SPACES | EOL | COMMA | SEMICOLON | STRINGBLOCK | DEFAULTBLOCK1 | DEFAULTBLOCK2 | DEFAULTBLOCK3 | DEFAULTBLOCK4 )
			int alt3=14;
			try { DebugEnterDecision(3, false);
			try
			{
				alt3 = dfa3.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:166:25: LINECOMMENT1
				{
				DebugLocation(166, 25);
				mLINECOMMENT1(); if (state.failed) return;
				DebugLocation(166, 39);
				if (state.backtracking == 0)
				{
					 Machine_Update(LINECOMMENT, Channel.Skipped, Mode.Command); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:167:25: LINECOMMENT2
				{
				DebugLocation(167, 25);
				mLINECOMMENT2(); if (state.failed) return;
				DebugLocation(167, 39);
				if (state.backtracking == 0)
				{
					 Machine_Update(LINECOMMENT, Channel.Skipped, Mode.Command); 
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:168:10: LINECOMMENT3
				{
				DebugLocation(168, 10);
				mLINECOMMENT3(); if (state.failed) return;
				DebugLocation(168, 24);
				if (state.backtracking == 0)
				{
					 Machine_Update(LINECOMMENT, Channel.Skipped, Mode.Command); 
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:169:10: BLOCKCOMMENT
				{
				DebugLocation(169, 10);
				mBLOCKCOMMENT(); if (state.failed) return;
				DebugLocation(169, 24);
				if (state.backtracking == 0)
				{
					 Machine_Update(BLOCKCOMMENT, Channel.Spaces, Mode.Command); 
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:170:10: ELLIPSIS
				{
				DebugLocation(170, 10);
				mELLIPSIS(); if (state.failed) return;
				DebugLocation(170, 21);
				if (state.backtracking == 0)
				{
					 Machine_Update(ELLIPSIS, Channel.Spaces, Mode.Command); 
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:171:10: SPACES
				{
				DebugLocation(171, 10);
				mSPACES(); if (state.failed) return;
				DebugLocation(171, 20);
				if (state.backtracking == 0)
				{
					 Machine_Update(SPACES, Channel.Spaces, Mode.Command); 
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:172:10: EOL
				{
				DebugLocation(172, 10);
				mEOL(); if (state.failed) return;
				DebugLocation(172, 18);
				if (state.backtracking == 0)
				{
					 Machine_Update(EOL, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:173:10: COMMA
				{
				DebugLocation(173, 10);
				mCOMMA(); if (state.failed) return;
				DebugLocation(173, 19);
				if (state.backtracking == 0)
				{
					 Machine_Update(COMMA, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:174:10: SEMICOLON
				{
				DebugLocation(174, 10);
				mSEMICOLON(); if (state.failed) return;
				DebugLocation(174, 22);
				if (state.backtracking == 0)
				{
					 Machine_Update(SEMICOLON, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:175:10: STRINGBLOCK
				{
				DebugLocation(175, 10);
				mSTRINGBLOCK(); if (state.failed) return;
				DebugLocation(175, 24);
				if (state.backtracking == 0)
				{
					 Machine_Update(STRINGBLOCK, Channel.Default, Mode.Command); 
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:176:10: DEFAULTBLOCK1
				{
				DebugLocation(176, 10);
				mDEFAULTBLOCK1(); if (state.failed) return;
				DebugLocation(176, 25);
				if (state.backtracking == 0)
				{
					 Machine_Update(DEFAULTBLOCK, Channel.Default, Mode.Command); 
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:177:10: DEFAULTBLOCK2
				{
				DebugLocation(177, 10);
				mDEFAULTBLOCK2(); if (state.failed) return;
				DebugLocation(177, 25);
				if (state.backtracking == 0)
				{
					 Machine_Update(DEFAULTBLOCK, Channel.Default, Mode.Command); 
				}

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:178:10: DEFAULTBLOCK3
				{
				DebugLocation(178, 10);
				mDEFAULTBLOCK3(); if (state.failed) return;
				DebugLocation(178, 25);
				if (state.backtracking == 0)
				{
					 Machine_Update(DEFAULTBLOCK, Channel.Default, Mode.Command); 
				}

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:179:10: DEFAULTBLOCK4
				{
				DebugLocation(179, 10);
				mDEFAULTBLOCK4(); if (state.failed) return;
				DebugLocation(179, 25);
				if (state.backtracking == 0)
				{
					 Machine_Update(DEFAULTBLOCK, Channel.Default, Mode.Command); 
				}

				}
				break;

			}
		}
		finally
		{
			TraceOut("COMMAND_MODE", 3);
			LeaveRule("COMMAND_MODE", 3);
			LeaveRule_COMMAND_MODE();
		}
	}
	// $ANTLR end "COMMAND_MODE"

	partial void EnterRule_BANG_MODE();
	partial void LeaveRule_BANG_MODE();

	// $ANTLR start "BANG_MODE"
	[GrammarRule("BANG_MODE")]
	private void mBANG_MODE()
	{
		EnterRule_BANG_MODE();
		EnterRule("BANG_MODE", 4);
		TraceIn("BANG_MODE", 4);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:182:20: ( EOL | LINE )
			int alt4=2;
			try { DebugEnterDecision(4, false);
			int LA4_1 = input.LA(1);

			if ((LA4_1=='\n'||LA4_1=='\r'))
			{
				alt4 = 1;
			}
			else if (((LA4_1>='\u0000' && LA4_1<='\t')||(LA4_1>='\u000B' && LA4_1<='\f')||(LA4_1>='\u000E' && LA4_1<='\uFFFF')))
			{
				alt4 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:182:22: EOL
				{
				DebugLocation(182, 22);
				mEOL(); if (state.failed) return;
				DebugLocation(182, 30);
				if (state.backtracking == 0)
				{
					 Machine_Update(EOL, Channel.Default, Mode.Default); 
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:183:10: LINE
				{
				DebugLocation(183, 10);
				mLINE(); if (state.failed) return;
				DebugLocation(183, 19);
				if (state.backtracking == 0)
				{
					 Machine_Update(LINE, Channel.Default, Mode.Bang); 
				}

				}
				break;

			}
		}
		finally
		{
			TraceOut("BANG_MODE", 4);
			LeaveRule("BANG_MODE", 4);
			LeaveRule_BANG_MODE();
		}
	}
	// $ANTLR end "BANG_MODE"

	partial void EnterRule_LETTER();
	partial void LeaveRule_LETTER();

	// $ANTLR start "LETTER"
	[GrammarRule("LETTER")]
	private void mLETTER()
	{
		EnterRule_LETTER();
		EnterRule("LETTER", 5);
		TraceIn("LETTER", 5);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:188:17: ( 'a' .. 'z' | 'A' .. 'Z' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
			{
			DebugLocation(188, 17);
			if ((input.LA(1)>='A' && input.LA(1)<='Z')||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("LETTER", 5);
			LeaveRule("LETTER", 5);
			LeaveRule_LETTER();
		}
	}
	// $ANTLR end "LETTER"

	partial void EnterRule_DIGIT();
	partial void LeaveRule_DIGIT();

	// $ANTLR start "DIGIT"
	[GrammarRule("DIGIT")]
	private void mDIGIT()
	{
		EnterRule_DIGIT();
		EnterRule("DIGIT", 6);
		TraceIn("DIGIT", 6);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:190:16: ( '0' .. '9' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
			{
			DebugLocation(190, 16);
			if ((input.LA(1)>='0' && input.LA(1)<='9'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("DIGIT", 6);
			LeaveRule("DIGIT", 6);
			LeaveRule_DIGIT();
		}
	}
	// $ANTLR end "DIGIT"

	partial void EnterRule_EXP();
	partial void LeaveRule_EXP();

	// $ANTLR start "EXP"
	[GrammarRule("EXP")]
	private void mEXP()
	{
		EnterRule_EXP();
		EnterRule("EXP", 7);
		TraceIn("EXP", 7);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:192:14: ( 'e' | 'E' | 'd' | 'D' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
			{
			DebugLocation(192, 14);
			if ((input.LA(1)>='D' && input.LA(1)<='E')||(input.LA(1)>='d' && input.LA(1)<='e'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("EXP", 7);
			LeaveRule("EXP", 7);
			LeaveRule_EXP();
		}
	}
	// $ANTLR end "EXP"

	partial void EnterRule_IMG();
	partial void LeaveRule_IMG();

	// $ANTLR start "IMG"
	[GrammarRule("IMG")]
	private void mIMG()
	{
		EnterRule_IMG();
		EnterRule("IMG", 8);
		TraceIn("IMG", 8);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:194:14: ( 'i' | 'j' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
			{
			DebugLocation(194, 14);
			if ((input.LA(1)>='i' && input.LA(1)<='j'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("IMG", 8);
			LeaveRule("IMG", 8);
			LeaveRule_IMG();
		}
	}
	// $ANTLR end "IMG"

	partial void EnterRule_SIGN();
	partial void LeaveRule_SIGN();

	// $ANTLR start "SIGN"
	[GrammarRule("SIGN")]
	private void mSIGN()
	{
		EnterRule_SIGN();
		EnterRule("SIGN", 9);
		TraceIn("SIGN", 9);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:196:15: ( '+' | '-' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
			{
			DebugLocation(196, 15);
			if (input.LA(1)=='+'||input.LA(1)=='-')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("SIGN", 9);
			LeaveRule("SIGN", 9);
			LeaveRule_SIGN();
		}
	}
	// $ANTLR end "SIGN"

	partial void EnterRule_POINT();
	partial void LeaveRule_POINT();

	// $ANTLR start "POINT"
	[GrammarRule("POINT")]
	private void mPOINT()
	{
		EnterRule_POINT();
		EnterRule("POINT", 10);
		TraceIn("POINT", 10);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:198:16: ( '.' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:198:18: '.'
			{
			DebugLocation(198, 18);
			Match('.'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("POINT", 10);
			LeaveRule("POINT", 10);
			LeaveRule_POINT();
		}
	}
	// $ANTLR end "POINT"

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 11);
		TraceIn("WS", 11);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:200:13: ( ' ' | '\\t' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
			{
			DebugLocation(200, 13);
			if (input.LA(1)=='\t'||input.LA(1)==' ')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("WS", 11);
			LeaveRule("WS", 11);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	partial void EnterRule_NUMBER();
	partial void LeaveRule_NUMBER();

	// $ANTLR start "NUMBER"
	[GrammarRule("NUMBER")]
	private void mNUMBER()
	{
		EnterRule_NUMBER();
		EnterRule("NUMBER", 12);
		TraceIn("NUMBER", 12);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:202:17: ( ( ( DIGIT )+ ( '.' ( DIGIT )* )? | '.' ( DIGIT )+ ) ( EXP ( SIGN )? ( DIGIT )+ )? )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:202:19: ( ( DIGIT )+ ( '.' ( DIGIT )* )? | '.' ( DIGIT )+ ) ( EXP ( SIGN )? ( DIGIT )+ )?
			{
			DebugLocation(202, 19);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:202:19: ( ( DIGIT )+ ( '.' ( DIGIT )* )? | '.' ( DIGIT )+ )
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if (((LA9_1>='0' && LA9_1<='9')))
			{
				alt9 = 1;
			}
			else if ((LA9_1=='.'))
			{
				alt9 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 9, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:202:20: ( DIGIT )+ ( '.' ( DIGIT )* )?
				{
				DebugLocation(202, 20);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:202:20: ( DIGIT )+
				int cnt5=0;
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=2;
					try { DebugEnterDecision(5, false);
					int LA5_1 = input.LA(1);

					if (((LA5_1>='0' && LA5_1<='9')))
					{
						alt5 = 1;
					}


					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
						{
						DebugLocation(202, 20);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt5 >= 1)
							goto loop5;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee5 = new EarlyExitException( 5, input );
						DebugRecognitionException(eee5);
						throw eee5;
					}
					cnt5++;
				}
				loop5:
					;

				} finally { DebugExitSubRule(5); }

				DebugLocation(202, 29);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:202:29: ( '.' ( DIGIT )* )?
				int alt7=2;
				try { DebugEnterSubRule(7);
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1=='.'))
				{
					alt7 = 1;
				}
				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:202:30: '.' ( DIGIT )*
					{
					DebugLocation(202, 30);
					Match('.'); if (state.failed) return;
					DebugLocation(202, 34);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:202:34: ( DIGIT )*
					try { DebugEnterSubRule(6);
					while (true)
					{
						int alt6=2;
						try { DebugEnterDecision(6, false);
						int LA6_1 = input.LA(1);

						if (((LA6_1>='0' && LA6_1<='9')))
						{
							alt6 = 1;
						}


						} finally { DebugExitDecision(6); }
						switch ( alt6 )
						{
						case 1:
							DebugEnterAlt(1);
							// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
							{
							DebugLocation(202, 34);
							input.Consume();
							state.failed=false;

							}
							break;

						default:
							goto loop6;
						}
					}

					loop6:
						;

					} finally { DebugExitSubRule(6); }


					}
					break;

				}
				} finally { DebugExitSubRule(7); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:202:47: '.' ( DIGIT )+
				{
				DebugLocation(202, 47);
				Match('.'); if (state.failed) return;
				DebugLocation(202, 51);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:202:51: ( DIGIT )+
				int cnt8=0;
				try { DebugEnterSubRule(8);
				while (true)
				{
					int alt8=2;
					try { DebugEnterDecision(8, false);
					int LA8_1 = input.LA(1);

					if (((LA8_1>='0' && LA8_1<='9')))
					{
						alt8 = 1;
					}


					} finally { DebugExitDecision(8); }
					switch (alt8)
					{
					case 1:
						DebugEnterAlt(1);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
						{
						DebugLocation(202, 51);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt8 >= 1)
							goto loop8;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee8 = new EarlyExitException( 8, input );
						DebugRecognitionException(eee8);
						throw eee8;
					}
					cnt8++;
				}
				loop8:
					;

				} finally { DebugExitSubRule(8); }


				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(202, 61);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:202:61: ( EXP ( SIGN )? ( DIGIT )+ )?
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_1 = input.LA(1);

			if (((LA12_1>='D' && LA12_1<='E')||(LA12_1>='d' && LA12_1<='e')))
			{
				alt12 = 1;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:202:62: EXP ( SIGN )? ( DIGIT )+
				{
				DebugLocation(202, 62);
				mEXP(); if (state.failed) return;
				DebugLocation(202, 66);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:202:66: ( SIGN )?
				int alt10=2;
				try { DebugEnterSubRule(10);
				try { DebugEnterDecision(10, false);
				int LA10_1 = input.LA(1);

				if ((LA10_1=='+'||LA10_1=='-'))
				{
					alt10 = 1;
				}
				} finally { DebugExitDecision(10); }
				switch (alt10)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
					{
					DebugLocation(202, 66);
					input.Consume();
					state.failed=false;

					}
					break;

				}
				} finally { DebugExitSubRule(10); }

				DebugLocation(202, 74);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:202:74: ( DIGIT )+
				int cnt11=0;
				try { DebugEnterSubRule(11);
				while (true)
				{
					int alt11=2;
					try { DebugEnterDecision(11, false);
					int LA11_1 = input.LA(1);

					if (((LA11_1>='0' && LA11_1<='9')))
					{
						alt11 = 1;
					}


					} finally { DebugExitDecision(11); }
					switch (alt11)
					{
					case 1:
						DebugEnterAlt(1);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
						{
						DebugLocation(202, 74);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt11 >= 1)
							goto loop11;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee11 = new EarlyExitException( 11, input );
						DebugRecognitionException(eee11);
						throw eee11;
					}
					cnt11++;
				}
				loop11:
					;

				} finally { DebugExitSubRule(11); }


				}
				break;

			}
			} finally { DebugExitSubRule(12); }


			}

		}
		finally
		{
			TraceOut("NUMBER", 12);
			LeaveRule("NUMBER", 12);
			LeaveRule_NUMBER();
		}
	}
	// $ANTLR end "NUMBER"

	partial void EnterRule_LINECOMMENT1();
	partial void LeaveRule_LINECOMMENT1();

	// $ANTLR start "LINECOMMENT1"
	[GrammarRule("LINECOMMENT1")]
	private void mLINECOMMENT1()
	{
		EnterRule_LINECOMMENT1();
		EnterRule("LINECOMMENT1", 13);
		TraceIn("LINECOMMENT1", 13);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:208:23: ({...}? => '%' (~ ( '\\r' | '\\n' ) )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:208:25: {...}? => '%' (~ ( '\\r' | '\\n' ) )*
			{
			DebugLocation(208, 25);
			if (!((!Spaces_SpacesPrecedeInLine())))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "LINECOMMENT1", "!Spaces_SpacesPrecedeInLine()");
			}
			DebugLocation(208, 60);
			Match('%'); if (state.failed) return;
			DebugLocation(208, 64);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:208:64: (~ ( '\\r' | '\\n' ) )*
			try { DebugEnterSubRule(13);
			while (true)
			{
				int alt13=2;
				try { DebugEnterDecision(13, false);
				int LA13_1 = input.LA(1);

				if (((LA13_1>='\u0000' && LA13_1<='\t')||(LA13_1>='\u000B' && LA13_1<='\f')||(LA13_1>='\u000E' && LA13_1<='\uFFFF')))
				{
					alt13 = 1;
				}


				} finally { DebugExitDecision(13); }
				switch ( alt13 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
					{
					DebugLocation(208, 64);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop13;
				}
			}

			loop13:
				;

			} finally { DebugExitSubRule(13); }


			}

		}
		finally
		{
			TraceOut("LINECOMMENT1", 13);
			LeaveRule("LINECOMMENT1", 13);
			LeaveRule_LINECOMMENT1();
		}
	}
	// $ANTLR end "LINECOMMENT1"

	partial void EnterRule_LINECOMMENT2();
	partial void LeaveRule_LINECOMMENT2();

	// $ANTLR start "LINECOMMENT2"
	[GrammarRule("LINECOMMENT2")]
	private void mLINECOMMENT2()
	{
		EnterRule_LINECOMMENT2();
		EnterRule("LINECOMMENT2", 14);
		TraceIn("LINECOMMENT2", 14);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:210:23: ({...}? => '%' '{' ( WS )* ~ ( ' ' | '\\t' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:210:25: {...}? => '%' '{' ( WS )* ~ ( ' ' | '\\t' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )*
			{
			DebugLocation(210, 25);
			if (!((Spaces_SpacesPrecedeInLine())))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "LINECOMMENT2", "Spaces_SpacesPrecedeInLine()");
			}
			DebugLocation(210, 59);
			Match('%'); if (state.failed) return;
			DebugLocation(210, 63);
			Match('{'); if (state.failed) return;
			DebugLocation(210, 67);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:210:67: ( WS )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if ((LA14_1=='\t'||LA14_1==' '))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
					{
					DebugLocation(210, 67);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }

			DebugLocation(210, 73);
			if ((input.LA(1)>='\u0000' && input.LA(1)<='\b')||(input.LA(1)>='\u000B' && input.LA(1)<='\f')||(input.LA(1)>='\u000E' && input.LA(1)<='\u001F')||(input.LA(1)>='!' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(210, 101);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:210:101: (~ ( '\\r' | '\\n' ) )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if (((LA15_1>='\u0000' && LA15_1<='\t')||(LA15_1>='\u000B' && LA15_1<='\f')||(LA15_1>='\u000E' && LA15_1<='\uFFFF')))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
					{
					DebugLocation(210, 101);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }


			}

		}
		finally
		{
			TraceOut("LINECOMMENT2", 14);
			LeaveRule("LINECOMMENT2", 14);
			LeaveRule_LINECOMMENT2();
		}
	}
	// $ANTLR end "LINECOMMENT2"

	partial void EnterRule_LINECOMMENT3();
	partial void LeaveRule_LINECOMMENT3();

	// $ANTLR start "LINECOMMENT3"
	[GrammarRule("LINECOMMENT3")]
	private void mLINECOMMENT3()
	{
		EnterRule_LINECOMMENT3();
		EnterRule("LINECOMMENT3", 15);
		TraceIn("LINECOMMENT3", 15);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:212:23: ({...}? => '%' (~ ( '{' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* )? )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:212:25: {...}? => '%' (~ ( '{' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* )?
			{
			DebugLocation(212, 25);
			if (!((Spaces_SpacesPrecedeInLine())))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "LINECOMMENT3", "Spaces_SpacesPrecedeInLine()");
			}
			DebugLocation(212, 59);
			Match('%'); if (state.failed) return;
			DebugLocation(212, 63);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:212:63: (~ ( '{' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if (((LA17_1>='\u0000' && LA17_1<='\t')||(LA17_1>='\u000B' && LA17_1<='\f')||(LA17_1>='\u000E' && LA17_1<='z')||(LA17_1>='|' && LA17_1<='\uFFFF')))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:212:64: ~ ( '{' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )*
				{
				DebugLocation(212, 64);
				input.Consume();
				state.failed=false;
				DebugLocation(212, 85);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:212:85: (~ ( '\\r' | '\\n' ) )*
				try { DebugEnterSubRule(16);
				while (true)
				{
					int alt16=2;
					try { DebugEnterDecision(16, false);
					int LA16_1 = input.LA(1);

					if (((LA16_1>='\u0000' && LA16_1<='\t')||(LA16_1>='\u000B' && LA16_1<='\f')||(LA16_1>='\u000E' && LA16_1<='\uFFFF')))
					{
						alt16 = 1;
					}


					} finally { DebugExitDecision(16); }
					switch ( alt16 )
					{
					case 1:
						DebugEnterAlt(1);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
						{
						DebugLocation(212, 85);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						goto loop16;
					}
				}

				loop16:
					;

				} finally { DebugExitSubRule(16); }


				}
				break;

			}
			} finally { DebugExitSubRule(17); }


			}

		}
		finally
		{
			TraceOut("LINECOMMENT3", 15);
			LeaveRule("LINECOMMENT3", 15);
			LeaveRule_LINECOMMENT3();
		}
	}
	// $ANTLR end "LINECOMMENT3"

	partial void EnterRule_BLOCKCOMMENT();
	partial void LeaveRule_BLOCKCOMMENT();

	// $ANTLR start "BLOCKCOMMENT"
	[GrammarRule("BLOCKCOMMENT")]
	private void mBLOCKCOMMENT()
	{
		EnterRule_BLOCKCOMMENT();
		EnterRule("BLOCKCOMMENT", 16);
		TraceIn("BLOCKCOMMENT", 16);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:214:23: ({...}? => '%' '{' ( WS )* EOL ( ( WS )* BLOCKCOMMENT | ( WS )* EOL | ( WS )* ~ ( '%' | ' ' | '\\t' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* EOL | ( WS )* '%' EOL | ( WS )* '%' ~ ( '{' | '}' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* EOL | ( WS )* '%' ( '{' | '}' ) ( WS )* ~ ( ' ' | '\\t' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* EOL )* ( WS )* '%' '}' ( WS )* EOL )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:214:25: {...}? => '%' '{' ( WS )* EOL ( ( WS )* BLOCKCOMMENT | ( WS )* EOL | ( WS )* ~ ( '%' | ' ' | '\\t' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* EOL | ( WS )* '%' EOL | ( WS )* '%' ~ ( '{' | '}' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* EOL | ( WS )* '%' ( '{' | '}' ) ( WS )* ~ ( ' ' | '\\t' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* EOL )* ( WS )* '%' '}' ( WS )* EOL
			{
			DebugLocation(214, 25);
			if (!((Spaces_SpacesPrecedeInLine())))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "BLOCKCOMMENT", "Spaces_SpacesPrecedeInLine()");
			}
			DebugLocation(215, 25);
			Match('%'); if (state.failed) return;
			DebugLocation(215, 29);
			Match('{'); if (state.failed) return;
			DebugLocation(215, 33);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:215:33: ( WS )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1=='\t'||LA18_1==' '))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
					{
					DebugLocation(215, 33);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }

			DebugLocation(215, 39);
			mEOL(); if (state.failed) return;
			DebugLocation(216, 25);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:216:25: ( ( WS )* BLOCKCOMMENT | ( WS )* EOL | ( WS )* ~ ( '%' | ' ' | '\\t' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* EOL | ( WS )* '%' EOL | ( WS )* '%' ~ ( '{' | '}' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* EOL | ( WS )* '%' ( '{' | '}' ) ( WS )* ~ ( ' ' | '\\t' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* EOL )*
			try { DebugEnterSubRule(29);
			while (true)
			{
				int alt29=7;
				try { DebugEnterDecision(29, false);
				try
				{
					alt29 = dfa29.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(29); }
				switch ( alt29 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:216:30: ( WS )* BLOCKCOMMENT
					{
					DebugLocation(216, 30);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:216:30: ( WS )*
					try { DebugEnterSubRule(19);
					while (true)
					{
						int alt19=2;
						try { DebugEnterDecision(19, false);
						int LA19_1 = input.LA(1);

						if ((LA19_1=='\t'||LA19_1==' '))
						{
							alt19 = 1;
						}


						} finally { DebugExitDecision(19); }
						switch ( alt19 )
						{
						case 1:
							DebugEnterAlt(1);
							// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
							{
							DebugLocation(216, 30);
							input.Consume();
							state.failed=false;

							}
							break;

						default:
							goto loop19;
						}
					}

					loop19:
						;

					} finally { DebugExitSubRule(19); }

					DebugLocation(216, 36);
					mBLOCKCOMMENT(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:217:19: ( WS )* EOL
					{
					DebugLocation(217, 19);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:217:19: ( WS )*
					try { DebugEnterSubRule(20);
					while (true)
					{
						int alt20=2;
						try { DebugEnterDecision(20, false);
						int LA20_1 = input.LA(1);

						if ((LA20_1=='\t'||LA20_1==' '))
						{
							alt20 = 1;
						}


						} finally { DebugExitDecision(20); }
						switch ( alt20 )
						{
						case 1:
							DebugEnterAlt(1);
							// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
							{
							DebugLocation(217, 19);
							input.Consume();
							state.failed=false;

							}
							break;

						default:
							goto loop20;
						}
					}

					loop20:
						;

					} finally { DebugExitSubRule(20); }

					DebugLocation(217, 25);
					mEOL(); if (state.failed) return;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:218:19: ( WS )* ~ ( '%' | ' ' | '\\t' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* EOL
					{
					DebugLocation(218, 19);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:218:19: ( WS )*
					try { DebugEnterSubRule(21);
					while (true)
					{
						int alt21=2;
						try { DebugEnterDecision(21, false);
						int LA21_1 = input.LA(1);

						if ((LA21_1=='\t'||LA21_1==' '))
						{
							alt21 = 1;
						}


						} finally { DebugExitDecision(21); }
						switch ( alt21 )
						{
						case 1:
							DebugEnterAlt(1);
							// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
							{
							DebugLocation(218, 19);
							input.Consume();
							state.failed=false;

							}
							break;

						default:
							goto loop21;
						}
					}

					loop21:
						;

					} finally { DebugExitSubRule(21); }

					DebugLocation(218, 25);
					input.Consume();
					state.failed=false;
					DebugLocation(218, 59);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:218:59: (~ ( '\\r' | '\\n' ) )*
					try { DebugEnterSubRule(22);
					while (true)
					{
						int alt22=2;
						try { DebugEnterDecision(22, false);
						int LA22_1 = input.LA(1);

						if (((LA22_1>='\u0000' && LA22_1<='\t')||(LA22_1>='\u000B' && LA22_1<='\f')||(LA22_1>='\u000E' && LA22_1<='\uFFFF')))
						{
							alt22 = 1;
						}


						} finally { DebugExitDecision(22); }
						switch ( alt22 )
						{
						case 1:
							DebugEnterAlt(1);
							// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
							{
							DebugLocation(218, 59);
							input.Consume();
							state.failed=false;

							}
							break;

						default:
							goto loop22;
						}
					}

					loop22:
						;

					} finally { DebugExitSubRule(22); }

					DebugLocation(218, 77);
					mEOL(); if (state.failed) return;

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:219:19: ( WS )* '%' EOL
					{
					DebugLocation(219, 19);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:219:19: ( WS )*
					try { DebugEnterSubRule(23);
					while (true)
					{
						int alt23=2;
						try { DebugEnterDecision(23, false);
						int LA23_1 = input.LA(1);

						if ((LA23_1=='\t'||LA23_1==' '))
						{
							alt23 = 1;
						}


						} finally { DebugExitDecision(23); }
						switch ( alt23 )
						{
						case 1:
							DebugEnterAlt(1);
							// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
							{
							DebugLocation(219, 19);
							input.Consume();
							state.failed=false;

							}
							break;

						default:
							goto loop23;
						}
					}

					loop23:
						;

					} finally { DebugExitSubRule(23); }

					DebugLocation(219, 25);
					Match('%'); if (state.failed) return;
					DebugLocation(219, 29);
					mEOL(); if (state.failed) return;

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:220:19: ( WS )* '%' ~ ( '{' | '}' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* EOL
					{
					DebugLocation(220, 19);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:220:19: ( WS )*
					try { DebugEnterSubRule(24);
					while (true)
					{
						int alt24=2;
						try { DebugEnterDecision(24, false);
						int LA24_1 = input.LA(1);

						if ((LA24_1=='\t'||LA24_1==' '))
						{
							alt24 = 1;
						}


						} finally { DebugExitDecision(24); }
						switch ( alt24 )
						{
						case 1:
							DebugEnterAlt(1);
							// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
							{
							DebugLocation(220, 19);
							input.Consume();
							state.failed=false;

							}
							break;

						default:
							goto loop24;
						}
					}

					loop24:
						;

					} finally { DebugExitSubRule(24); }

					DebugLocation(220, 25);
					Match('%'); if (state.failed) return;
					DebugLocation(220, 29);
					input.Consume();
					state.failed=false;
					DebugLocation(220, 56);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:220:56: (~ ( '\\r' | '\\n' ) )*
					try { DebugEnterSubRule(25);
					while (true)
					{
						int alt25=2;
						try { DebugEnterDecision(25, false);
						int LA25_1 = input.LA(1);

						if (((LA25_1>='\u0000' && LA25_1<='\t')||(LA25_1>='\u000B' && LA25_1<='\f')||(LA25_1>='\u000E' && LA25_1<='\uFFFF')))
						{
							alt25 = 1;
						}


						} finally { DebugExitDecision(25); }
						switch ( alt25 )
						{
						case 1:
							DebugEnterAlt(1);
							// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
							{
							DebugLocation(220, 56);
							input.Consume();
							state.failed=false;

							}
							break;

						default:
							goto loop25;
						}
					}

					loop25:
						;

					} finally { DebugExitSubRule(25); }

					DebugLocation(220, 74);
					mEOL(); if (state.failed) return;

					}
					break;
				case 6:
					DebugEnterAlt(6);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:221:19: ( WS )* '%' ( '{' | '}' ) ( WS )* ~ ( ' ' | '\\t' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* EOL
					{
					DebugLocation(221, 19);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:221:19: ( WS )*
					try { DebugEnterSubRule(26);
					while (true)
					{
						int alt26=2;
						try { DebugEnterDecision(26, false);
						int LA26_1 = input.LA(1);

						if ((LA26_1=='\t'||LA26_1==' '))
						{
							alt26 = 1;
						}


						} finally { DebugExitDecision(26); }
						switch ( alt26 )
						{
						case 1:
							DebugEnterAlt(1);
							// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
							{
							DebugLocation(221, 19);
							input.Consume();
							state.failed=false;

							}
							break;

						default:
							goto loop26;
						}
					}

					loop26:
						;

					} finally { DebugExitSubRule(26); }

					DebugLocation(221, 25);
					Match('%'); if (state.failed) return;
					DebugLocation(221, 29);
					input.Consume();
					state.failed=false;
					DebugLocation(221, 41);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:221:41: ( WS )*
					try { DebugEnterSubRule(27);
					while (true)
					{
						int alt27=2;
						try { DebugEnterDecision(27, false);
						int LA27_1 = input.LA(1);

						if ((LA27_1=='\t'||LA27_1==' '))
						{
							alt27 = 1;
						}


						} finally { DebugExitDecision(27); }
						switch ( alt27 )
						{
						case 1:
							DebugEnterAlt(1);
							// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
							{
							DebugLocation(221, 41);
							input.Consume();
							state.failed=false;

							}
							break;

						default:
							goto loop27;
						}
					}

					loop27:
						;

					} finally { DebugExitSubRule(27); }

					DebugLocation(221, 47);
					input.Consume();
					state.failed=false;
					DebugLocation(221, 75);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:221:75: (~ ( '\\r' | '\\n' ) )*
					try { DebugEnterSubRule(28);
					while (true)
					{
						int alt28=2;
						try { DebugEnterDecision(28, false);
						int LA28_1 = input.LA(1);

						if (((LA28_1>='\u0000' && LA28_1<='\t')||(LA28_1>='\u000B' && LA28_1<='\f')||(LA28_1>='\u000E' && LA28_1<='\uFFFF')))
						{
							alt28 = 1;
						}


						} finally { DebugExitDecision(28); }
						switch ( alt28 )
						{
						case 1:
							DebugEnterAlt(1);
							// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
							{
							DebugLocation(221, 75);
							input.Consume();
							state.failed=false;

							}
							break;

						default:
							goto loop28;
						}
					}

					loop28:
						;

					} finally { DebugExitSubRule(28); }

					DebugLocation(221, 93);
					mEOL(); if (state.failed) return;

					}
					break;

				default:
					goto loop29;
				}
			}

			loop29:
				;

			} finally { DebugExitSubRule(29); }

			DebugLocation(223, 25);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:223:25: ( WS )*
			try { DebugEnterSubRule(30);
			while (true)
			{
				int alt30=2;
				try { DebugEnterDecision(30, false);
				int LA30_1 = input.LA(1);

				if ((LA30_1=='\t'||LA30_1==' '))
				{
					alt30 = 1;
				}


				} finally { DebugExitDecision(30); }
				switch ( alt30 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
					{
					DebugLocation(223, 25);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop30;
				}
			}

			loop30:
				;

			} finally { DebugExitSubRule(30); }

			DebugLocation(223, 31);
			Match('%'); if (state.failed) return;
			DebugLocation(223, 35);
			Match('}'); if (state.failed) return;
			DebugLocation(223, 39);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:223:39: ( WS )*
			try { DebugEnterSubRule(31);
			while (true)
			{
				int alt31=2;
				try { DebugEnterDecision(31, false);
				int LA31_1 = input.LA(1);

				if ((LA31_1=='\t'||LA31_1==' '))
				{
					alt31 = 1;
				}


				} finally { DebugExitDecision(31); }
				switch ( alt31 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
					{
					DebugLocation(223, 39);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop31;
				}
			}

			loop31:
				;

			} finally { DebugExitSubRule(31); }

			DebugLocation(223, 45);
			mEOL(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("BLOCKCOMMENT", 16);
			LeaveRule("BLOCKCOMMENT", 16);
			LeaveRule_BLOCKCOMMENT();
		}
	}
	// $ANTLR end "BLOCKCOMMENT"

	partial void EnterRule_ELLIPSIS();
	partial void LeaveRule_ELLIPSIS();

	// $ANTLR start "ELLIPSIS"
	[GrammarRule("ELLIPSIS")]
	private void mELLIPSIS()
	{
		EnterRule_ELLIPSIS();
		EnterRule("ELLIPSIS", 17);
		TraceIn("ELLIPSIS", 17);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:227:19: ({...}? => '...' (~ ( '\\r' | '\\n' ) )* EOL )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:227:21: {...}? => '...' (~ ( '\\r' | '\\n' ) )* EOL
			{
			DebugLocation(227, 21);
			if (!((Text_ThreeDotsFollow())))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "ELLIPSIS", "Text_ThreeDotsFollow()");
			}
			DebugLocation(227, 49);
			Match("..."); if (state.failed) return;

			DebugLocation(227, 55);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:227:55: (~ ( '\\r' | '\\n' ) )*
			try { DebugEnterSubRule(32);
			while (true)
			{
				int alt32=2;
				try { DebugEnterDecision(32, false);
				int LA32_1 = input.LA(1);

				if (((LA32_1>='\u0000' && LA32_1<='\t')||(LA32_1>='\u000B' && LA32_1<='\f')||(LA32_1>='\u000E' && LA32_1<='\uFFFF')))
				{
					alt32 = 1;
				}


				} finally { DebugExitDecision(32); }
				switch ( alt32 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
					{
					DebugLocation(227, 55);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop32;
				}
			}

			loop32:
				;

			} finally { DebugExitSubRule(32); }

			DebugLocation(227, 73);
			mEOL(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("ELLIPSIS", 17);
			LeaveRule("ELLIPSIS", 17);
			LeaveRule_ELLIPSIS();
		}
	}
	// $ANTLR end "ELLIPSIS"

	partial void EnterRule_SPACES();
	partial void LeaveRule_SPACES();

	// $ANTLR start "SPACES"
	[GrammarRule("SPACES")]
	private void mSPACES()
	{
		EnterRule_SPACES();
		EnterRule("SPACES", 18);
		TraceIn("SPACES", 18);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:229:17: ( ( WS )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:229:19: ( WS )+
			{
			DebugLocation(229, 19);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:229:19: ( WS )+
			int cnt33=0;
			try { DebugEnterSubRule(33);
			while (true)
			{
				int alt33=2;
				try { DebugEnterDecision(33, false);
				int LA33_1 = input.LA(1);

				if ((LA33_1=='\t'||LA33_1==' '))
				{
					alt33 = 1;
				}


				} finally { DebugExitDecision(33); }
				switch (alt33)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
					{
					DebugLocation(229, 19);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt33 >= 1)
						goto loop33;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee33 = new EarlyExitException( 33, input );
					DebugRecognitionException(eee33);
					throw eee33;
				}
				cnt33++;
			}
			loop33:
				;

			} finally { DebugExitSubRule(33); }


			}

		}
		finally
		{
			TraceOut("SPACES", 18);
			LeaveRule("SPACES", 18);
			LeaveRule_SPACES();
		}
	}
	// $ANTLR end "SPACES"

	partial void EnterRule_EOL();
	partial void LeaveRule_EOL();

	// $ANTLR start "EOL"
	[GrammarRule("EOL")]
	private void mEOL()
	{
		EnterRule_EOL();
		EnterRule("EOL", 19);
		TraceIn("EOL", 19);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:231:14: ( '\\r\\n' | '\\r' | '\\n' )
			int alt34=3;
			try { DebugEnterDecision(34, false);
			int LA34_1 = input.LA(1);

			if ((LA34_1=='\r'))
			{
				int LA34_2 = input.LA(2);

				if ((LA34_2=='\n'))
				{
					alt34 = 1;
				}
				else
				{
					alt34 = 2;
				}
			}
			else if ((LA34_1=='\n'))
			{
				alt34 = 3;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 34, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:231:16: '\\r\\n'
				{
				DebugLocation(231, 16);
				Match("\r\n"); if (state.failed) return;


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:231:25: '\\r'
				{
				DebugLocation(231, 25);
				Match('\r'); if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:231:32: '\\n'
				{
				DebugLocation(231, 32);
				Match('\n'); if (state.failed) return;

				}
				break;

			}
		}
		finally
		{
			TraceOut("EOL", 19);
			LeaveRule("EOL", 19);
			LeaveRule_EOL();
		}
	}
	// $ANTLR end "EOL"

	partial void EnterRule_STRING();
	partial void LeaveRule_STRING();

	// $ANTLR start "STRING"
	[GrammarRule("STRING")]
	private void mSTRING()
	{
		EnterRule_STRING();
		EnterRule("STRING", 20);
		TraceIn("STRING", 20);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:235:17: ({...}? => '\\'' ( '\\'\\'' |~ ( '\\'' | '\\r' | '\\n' ) )* '\\'' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:235:19: {...}? => '\\'' ( '\\'\\'' |~ ( '\\'' | '\\r' | '\\n' ) )* '\\''
			{
			DebugLocation(235, 19);
			if (!((!Quotation_TransposeIsEnabled())))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "STRING", "!Quotation_TransposeIsEnabled()");
			}
			DebugLocation(235, 56);
			Match('\''); if (state.failed) return;
			DebugLocation(235, 61);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:235:61: ( '\\'\\'' |~ ( '\\'' | '\\r' | '\\n' ) )*
			try { DebugEnterSubRule(35);
			while (true)
			{
				int alt35=3;
				try { DebugEnterDecision(35, false);
				int LA35_1 = input.LA(1);

				if ((LA35_1=='\''))
				{
					int LA35_2 = input.LA(2);

					if ((LA35_2=='\''))
					{
						alt35 = 1;
					}


				}
				else if (((LA35_1>='\u0000' && LA35_1<='\t')||(LA35_1>='\u000B' && LA35_1<='\f')||(LA35_1>='\u000E' && LA35_1<='&')||(LA35_1>='(' && LA35_1<='\uFFFF')))
				{
					alt35 = 2;
				}


				} finally { DebugExitDecision(35); }
				switch ( alt35 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:235:62: '\\'\\''
					{
					DebugLocation(235, 62);
					Match("''"); if (state.failed) return;


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:235:71: ~ ( '\\'' | '\\r' | '\\n' )
					{
					DebugLocation(235, 71);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop35;
				}
			}

			loop35:
				;

			} finally { DebugExitSubRule(35); }

			DebugLocation(235, 95);
			Match('\''); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("STRING", 20);
			LeaveRule("STRING", 20);
			LeaveRule_STRING();
		}
	}
	// $ANTLR end "STRING"

	partial void EnterRule_QUOTATION();
	partial void LeaveRule_QUOTATION();

	// $ANTLR start "QUOTATION"
	[GrammarRule("QUOTATION")]
	private void mQUOTATION()
	{
		EnterRule_QUOTATION();
		EnterRule("QUOTATION", 21);
		TraceIn("QUOTATION", 21);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:237:20: ({...}? => '\\'' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:237:22: {...}? => '\\''
			{
			DebugLocation(237, 22);
			if (!((!Quotation_TransposeIsEnabled())))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "QUOTATION", "!Quotation_TransposeIsEnabled()");
			}
			DebugLocation(237, 59);
			Match('\''); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("QUOTATION", 21);
			LeaveRule("QUOTATION", 21);
			LeaveRule_QUOTATION();
		}
	}
	// $ANTLR end "QUOTATION"

	partial void EnterRule_CTRANS();
	partial void LeaveRule_CTRANS();

	// $ANTLR start "CTRANS"
	[GrammarRule("CTRANS")]
	private void mCTRANS()
	{
		EnterRule_CTRANS();
		EnterRule("CTRANS", 22);
		TraceIn("CTRANS", 22);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:239:17: ({...}? => '\\'' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:239:19: {...}? => '\\''
			{
			DebugLocation(239, 19);
			if (!((Quotation_TransposeIsEnabled())))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "CTRANS", "Quotation_TransposeIsEnabled()");
			}
			DebugLocation(239, 55);
			Match('\''); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("CTRANS", 22);
			LeaveRule("CTRANS", 22);
			LeaveRule_CTRANS();
		}
	}
	// $ANTLR end "CTRANS"

	partial void EnterRule_REAL();
	partial void LeaveRule_REAL();

	// $ANTLR start "REAL"
	[GrammarRule("REAL")]
	private void mREAL()
	{
		EnterRule_REAL();
		EnterRule("REAL", 23);
		TraceIn("REAL", 23);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:243:15: ( NUMBER )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:243:17: NUMBER
			{
			DebugLocation(243, 17);
			mNUMBER(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("REAL", 23);
			LeaveRule("REAL", 23);
			LeaveRule_REAL();
		}
	}
	// $ANTLR end "REAL"

	partial void EnterRule_IMAGINARY();
	partial void LeaveRule_IMAGINARY();

	// $ANTLR start "IMAGINARY"
	[GrammarRule("IMAGINARY")]
	private void mIMAGINARY()
	{
		EnterRule_IMAGINARY();
		EnterRule("IMAGINARY", 24);
		TraceIn("IMAGINARY", 24);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:245:20: ( NUMBER IMG )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:245:22: NUMBER IMG
			{
			DebugLocation(245, 22);
			mNUMBER(); if (state.failed) return;
			DebugLocation(245, 29);
			mIMG(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("IMAGINARY", 24);
			LeaveRule("IMAGINARY", 24);
			LeaveRule_IMAGINARY();
		}
	}
	// $ANTLR end "IMAGINARY"

	partial void EnterRule_ID();
	partial void LeaveRule_ID();

	// $ANTLR start "ID"
	[GrammarRule("ID")]
	private void mID()
	{
		EnterRule_ID();
		EnterRule("ID", 25);
		TraceIn("ID", 25);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:247:13: ( LETTER ( '_' | LETTER | DIGIT )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:247:15: LETTER ( '_' | LETTER | DIGIT )*
			{
			DebugLocation(247, 15);
			mLETTER(); if (state.failed) return;
			DebugLocation(247, 22);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:247:22: ( '_' | LETTER | DIGIT )*
			try { DebugEnterSubRule(36);
			while (true)
			{
				int alt36=2;
				try { DebugEnterDecision(36, false);
				int LA36_1 = input.LA(1);

				if (((LA36_1>='0' && LA36_1<='9')||(LA36_1>='A' && LA36_1<='Z')||LA36_1=='_'||(LA36_1>='a' && LA36_1<='z')))
				{
					alt36 = 1;
				}


				} finally { DebugExitDecision(36); }
				switch ( alt36 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
					{
					DebugLocation(247, 22);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop36;
				}
			}

			loop36:
				;

			} finally { DebugExitSubRule(36); }


			}

		}
		finally
		{
			TraceOut("ID", 25);
			LeaveRule("ID", 25);
			LeaveRule_ID();
		}
	}
	// $ANTLR end "ID"

	partial void EnterRule_PLUS();
	partial void LeaveRule_PLUS();

	// $ANTLR start "PLUS"
	[GrammarRule("PLUS")]
	private void mPLUS()
	{
		EnterRule_PLUS();
		EnterRule("PLUS", 26);
		TraceIn("PLUS", 26);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:251:15: ( '+' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:251:17: '+'
			{
			DebugLocation(251, 17);
			Match('+'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("PLUS", 26);
			LeaveRule("PLUS", 26);
			LeaveRule_PLUS();
		}
	}
	// $ANTLR end "PLUS"

	partial void EnterRule_MINUS();
	partial void LeaveRule_MINUS();

	// $ANTLR start "MINUS"
	[GrammarRule("MINUS")]
	private void mMINUS()
	{
		EnterRule_MINUS();
		EnterRule("MINUS", 27);
		TraceIn("MINUS", 27);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:253:16: ( '-' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:253:18: '-'
			{
			DebugLocation(253, 18);
			Match('-'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("MINUS", 27);
			LeaveRule("MINUS", 27);
			LeaveRule_MINUS();
		}
	}
	// $ANTLR end "MINUS"

	partial void EnterRule_MTIMES();
	partial void LeaveRule_MTIMES();

	// $ANTLR start "MTIMES"
	[GrammarRule("MTIMES")]
	private void mMTIMES()
	{
		EnterRule_MTIMES();
		EnterRule("MTIMES", 28);
		TraceIn("MTIMES", 28);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:255:17: ( '*' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:255:19: '*'
			{
			DebugLocation(255, 19);
			Match('*'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("MTIMES", 28);
			LeaveRule("MTIMES", 28);
			LeaveRule_MTIMES();
		}
	}
	// $ANTLR end "MTIMES"

	partial void EnterRule_TIMES();
	partial void LeaveRule_TIMES();

	// $ANTLR start "TIMES"
	[GrammarRule("TIMES")]
	private void mTIMES()
	{
		EnterRule_TIMES();
		EnterRule("TIMES", 29);
		TraceIn("TIMES", 29);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:257:16: ( '.*' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:257:18: '.*'
			{
			DebugLocation(257, 18);
			Match(".*"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("TIMES", 29);
			LeaveRule("TIMES", 29);
			LeaveRule_TIMES();
		}
	}
	// $ANTLR end "TIMES"

	partial void EnterRule_MRDIV();
	partial void LeaveRule_MRDIV();

	// $ANTLR start "MRDIV"
	[GrammarRule("MRDIV")]
	private void mMRDIV()
	{
		EnterRule_MRDIV();
		EnterRule("MRDIV", 30);
		TraceIn("MRDIV", 30);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:259:16: ( '/' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:259:18: '/'
			{
			DebugLocation(259, 18);
			Match('/'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("MRDIV", 30);
			LeaveRule("MRDIV", 30);
			LeaveRule_MRDIV();
		}
	}
	// $ANTLR end "MRDIV"

	partial void EnterRule_RDIV();
	partial void LeaveRule_RDIV();

	// $ANTLR start "RDIV"
	[GrammarRule("RDIV")]
	private void mRDIV()
	{
		EnterRule_RDIV();
		EnterRule("RDIV", 31);
		TraceIn("RDIV", 31);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:261:15: ( './' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:261:17: './'
			{
			DebugLocation(261, 17);
			Match("./"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("RDIV", 31);
			LeaveRule("RDIV", 31);
			LeaveRule_RDIV();
		}
	}
	// $ANTLR end "RDIV"

	partial void EnterRule_MLDIV();
	partial void LeaveRule_MLDIV();

	// $ANTLR start "MLDIV"
	[GrammarRule("MLDIV")]
	private void mMLDIV()
	{
		EnterRule_MLDIV();
		EnterRule("MLDIV", 32);
		TraceIn("MLDIV", 32);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:263:16: ( '\\\\' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:263:18: '\\\\'
			{
			DebugLocation(263, 18);
			Match('\\'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("MLDIV", 32);
			LeaveRule("MLDIV", 32);
			LeaveRule_MLDIV();
		}
	}
	// $ANTLR end "MLDIV"

	partial void EnterRule_LDIV();
	partial void LeaveRule_LDIV();

	// $ANTLR start "LDIV"
	[GrammarRule("LDIV")]
	private void mLDIV()
	{
		EnterRule_LDIV();
		EnterRule("LDIV", 33);
		TraceIn("LDIV", 33);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:265:15: ( '.\\\\' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:265:17: '.\\\\'
			{
			DebugLocation(265, 17);
			Match(".\\"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("LDIV", 33);
			LeaveRule("LDIV", 33);
			LeaveRule_LDIV();
		}
	}
	// $ANTLR end "LDIV"

	partial void EnterRule_MPOW();
	partial void LeaveRule_MPOW();

	// $ANTLR start "MPOW"
	[GrammarRule("MPOW")]
	private void mMPOW()
	{
		EnterRule_MPOW();
		EnterRule("MPOW", 34);
		TraceIn("MPOW", 34);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:267:15: ( '^' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:267:17: '^'
			{
			DebugLocation(267, 17);
			Match('^'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("MPOW", 34);
			LeaveRule("MPOW", 34);
			LeaveRule_MPOW();
		}
	}
	// $ANTLR end "MPOW"

	partial void EnterRule_POW();
	partial void LeaveRule_POW();

	// $ANTLR start "POW"
	[GrammarRule("POW")]
	private void mPOW()
	{
		EnterRule_POW();
		EnterRule("POW", 35);
		TraceIn("POW", 35);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:269:14: ( '.^' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:269:16: '.^'
			{
			DebugLocation(269, 16);
			Match(".^"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("POW", 35);
			LeaveRule("POW", 35);
			LeaveRule_POW();
		}
	}
	// $ANTLR end "POW"

	partial void EnterRule_TRANS();
	partial void LeaveRule_TRANS();

	// $ANTLR start "TRANS"
	[GrammarRule("TRANS")]
	private void mTRANS()
	{
		EnterRule_TRANS();
		EnterRule("TRANS", 36);
		TraceIn("TRANS", 36);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:271:16: ( '.\\'' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:271:18: '.\\''
			{
			DebugLocation(271, 18);
			Match(".'"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("TRANS", 36);
			LeaveRule("TRANS", 36);
			LeaveRule_TRANS();
		}
	}
	// $ANTLR end "TRANS"

	partial void EnterRule_EQ();
	partial void LeaveRule_EQ();

	// $ANTLR start "EQ"
	[GrammarRule("EQ")]
	private void mEQ()
	{
		EnterRule_EQ();
		EnterRule("EQ", 37);
		TraceIn("EQ", 37);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:275:13: ( '==' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:275:15: '=='
			{
			DebugLocation(275, 15);
			Match("=="); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("EQ", 37);
			LeaveRule("EQ", 37);
			LeaveRule_EQ();
		}
	}
	// $ANTLR end "EQ"

	partial void EnterRule_NOTEQ();
	partial void LeaveRule_NOTEQ();

	// $ANTLR start "NOTEQ"
	[GrammarRule("NOTEQ")]
	private void mNOTEQ()
	{
		EnterRule_NOTEQ();
		EnterRule("NOTEQ", 38);
		TraceIn("NOTEQ", 38);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:277:16: ( '~=' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:277:18: '~='
			{
			DebugLocation(277, 18);
			Match("~="); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("NOTEQ", 38);
			LeaveRule("NOTEQ", 38);
			LeaveRule_NOTEQ();
		}
	}
	// $ANTLR end "NOTEQ"

	partial void EnterRule_LT();
	partial void LeaveRule_LT();

	// $ANTLR start "LT"
	[GrammarRule("LT")]
	private void mLT()
	{
		EnterRule_LT();
		EnterRule("LT", 39);
		TraceIn("LT", 39);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:279:13: ( '<' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:279:15: '<'
			{
			DebugLocation(279, 15);
			Match('<'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("LT", 39);
			LeaveRule("LT", 39);
			LeaveRule_LT();
		}
	}
	// $ANTLR end "LT"

	partial void EnterRule_LTEQ();
	partial void LeaveRule_LTEQ();

	// $ANTLR start "LTEQ"
	[GrammarRule("LTEQ")]
	private void mLTEQ()
	{
		EnterRule_LTEQ();
		EnterRule("LTEQ", 40);
		TraceIn("LTEQ", 40);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:281:15: ( '<=' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:281:17: '<='
			{
			DebugLocation(281, 17);
			Match("<="); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("LTEQ", 40);
			LeaveRule("LTEQ", 40);
			LeaveRule_LTEQ();
		}
	}
	// $ANTLR end "LTEQ"

	partial void EnterRule_GT();
	partial void LeaveRule_GT();

	// $ANTLR start "GT"
	[GrammarRule("GT")]
	private void mGT()
	{
		EnterRule_GT();
		EnterRule("GT", 41);
		TraceIn("GT", 41);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:283:13: ( '>' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:283:15: '>'
			{
			DebugLocation(283, 15);
			Match('>'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("GT", 41);
			LeaveRule("GT", 41);
			LeaveRule_GT();
		}
	}
	// $ANTLR end "GT"

	partial void EnterRule_GTEQ();
	partial void LeaveRule_GTEQ();

	// $ANTLR start "GTEQ"
	[GrammarRule("GTEQ")]
	private void mGTEQ()
	{
		EnterRule_GTEQ();
		EnterRule("GTEQ", 42);
		TraceIn("GTEQ", 42);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:285:15: ( '>=' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:285:17: '>='
			{
			DebugLocation(285, 17);
			Match(">="); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("GTEQ", 42);
			LeaveRule("GTEQ", 42);
			LeaveRule_GTEQ();
		}
	}
	// $ANTLR end "GTEQ"

	partial void EnterRule_NOT();
	partial void LeaveRule_NOT();

	// $ANTLR start "NOT"
	[GrammarRule("NOT")]
	private void mNOT()
	{
		EnterRule_NOT();
		EnterRule("NOT", 43);
		TraceIn("NOT", 43);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:289:14: ( '~' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:289:16: '~'
			{
			DebugLocation(289, 16);
			Match('~'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("NOT", 43);
			LeaveRule("NOT", 43);
			LeaveRule_NOT();
		}
	}
	// $ANTLR end "NOT"

	partial void EnterRule_AND();
	partial void LeaveRule_AND();

	// $ANTLR start "AND"
	[GrammarRule("AND")]
	private void mAND()
	{
		EnterRule_AND();
		EnterRule("AND", 44);
		TraceIn("AND", 44);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:291:14: ( '&' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:291:16: '&'
			{
			DebugLocation(291, 16);
			Match('&'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("AND", 44);
			LeaveRule("AND", 44);
			LeaveRule_AND();
		}
	}
	// $ANTLR end "AND"

	partial void EnterRule_SHORTAND();
	partial void LeaveRule_SHORTAND();

	// $ANTLR start "SHORTAND"
	[GrammarRule("SHORTAND")]
	private void mSHORTAND()
	{
		EnterRule_SHORTAND();
		EnterRule("SHORTAND", 45);
		TraceIn("SHORTAND", 45);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:293:19: ( '&&' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:293:21: '&&'
			{
			DebugLocation(293, 21);
			Match("&&"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("SHORTAND", 45);
			LeaveRule("SHORTAND", 45);
			LeaveRule_SHORTAND();
		}
	}
	// $ANTLR end "SHORTAND"

	partial void EnterRule_OR();
	partial void LeaveRule_OR();

	// $ANTLR start "OR"
	[GrammarRule("OR")]
	private void mOR()
	{
		EnterRule_OR();
		EnterRule("OR", 46);
		TraceIn("OR", 46);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:295:13: ( '|' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:295:15: '|'
			{
			DebugLocation(295, 15);
			Match('|'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("OR", 46);
			LeaveRule("OR", 46);
			LeaveRule_OR();
		}
	}
	// $ANTLR end "OR"

	partial void EnterRule_SHORTOR();
	partial void LeaveRule_SHORTOR();

	// $ANTLR start "SHORTOR"
	[GrammarRule("SHORTOR")]
	private void mSHORTOR()
	{
		EnterRule_SHORTOR();
		EnterRule("SHORTOR", 47);
		TraceIn("SHORTOR", 47);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:297:18: ( '||' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:297:20: '||'
			{
			DebugLocation(297, 20);
			Match("||"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("SHORTOR", 47);
			LeaveRule("SHORTOR", 47);
			LeaveRule_SHORTOR();
		}
	}
	// $ANTLR end "SHORTOR"

	partial void EnterRule_ASSIGN();
	partial void LeaveRule_ASSIGN();

	// $ANTLR start "ASSIGN"
	[GrammarRule("ASSIGN")]
	private void mASSIGN()
	{
		EnterRule_ASSIGN();
		EnterRule("ASSIGN", 48);
		TraceIn("ASSIGN", 48);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:301:17: ( '=' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:301:19: '='
			{
			DebugLocation(301, 19);
			Match('='); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("ASSIGN", 48);
			LeaveRule("ASSIGN", 48);
			LeaveRule_ASSIGN();
		}
	}
	// $ANTLR end "ASSIGN"

	partial void EnterRule_COMMA();
	partial void LeaveRule_COMMA();

	// $ANTLR start "COMMA"
	[GrammarRule("COMMA")]
	private void mCOMMA()
	{
		EnterRule_COMMA();
		EnterRule("COMMA", 49);
		TraceIn("COMMA", 49);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:303:16: ( ',' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:303:18: ','
			{
			DebugLocation(303, 18);
			Match(','); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("COMMA", 49);
			LeaveRule("COMMA", 49);
			LeaveRule_COMMA();
		}
	}
	// $ANTLR end "COMMA"

	partial void EnterRule_SEMICOLON();
	partial void LeaveRule_SEMICOLON();

	// $ANTLR start "SEMICOLON"
	[GrammarRule("SEMICOLON")]
	private void mSEMICOLON()
	{
		EnterRule_SEMICOLON();
		EnterRule("SEMICOLON", 50);
		TraceIn("SEMICOLON", 50);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:305:20: ( ';' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:305:22: ';'
			{
			DebugLocation(305, 22);
			Match(';'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("SEMICOLON", 50);
			LeaveRule("SEMICOLON", 50);
			LeaveRule_SEMICOLON();
		}
	}
	// $ANTLR end "SEMICOLON"

	partial void EnterRule_COLON();
	partial void LeaveRule_COLON();

	// $ANTLR start "COLON"
	[GrammarRule("COLON")]
	private void mCOLON()
	{
		EnterRule_COLON();
		EnterRule("COLON", 51);
		TraceIn("COLON", 51);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:307:16: ( ':' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:307:18: ':'
			{
			DebugLocation(307, 18);
			Match(':'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("COLON", 51);
			LeaveRule("COLON", 51);
			LeaveRule_COLON();
		}
	}
	// $ANTLR end "COLON"

	partial void EnterRule_DOT();
	partial void LeaveRule_DOT();

	// $ANTLR start "DOT"
	[GrammarRule("DOT")]
	private void mDOT()
	{
		EnterRule_DOT();
		EnterRule("DOT", 52);
		TraceIn("DOT", 52);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:309:14: ( '.' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:309:16: '.'
			{
			DebugLocation(309, 16);
			Match('.'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("DOT", 52);
			LeaveRule("DOT", 52);
			LeaveRule_DOT();
		}
	}
	// $ANTLR end "DOT"

	partial void EnterRule_LPAREN();
	partial void LeaveRule_LPAREN();

	// $ANTLR start "LPAREN"
	[GrammarRule("LPAREN")]
	private void mLPAREN()
	{
		EnterRule_LPAREN();
		EnterRule("LPAREN", 53);
		TraceIn("LPAREN", 53);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:311:17: ( '(' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:311:19: '('
			{
			DebugLocation(311, 19);
			Match('('); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("LPAREN", 53);
			LeaveRule("LPAREN", 53);
			LeaveRule_LPAREN();
		}
	}
	// $ANTLR end "LPAREN"

	partial void EnterRule_RPAREN();
	partial void LeaveRule_RPAREN();

	// $ANTLR start "RPAREN"
	[GrammarRule("RPAREN")]
	private void mRPAREN()
	{
		EnterRule_RPAREN();
		EnterRule("RPAREN", 54);
		TraceIn("RPAREN", 54);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:313:17: ( ')' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:313:19: ')'
			{
			DebugLocation(313, 19);
			Match(')'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("RPAREN", 54);
			LeaveRule("RPAREN", 54);
			LeaveRule_RPAREN();
		}
	}
	// $ANTLR end "RPAREN"

	partial void EnterRule_LSQUARE();
	partial void LeaveRule_LSQUARE();

	// $ANTLR start "LSQUARE"
	[GrammarRule("LSQUARE")]
	private void mLSQUARE()
	{
		EnterRule_LSQUARE();
		EnterRule("LSQUARE", 55);
		TraceIn("LSQUARE", 55);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:315:18: ( '[' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:315:20: '['
			{
			DebugLocation(315, 20);
			Match('['); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("LSQUARE", 55);
			LeaveRule("LSQUARE", 55);
			LeaveRule_LSQUARE();
		}
	}
	// $ANTLR end "LSQUARE"

	partial void EnterRule_RSQUARE();
	partial void LeaveRule_RSQUARE();

	// $ANTLR start "RSQUARE"
	[GrammarRule("RSQUARE")]
	private void mRSQUARE()
	{
		EnterRule_RSQUARE();
		EnterRule("RSQUARE", 56);
		TraceIn("RSQUARE", 56);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:317:18: ( ']' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:317:20: ']'
			{
			DebugLocation(317, 20);
			Match(']'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("RSQUARE", 56);
			LeaveRule("RSQUARE", 56);
			LeaveRule_RSQUARE();
		}
	}
	// $ANTLR end "RSQUARE"

	partial void EnterRule_LCURLY();
	partial void LeaveRule_LCURLY();

	// $ANTLR start "LCURLY"
	[GrammarRule("LCURLY")]
	private void mLCURLY()
	{
		EnterRule_LCURLY();
		EnterRule("LCURLY", 57);
		TraceIn("LCURLY", 57);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:319:17: ( '{' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:319:19: '{'
			{
			DebugLocation(319, 19);
			Match('{'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("LCURLY", 57);
			LeaveRule("LCURLY", 57);
			LeaveRule_LCURLY();
		}
	}
	// $ANTLR end "LCURLY"

	partial void EnterRule_RCURLY();
	partial void LeaveRule_RCURLY();

	// $ANTLR start "RCURLY"
	[GrammarRule("RCURLY")]
	private void mRCURLY()
	{
		EnterRule_RCURLY();
		EnterRule("RCURLY", 58);
		TraceIn("RCURLY", 58);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:321:17: ( '}' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:321:19: '}'
			{
			DebugLocation(321, 19);
			Match('}'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("RCURLY", 58);
			LeaveRule("RCURLY", 58);
			LeaveRule_RCURLY();
		}
	}
	// $ANTLR end "RCURLY"

	partial void EnterRule_AT();
	partial void LeaveRule_AT();

	// $ANTLR start "AT"
	[GrammarRule("AT")]
	private void mAT()
	{
		EnterRule_AT();
		EnterRule("AT", 59);
		TraceIn("AT", 59);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:323:13: ( '@' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:323:15: '@'
			{
			DebugLocation(323, 15);
			Match('@'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("AT", 59);
			LeaveRule("AT", 59);
			LeaveRule_AT();
		}
	}
	// $ANTLR end "AT"

	partial void EnterRule_QUESTION();
	partial void LeaveRule_QUESTION();

	// $ANTLR start "QUESTION"
	[GrammarRule("QUESTION")]
	private void mQUESTION()
	{
		EnterRule_QUESTION();
		EnterRule("QUESTION", 60);
		TraceIn("QUESTION", 60);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:325:19: ( '?' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:325:21: '?'
			{
			DebugLocation(325, 21);
			Match('?'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("QUESTION", 60);
			LeaveRule("QUESTION", 60);
			LeaveRule_QUESTION();
		}
	}
	// $ANTLR end "QUESTION"

	partial void EnterRule_EXCLAMATION();
	partial void LeaveRule_EXCLAMATION();

	// $ANTLR start "EXCLAMATION"
	[GrammarRule("EXCLAMATION")]
	private void mEXCLAMATION()
	{
		EnterRule_EXCLAMATION();
		EnterRule("EXCLAMATION", 61);
		TraceIn("EXCLAMATION", 61);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:327:22: ( '!' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:327:24: '!'
			{
			DebugLocation(327, 24);
			Match('!'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("EXCLAMATION", 61);
			LeaveRule("EXCLAMATION", 61);
			LeaveRule_EXCLAMATION();
		}
	}
	// $ANTLR end "EXCLAMATION"

	partial void EnterRule_UNKNOWN();
	partial void LeaveRule_UNKNOWN();

	// $ANTLR start "UNKNOWN"
	[GrammarRule("UNKNOWN")]
	private void mUNKNOWN()
	{
		EnterRule_UNKNOWN();
		EnterRule("UNKNOWN", 62);
		TraceIn("UNKNOWN", 62);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:331:18: (~ ( '%' | '.' | ' ' | '\\t' | '\\r' | '\\n' | '0' .. '9' | '\\'' | 'a' .. 'z' | 'A' .. 'Z' | '+' | '-' | '*' | '\\\\' | '/' | '^' | '=' | '~' | '<' | '>' | '&' | '|' | ',' | ';' | ':' | '(' | '[' | '{' | ')' | ']' | '}' | '@' | '?' | '!' ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
			{
			DebugLocation(331, 18);
			if ((input.LA(1)>='\u0000' && input.LA(1)<='\b')||(input.LA(1)>='\u000B' && input.LA(1)<='\f')||(input.LA(1)>='\u000E' && input.LA(1)<='\u001F')||(input.LA(1)>='\"' && input.LA(1)<='$')||(input.LA(1)>='_' && input.LA(1)<='`')||(input.LA(1)>='\u007F' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("UNKNOWN", 62);
			LeaveRule("UNKNOWN", 62);
			LeaveRule_UNKNOWN();
		}
	}
	// $ANTLR end "UNKNOWN"

	partial void EnterRule_STRINGBLOCK();
	partial void LeaveRule_STRINGBLOCK();

	// $ANTLR start "STRINGBLOCK"
	[GrammarRule("STRINGBLOCK")]
	private void mSTRINGBLOCK()
	{
		EnterRule_STRINGBLOCK();
		EnterRule("STRINGBLOCK", 63);
		TraceIn("STRINGBLOCK", 63);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:335:22: ( '\\'' ( '\\'\\'' |~ ( '\\'' | '\\r' | '\\n' ) )* '\\'' )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:335:24: '\\'' ( '\\'\\'' |~ ( '\\'' | '\\r' | '\\n' ) )* '\\''
			{
			DebugLocation(335, 24);
			Match('\''); if (state.failed) return;
			DebugLocation(335, 29);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:335:29: ( '\\'\\'' |~ ( '\\'' | '\\r' | '\\n' ) )*
			try { DebugEnterSubRule(37);
			while (true)
			{
				int alt37=3;
				try { DebugEnterDecision(37, false);
				int LA37_1 = input.LA(1);

				if ((LA37_1=='\''))
				{
					int LA37_2 = input.LA(2);

					if ((LA37_2=='\''))
					{
						alt37 = 1;
					}


				}
				else if (((LA37_1>='\u0000' && LA37_1<='\t')||(LA37_1>='\u000B' && LA37_1<='\f')||(LA37_1>='\u000E' && LA37_1<='&')||(LA37_1>='(' && LA37_1<='\uFFFF')))
				{
					alt37 = 2;
				}


				} finally { DebugExitDecision(37); }
				switch ( alt37 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:335:30: '\\'\\''
					{
					DebugLocation(335, 30);
					Match("''"); if (state.failed) return;


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:335:39: ~ ( '\\'' | '\\r' | '\\n' )
					{
					DebugLocation(335, 39);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop37;
				}
			}

			loop37:
				;

			} finally { DebugExitSubRule(37); }

			DebugLocation(335, 63);
			Match('\''); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("STRINGBLOCK", 63);
			LeaveRule("STRINGBLOCK", 63);
			LeaveRule_STRINGBLOCK();
		}
	}
	// $ANTLR end "STRINGBLOCK"

	partial void EnterRule_DEFAULTBLOCK1();
	partial void LeaveRule_DEFAULTBLOCK1();

	// $ANTLR start "DEFAULTBLOCK1"
	[GrammarRule("DEFAULTBLOCK1")]
	private void mDEFAULTBLOCK1()
	{
		EnterRule_DEFAULTBLOCK1();
		EnterRule("DEFAULTBLOCK1", 64);
		TraceIn("DEFAULTBLOCK1", 64);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:337:24: ( ( '(' | '[' | '{' ) ( DEFAULTBLOCK1 | DEFAULTBLOCK3 |~ ( '(' | '[' | '{' | ')' | ']' | '}' | '.' | ';' | '\\r' | '\\n' ) )* ( ')' | ']' | '}' )? )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:337:26: ( '(' | '[' | '{' ) ( DEFAULTBLOCK1 | DEFAULTBLOCK3 |~ ( '(' | '[' | '{' | ')' | ']' | '}' | '.' | ';' | '\\r' | '\\n' ) )* ( ')' | ']' | '}' )?
			{
			DebugLocation(337, 26);
			if (input.LA(1)=='('||input.LA(1)=='['||input.LA(1)=='{')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(337, 44);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:337:44: ( DEFAULTBLOCK1 | DEFAULTBLOCK3 |~ ( '(' | '[' | '{' | ')' | ']' | '}' | '.' | ';' | '\\r' | '\\n' ) )*
			try { DebugEnterSubRule(38);
			while (true)
			{
				int alt38=4;
				try { DebugEnterDecision(38, false);
				int LA38_1 = input.LA(1);

				if ((LA38_1=='('||LA38_1=='['||LA38_1=='{'))
				{
					alt38 = 1;
				}
				else if ((LA38_1=='.') && ((!Text_ThreeDotsFollow())))
				{
					alt38 = 2;
				}
				else if (((LA38_1>='\u0000' && LA38_1<='\t')||(LA38_1>='\u000B' && LA38_1<='\f')||(LA38_1>='\u000E' && LA38_1<='\'')||(LA38_1>='*' && LA38_1<='-')||(LA38_1>='/' && LA38_1<=':')||(LA38_1>='<' && LA38_1<='Z')||LA38_1=='\\'||(LA38_1>='^' && LA38_1<='z')||LA38_1=='|'||(LA38_1>='~' && LA38_1<='\uFFFF')))
				{
					alt38 = 3;
				}


				} finally { DebugExitDecision(38); }
				switch ( alt38 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:337:45: DEFAULTBLOCK1
					{
					DebugLocation(337, 45);
					mDEFAULTBLOCK1(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:337:61: DEFAULTBLOCK3
					{
					DebugLocation(337, 61);
					mDEFAULTBLOCK3(); if (state.failed) return;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:337:77: ~ ( '(' | '[' | '{' | ')' | ']' | '}' | '.' | ';' | '\\r' | '\\n' )
					{
					DebugLocation(337, 77);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop38;
				}
			}

			loop38:
				;

			} finally { DebugExitSubRule(38); }

			DebugLocation(337, 142);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:337:142: ( ')' | ']' | '}' )?
			int alt39=2;
			try { DebugEnterSubRule(39);
			try { DebugEnterDecision(39, false);
			int LA39_1 = input.LA(1);

			if ((LA39_1==')'||LA39_1==']'||LA39_1=='}'))
			{
				alt39 = 1;
			}
			} finally { DebugExitDecision(39); }
			switch (alt39)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
				{
				DebugLocation(337, 142);
				input.Consume();
				state.failed=false;

				}
				break;

			}
			} finally { DebugExitSubRule(39); }


			}

		}
		finally
		{
			TraceOut("DEFAULTBLOCK1", 64);
			LeaveRule("DEFAULTBLOCK1", 64);
			LeaveRule_DEFAULTBLOCK1();
		}
	}
	// $ANTLR end "DEFAULTBLOCK1"

	partial void EnterRule_DEFAULTBLOCK2();
	partial void LeaveRule_DEFAULTBLOCK2();

	// $ANTLR start "DEFAULTBLOCK2"
	[GrammarRule("DEFAULTBLOCK2")]
	private void mDEFAULTBLOCK2()
	{
		EnterRule_DEFAULTBLOCK2();
		EnterRule("DEFAULTBLOCK2", 65);
		TraceIn("DEFAULTBLOCK2", 65);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:339:24: ( ( ')' | ']' | '}' ) ( DEFAULTBLOCK2 | DEFAULTBLOCK3 |~ ( '(' | '[' | '{' | ')' | ']' | '}' | '.' | ';' | '\\r' | '\\n' ) )* ( '(' | '[' | '{' )? )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:339:26: ( ')' | ']' | '}' ) ( DEFAULTBLOCK2 | DEFAULTBLOCK3 |~ ( '(' | '[' | '{' | ')' | ']' | '}' | '.' | ';' | '\\r' | '\\n' ) )* ( '(' | '[' | '{' )?
			{
			DebugLocation(339, 26);
			if (input.LA(1)==')'||input.LA(1)==']'||input.LA(1)=='}')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(339, 44);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:339:44: ( DEFAULTBLOCK2 | DEFAULTBLOCK3 |~ ( '(' | '[' | '{' | ')' | ']' | '}' | '.' | ';' | '\\r' | '\\n' ) )*
			try { DebugEnterSubRule(40);
			while (true)
			{
				int alt40=4;
				try { DebugEnterDecision(40, false);
				int LA40_1 = input.LA(1);

				if ((LA40_1==')'||LA40_1==']'||LA40_1=='}'))
				{
					alt40 = 1;
				}
				else if ((LA40_1=='.') && ((!Text_ThreeDotsFollow())))
				{
					alt40 = 2;
				}
				else if (((LA40_1>='\u0000' && LA40_1<='\t')||(LA40_1>='\u000B' && LA40_1<='\f')||(LA40_1>='\u000E' && LA40_1<='\'')||(LA40_1>='*' && LA40_1<='-')||(LA40_1>='/' && LA40_1<=':')||(LA40_1>='<' && LA40_1<='Z')||LA40_1=='\\'||(LA40_1>='^' && LA40_1<='z')||LA40_1=='|'||(LA40_1>='~' && LA40_1<='\uFFFF')))
				{
					alt40 = 3;
				}


				} finally { DebugExitDecision(40); }
				switch ( alt40 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:339:45: DEFAULTBLOCK2
					{
					DebugLocation(339, 45);
					mDEFAULTBLOCK2(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:339:61: DEFAULTBLOCK3
					{
					DebugLocation(339, 61);
					mDEFAULTBLOCK3(); if (state.failed) return;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:339:77: ~ ( '(' | '[' | '{' | ')' | ']' | '}' | '.' | ';' | '\\r' | '\\n' )
					{
					DebugLocation(339, 77);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop40;
				}
			}

			loop40:
				;

			} finally { DebugExitSubRule(40); }

			DebugLocation(339, 142);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:339:142: ( '(' | '[' | '{' )?
			int alt41=2;
			try { DebugEnterSubRule(41);
			try { DebugEnterDecision(41, false);
			int LA41_1 = input.LA(1);

			if ((LA41_1=='('||LA41_1=='['||LA41_1=='{'))
			{
				alt41 = 1;
			}
			} finally { DebugExitDecision(41); }
			switch (alt41)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
				{
				DebugLocation(339, 142);
				input.Consume();
				state.failed=false;

				}
				break;

			}
			} finally { DebugExitSubRule(41); }


			}

		}
		finally
		{
			TraceOut("DEFAULTBLOCK2", 65);
			LeaveRule("DEFAULTBLOCK2", 65);
			LeaveRule_DEFAULTBLOCK2();
		}
	}
	// $ANTLR end "DEFAULTBLOCK2"

	partial void EnterRule_DEFAULTBLOCK3();
	partial void LeaveRule_DEFAULTBLOCK3();

	// $ANTLR start "DEFAULTBLOCK3"
	[GrammarRule("DEFAULTBLOCK3")]
	private void mDEFAULTBLOCK3()
	{
		EnterRule_DEFAULTBLOCK3();
		EnterRule("DEFAULTBLOCK3", 66);
		TraceIn("DEFAULTBLOCK3", 66);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:341:24: ({...}? => '.' ( '.' )? )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:341:26: {...}? => '.' ( '.' )?
			{
			DebugLocation(341, 26);
			if (!((!Text_ThreeDotsFollow())))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "DEFAULTBLOCK3", "!Text_ThreeDotsFollow()");
			}
			DebugLocation(341, 55);
			Match('.'); if (state.failed) return;
			DebugLocation(341, 59);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:341:59: ( '.' )?
			int alt42=2;
			try { DebugEnterSubRule(42);
			try { DebugEnterDecision(42, false);
			int LA42_1 = input.LA(1);

			if ((LA42_1=='.'))
			{
				alt42 = 1;
			}
			} finally { DebugExitDecision(42); }
			switch (alt42)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:341:60: '.'
				{
				DebugLocation(341, 60);
				Match('.'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(42); }


			}

		}
		finally
		{
			TraceOut("DEFAULTBLOCK3", 66);
			LeaveRule("DEFAULTBLOCK3", 66);
			LeaveRule_DEFAULTBLOCK3();
		}
	}
	// $ANTLR end "DEFAULTBLOCK3"

	partial void EnterRule_DEFAULTBLOCK4();
	partial void LeaveRule_DEFAULTBLOCK4();

	// $ANTLR start "DEFAULTBLOCK4"
	[GrammarRule("DEFAULTBLOCK4")]
	private void mDEFAULTBLOCK4()
	{
		EnterRule_DEFAULTBLOCK4();
		EnterRule("DEFAULTBLOCK4", 67);
		TraceIn("DEFAULTBLOCK4", 67);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:343:24: ( (~ ( '\\'' | '(' | '[' | '{' | ')' | ']' | '}' | '.' | '%' | ' ' | '\\t' | ',' | ';' | '\\r' | '\\n' ) )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:343:26: (~ ( '\\'' | '(' | '[' | '{' | ')' | ']' | '}' | '.' | '%' | ' ' | '\\t' | ',' | ';' | '\\r' | '\\n' ) )+
			{
			DebugLocation(343, 26);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:343:26: (~ ( '\\'' | '(' | '[' | '{' | ')' | ']' | '}' | '.' | '%' | ' ' | '\\t' | ',' | ';' | '\\r' | '\\n' ) )+
			int cnt43=0;
			try { DebugEnterSubRule(43);
			while (true)
			{
				int alt43=2;
				try { DebugEnterDecision(43, false);
				int LA43_1 = input.LA(1);

				if (((LA43_1>='\u0000' && LA43_1<='\b')||(LA43_1>='\u000B' && LA43_1<='\f')||(LA43_1>='\u000E' && LA43_1<='\u001F')||(LA43_1>='!' && LA43_1<='$')||LA43_1=='&'||(LA43_1>='*' && LA43_1<='+')||LA43_1=='-'||(LA43_1>='/' && LA43_1<=':')||(LA43_1>='<' && LA43_1<='Z')||LA43_1=='\\'||(LA43_1>='^' && LA43_1<='z')||LA43_1=='|'||(LA43_1>='~' && LA43_1<='\uFFFF')))
				{
					alt43 = 1;
				}


				} finally { DebugExitDecision(43); }
				switch (alt43)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
					{
					DebugLocation(343, 26);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt43 >= 1)
						goto loop43;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee43 = new EarlyExitException( 43, input );
					DebugRecognitionException(eee43);
					throw eee43;
				}
				cnt43++;
			}
			loop43:
				;

			} finally { DebugExitSubRule(43); }


			}

		}
		finally
		{
			TraceOut("DEFAULTBLOCK4", 67);
			LeaveRule("DEFAULTBLOCK4", 67);
			LeaveRule_DEFAULTBLOCK4();
		}
	}
	// $ANTLR end "DEFAULTBLOCK4"

	partial void EnterRule_LINE();
	partial void LeaveRule_LINE();

	// $ANTLR start "LINE"
	[GrammarRule("LINE")]
	private void mLINE()
	{
		EnterRule_LINE();
		EnterRule("LINE", 68);
		TraceIn("LINE", 68);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:347:15: ( (~ ( '\\r' | '\\n' ) )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:347:17: (~ ( '\\r' | '\\n' ) )+
			{
			DebugLocation(347, 17);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:347:17: (~ ( '\\r' | '\\n' ) )+
			int cnt44=0;
			try { DebugEnterSubRule(44);
			while (true)
			{
				int alt44=2;
				try { DebugEnterDecision(44, false);
				int LA44_1 = input.LA(1);

				if (((LA44_1>='\u0000' && LA44_1<='\t')||(LA44_1>='\u000B' && LA44_1<='\f')||(LA44_1>='\u000E' && LA44_1<='\uFFFF')))
				{
					alt44 = 1;
				}


				} finally { DebugExitDecision(44); }
				switch (alt44)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:
					{
					DebugLocation(347, 17);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt44 >= 1)
						goto loop44;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee44 = new EarlyExitException( 44, input );
					DebugRecognitionException(eee44);
					throw eee44;
				}
				cnt44++;
			}
			loop44:
				;

			} finally { DebugExitSubRule(44); }


			}

		}
		finally
		{
			TraceOut("LINE", 68);
			LeaveRule("LINE", 68);
			LeaveRule_LINE();
		}
	}
	// $ANTLR end "LINE"

	public override void mTokens()
	{
		// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:1:8: ( START )
		DebugEnterAlt(1);
		// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:1:10: START
		{
		DebugLocation(1, 10);
		mSTART(); if (state.failed) return;

		}


	}

	partial void EnterRule_synpred1_MatlabLexer_fragment();
	partial void LeaveRule_synpred1_MatlabLexer_fragment();

	// $ANTLR start synpred1_MatlabLexer
	private void synpred1_MatlabLexer_fragment()
	{
		EnterRule_synpred1_MatlabLexer_fragment();
		EnterRule("synpred1_MatlabLexer_fragment", 70);
		TraceIn("synpred1_MatlabLexer_fragment", 70);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:121:10: ( STRING )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabLexer.g3:121:11: STRING
			{
			DebugLocation(121, 11);
			mSTRING(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_MatlabLexer_fragment", 70);
			LeaveRule("synpred1_MatlabLexer_fragment", 70);
			LeaveRule_synpred1_MatlabLexer_fragment();
		}
	}
	// $ANTLR end synpred1_MatlabLexer

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	DFA2 dfa2;
	DFA3 dfa3;
	DFA29 dfa29;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa2 = new DFA2(this, SpecialStateTransition2);
		dfa3 = new DFA3(this, SpecialStateTransition3);
		dfa29 = new DFA29(this, SpecialStateTransition29);
	}

	private class DFA2 : DFA
	{
		private const string DFA2_eotS =
			"\x2\xFFFF\x1\x2B\x3\xFFFF\x1\x32\x7\xFFFF\x1\x35\x1\x37\x1\x39\x1\x3B"+
			"\x1\x3D\x1\x3F\x16\xFFFF\x1\x32\x5\xFFFF\x1\x32\x12\xFFFF\x1\x32\x1\xFFFF"+
			"\x1\x32";
		private const string DFA2_eofS =
			"\x46\xFFFF";
		private const string DFA2_minS =
			"\x1\x0\x1\x7B\x1\x27\x2\xFFFF\x1\x0\x1\x2E\x7\xFFFF\x4\x3D\x1\x26\x1"+
			"\x7C\xD\xFFFF\x1\x0\x8\xFFFF\x1\x30\x5\xFFFF\x1\x30\x1\x2B\xE\xFFFF\x1"+
			"\x0\x2\xFFFF\x3\x30";
		private const string DFA2_maxS =
			"\x1\xFFFF\x1\x7B\x1\x5E\x2\xFFFF\x1\xFFFF\x1\x6A\x7\xFFFF\x4\x3D\x1\x26"+
			"\x1\x7C\xD\xFFFF\x1\xFFFF\x8\xFFFF\x1\x6A\x5\xFFFF\x1\x6A\x1\x39\xE\xFFFF"+
			"\x1\xFFFF\x2\xFFFF\x1\x6A\x1\x39\x1\x6A";
		private const string DFA2_acceptS =
			"\x3\xFFFF\x1\x6\x1\x7\x2\xFFFF\x1\xD\x1\xE\x1\xF\x1\x10\x1\x12\x1\x14"+
			"\x1\x16\x6\xFFFF\x1\x25\x1\x26\x1\x27\x1\x29\x1\x2A\x1\x2B\x1\x2C\x1"+
			"\x2D\x1\x2E\x1\x2F\x1\x30\x1\x31\x1\x32\x1\xFFFF\x1\x1\x1\x3\x1\x5\x1"+
			"\x11\x1\x13\x1\x15\x1\x17\x1\x18\x1\xFFFF\x1\x28\x2\x8\x1\x9\x1\xA\x2"+
			"\xFFFF\x1\xB\x1\xC\x1\x19\x1\x24\x1\x1A\x1\x1F\x1\x1C\x1\x1B\x1\x1E\x1"+
			"\x1D\x1\x21\x1\x20\x1\x23\x1\x22\x1\xFFFF\x1\x2\x1\x4\x3\xFFFF";
		private const string DFA2_specialS =
			"\x1\x0\x1\x1\x1\x2\x2\xFFFF\x1\x3\x1B\xFFFF\x1\x4\x1E\xFFFF\x1\x5\x5"+
			"\xFFFF}>";
		private static readonly string[] DFA2_transitionS =
			{
				"\x9\x20\x1\x3\x1\x4\x2\x20\x1\x4\x12\x20\x1\x3\x1\x1F\x3\x20\x1\x1\x1"+
				"\x12\x1\x5\x1\x17\x1\x18\x1\xA\x1\x8\x1\x14\x1\x9\x1\x2\x1\xB\xA\x6"+
				"\x1\x16\x1\x15\x1\x10\x1\xE\x1\x11\x1\x1E\x1\x1D\x1A\x7\x1\x19\x1\xC"+
				"\x1\x1A\x1\xD\x2\x20\x1A\x7\x1\x1B\x1\x13\x1\x1C\x1\xF\xFF81\x20",
				"\x1\x21",
				"\x1\x29\x2\xFFFF\x1\x25\x3\xFFFF\x1\x24\x1\x26\xA\x2A\x22\xFFFF\x1\x27"+
				"\x1\xFFFF\x1\x28",
				"",
				"",
				"\xA\x2D\x1\xFFFF\x2\x2D\x1\xFFFF\x19\x2D\x1\x2C\xFFD8\x2D",
				"\x1\x30\x1\xFFFF\xA\x6\xA\xFFFF\x2\x31\x1E\xFFFF\x2\x31\x3\xFFFF\x2"+
				"\x33",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x34",
				"\x1\x36",
				"\x1\x38",
				"\x1\x3A",
				"\x1\x3C",
				"\x1\x3E",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x9\x41\x1\x40\x1\x42\x2\x41\x1\x42\x12\x41\x1\x40\xFFDF\x41",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\xA\x2A\xA\xFFFF\x2\x31\x1E\xFFFF\x2\x31\x3\xFFFF\x2\x33",
				"",
				"",
				"",
				"",
				"",
				"\xA\x43\xA\xFFFF\x2\x31\x1E\xFFFF\x2\x31\x3\xFFFF\x2\x33",
				"\x1\x44\x1\xFFFF\x1\x44\x2\xFFFF\xA\x45",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x9\x41\x1\x40\x1\x42\x2\x41\x1\x42\x12\x41\x1\x40\xFFDF\x41",
				"",
				"",
				"\xA\x43\xA\xFFFF\x2\x31\x1E\xFFFF\x2\x31\x3\xFFFF\x2\x33",
				"\xA\x45",
				"\xA\x45\x2F\xFFFF\x2\x33"
			};

		private static readonly short[] DFA2_eot = DFA.UnpackEncodedString(DFA2_eotS);
		private static readonly short[] DFA2_eof = DFA.UnpackEncodedString(DFA2_eofS);
		private static readonly char[] DFA2_min = DFA.UnpackEncodedStringToUnsignedChars(DFA2_minS);
		private static readonly char[] DFA2_max = DFA.UnpackEncodedStringToUnsignedChars(DFA2_maxS);
		private static readonly short[] DFA2_accept = DFA.UnpackEncodedString(DFA2_acceptS);
		private static readonly short[] DFA2_special = DFA.UnpackEncodedString(DFA2_specialS);
		private static readonly short[][] DFA2_transition;

		static DFA2()
		{
			int numStates = DFA2_transitionS.Length;
			DFA2_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA2_transition[i] = DFA.UnpackEncodedString(DFA2_transitionS[i]);
			}
		}

		public DFA2( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 2;
			this.eot = DFA2_eot;
			this.eof = DFA2_eof;
			this.min = DFA2_min;
			this.max = DFA2_max;
			this.accept = DFA2_accept;
			this.special = DFA2_special;
			this.transition = DFA2_transition;
		}

		public override string Description { get { return "114:10: fragment DEFAULT_MODE : ( LINECOMMENT1 | LINECOMMENT2 | LINECOMMENT3 | BLOCKCOMMENT | ELLIPSIS | SPACES | EOL | ( STRING )=> STRING | QUOTATION | CTRANS | REAL | IMAGINARY | ID | PLUS | MINUS | MTIMES | TIMES | MRDIV | RDIV | MLDIV | LDIV | MPOW | POW | TRANS | EQ | NOTEQ | LT | LTEQ | GT | GTEQ | NOT | AND | SHORTAND | OR | SHORTOR | ASSIGN | COMMA | SEMICOLON | COLON | DOT | LPAREN | RPAREN | LSQUARE | RSQUARE | LCURLY | RCURLY | AT | QUESTION | EXCLAMATION | UNKNOWN );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition2(DFA dfa, int s, IIntStream _input)
	{
		IIntStream input = _input;
		int _s = s;
		s = -1;
		int LA2_1 = input.LA(1);
		int index2_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				input.Rewind();
				if ((LA2_1=='%') && (((!Spaces_SpacesPrecedeInLine())||(Spaces_SpacesPrecedeInLine())))) {s = 1;}

				else if ((LA2_1=='.')) {s = 2;}

				else if ((LA2_1=='\t'||LA2_1==' ')) {s = 3;}

				else if ((LA2_1=='\n'||LA2_1=='\r')) {s = 4;}

				else if ((LA2_1=='\'') && (((!Quotation_TransposeIsEnabled())||(Quotation_TransposeIsEnabled())))) {s = 5;}

				else if (((LA2_1>='0' && LA2_1<='9'))) {s = 6;}

				else if (((LA2_1>='A' && LA2_1<='Z')||(LA2_1>='a' && LA2_1<='z'))) {s = 7;}

				else if ((LA2_1=='+')) {s = 8;}

				else if ((LA2_1=='-')) {s = 9;}

				else if ((LA2_1=='*')) {s = 10;}

				else if ((LA2_1=='/')) {s = 11;}

				else if ((LA2_1=='\\')) {s = 12;}

				else if ((LA2_1=='^')) {s = 13;}

				else if ((LA2_1=='=')) {s = 14;}

				else if ((LA2_1=='~')) {s = 15;}

				else if ((LA2_1=='<')) {s = 16;}

				else if ((LA2_1=='>')) {s = 17;}

				else if ((LA2_1=='&')) {s = 18;}

				else if ((LA2_1=='|')) {s = 19;}

				else if ((LA2_1==',')) {s = 20;}

				else if ((LA2_1==';')) {s = 21;}

				else if ((LA2_1==':')) {s = 22;}

				else if ((LA2_1=='(')) {s = 23;}

				else if ((LA2_1==')')) {s = 24;}

				else if ((LA2_1=='[')) {s = 25;}

				else if ((LA2_1==']')) {s = 26;}

				else if ((LA2_1=='{')) {s = 27;}

				else if ((LA2_1=='}')) {s = 28;}

				else if ((LA2_1=='@')) {s = 29;}

				else if ((LA2_1=='?')) {s = 30;}

				else if ((LA2_1=='!')) {s = 31;}

				else if (((LA2_1>='\u0000' && LA2_1<='\b')||(LA2_1>='\u000B' && LA2_1<='\f')||(LA2_1>='\u000E' && LA2_1<='\u001F')||(LA2_1>='\"' && LA2_1<='$')||(LA2_1>='_' && LA2_1<='`')||(LA2_1>='\u007F' && LA2_1<='\uFFFF'))) {s = 32;}

				input.Seek(index2_1);
				break;
			}
		case 1:
			{
				input.Rewind();
				if ((LA2_1=='{') && ((Spaces_SpacesPrecedeInLine()))) {s = 33;}

				else if (((!Spaces_SpacesPrecedeInLine()))) {s = 34;}

				else if (((Spaces_SpacesPrecedeInLine()))) {s = 35;}

				input.Seek(index2_1);
				break;
			}
		case 2:
			{
				input.Rewind();
				if ((LA2_1=='.') && ((Text_ThreeDotsFollow()))) {s = 36;}

				else if ((LA2_1=='*')) {s = 37;}

				else if ((LA2_1=='/')) {s = 38;}

				else if ((LA2_1=='\\')) {s = 39;}

				else if ((LA2_1=='^')) {s = 40;}

				else if ((LA2_1=='\'')) {s = 41;}

				else if (((LA2_1>='0' && LA2_1<='9'))) {s = 42;}

				else s = 43;

				input.Seek(index2_1);
				break;
			}
		case 3:
			{
				input.Rewind();
				if ((LA2_1=='\'') && ((EvaluatePredicate(synpred1_MatlabLexer_fragment)&&(!Quotation_TransposeIsEnabled())))) {s = 44;}

				else if (((LA2_1>='\u0000' && LA2_1<='\t')||(LA2_1>='\u000B' && LA2_1<='\f')||(LA2_1>='\u000E' && LA2_1<='&')||(LA2_1>='(' && LA2_1<='\uFFFF')) && ((EvaluatePredicate(synpred1_MatlabLexer_fragment)&&(!Quotation_TransposeIsEnabled())))) {s = 45;}

				else if (((!Quotation_TransposeIsEnabled()))) {s = 46;}

				else if (((Quotation_TransposeIsEnabled()))) {s = 47;}

				input.Seek(index2_1);
				break;
			}
		case 4:
			{
				input.Rewind();
				if ((LA2_1=='\t'||LA2_1==' ') && ((Spaces_SpacesPrecedeInLine()))) {s = 64;}

				else if (((LA2_1>='\u0000' && LA2_1<='\b')||(LA2_1>='\u000B' && LA2_1<='\f')||(LA2_1>='\u000E' && LA2_1<='\u001F')||(LA2_1>='!' && LA2_1<='\uFFFF')) && ((Spaces_SpacesPrecedeInLine()))) {s = 65;}

				else if ((LA2_1=='\n'||LA2_1=='\r') && ((Spaces_SpacesPrecedeInLine()))) {s = 66;}

				input.Seek(index2_1);
				break;
			}
		case 5:
			{
				input.Rewind();
				if (((LA2_1>='\u0000' && LA2_1<='\b')||(LA2_1>='\u000B' && LA2_1<='\f')||(LA2_1>='\u000E' && LA2_1<='\u001F')||(LA2_1>='!' && LA2_1<='\uFFFF')) && ((Spaces_SpacesPrecedeInLine()))) {s = 65;}

				else if ((LA2_1=='\t'||LA2_1==' ') && ((Spaces_SpacesPrecedeInLine()))) {s = 64;}

				else if ((LA2_1=='\n'||LA2_1=='\r') && ((Spaces_SpacesPrecedeInLine()))) {s = 66;}

				input.Seek(index2_1);
				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 2, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA3 : DFA
	{
		private const string DFA3_eotS =
			"\x2\xFFFF\x1\xF\xB\xFFFF\x1\xF\x5\xFFFF";
		private const string DFA3_eofS =
			"\x14\xFFFF";
		private const string DFA3_minS =
			"\x1\x0\x1\x7B\x1\x2E\x8\xFFFF\x1\x0\x2\xFFFF\x1\x2E\x1\xFFFF\x1\x0\x3"+
			"\xFFFF";
		private const string DFA3_maxS =
			"\x1\xFFFF\x1\x7B\x1\x2E\x8\xFFFF\x1\xFFFF\x2\xFFFF\x1\x2E\x1\xFFFF\x1"+
			"\xFFFF\x3\xFFFF";
		private const string DFA3_acceptS =
			"\x3\xFFFF\x1\x6\x1\x7\x1\x8\x1\x9\x1\xA\x1\xB\x1\xC\x1\xE\x1\xFFFF\x1"+
			"\x1\x1\x3\x1\xFFFF\x1\xD\x1\xFFFF\x1\x2\x1\x4\x1\x5";
		private const string DFA3_specialS =
			"\x1\x0\x1\x1\x1\x2\x8\xFFFF\x1\x3\x2\xFFFF\x1\x4\x1\xFFFF\x1\x5\x3\xFFFF}>";
		private static readonly string[] DFA3_transitionS =
			{
				"\x9\xA\x1\x3\x1\x4\x2\xA\x1\x4\x12\xA\x1\x3\x4\xA\x1\x1\x1\xA\x1\x7"+
				"\x1\x8\x1\x9\x2\xA\x1\x5\x1\xA\x1\x2\xC\xA\x1\x6\x1F\xA\x1\x8\x1\xA"+
				"\x1\x9\x1D\xA\x1\x8\x1\xA\x1\x9\xFF82\xA",
				"\x1\xB",
				"\x1\xE",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x9\x11\x1\x10\x1\x12\x2\x11\x1\x12\x12\x11\x1\x10\xFFDF\x11",
				"",
				"",
				"\x1\x13",
				"",
				"\x9\x11\x1\x10\x1\x12\x2\x11\x1\x12\x12\x11\x1\x10\xFFDF\x11",
				"",
				"",
				""
			};

		private static readonly short[] DFA3_eot = DFA.UnpackEncodedString(DFA3_eotS);
		private static readonly short[] DFA3_eof = DFA.UnpackEncodedString(DFA3_eofS);
		private static readonly char[] DFA3_min = DFA.UnpackEncodedStringToUnsignedChars(DFA3_minS);
		private static readonly char[] DFA3_max = DFA.UnpackEncodedStringToUnsignedChars(DFA3_maxS);
		private static readonly short[] DFA3_accept = DFA.UnpackEncodedString(DFA3_acceptS);
		private static readonly short[] DFA3_special = DFA.UnpackEncodedString(DFA3_specialS);
		private static readonly short[][] DFA3_transition;

		static DFA3()
		{
			int numStates = DFA3_transitionS.Length;
			DFA3_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA3_transition[i] = DFA.UnpackEncodedString(DFA3_transitionS[i]);
			}
		}

		public DFA3( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 3;
			this.eot = DFA3_eot;
			this.eof = DFA3_eof;
			this.min = DFA3_min;
			this.max = DFA3_max;
			this.accept = DFA3_accept;
			this.special = DFA3_special;
			this.transition = DFA3_transition;
		}

		public override string Description { get { return "166:10: fragment COMMAND_MODE : ( LINECOMMENT1 | LINECOMMENT2 | LINECOMMENT3 | BLOCKCOMMENT | ELLIPSIS | SPACES | EOL | COMMA | SEMICOLON | STRINGBLOCK | DEFAULTBLOCK1 | DEFAULTBLOCK2 | DEFAULTBLOCK3 | DEFAULTBLOCK4 );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition3(DFA dfa, int s, IIntStream _input)
	{
		IIntStream input = _input;
		int _s = s;
		s = -1;
		int LA3_1 = input.LA(1);
		int index3_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				input.Rewind();
				if ((LA3_1=='%') && (((!Spaces_SpacesPrecedeInLine())||(Spaces_SpacesPrecedeInLine())))) {s = 1;}

				else if ((LA3_1=='.') && (((Text_ThreeDotsFollow())||(!Text_ThreeDotsFollow())))) {s = 2;}

				else if ((LA3_1=='\t'||LA3_1==' ')) {s = 3;}

				else if ((LA3_1=='\n'||LA3_1=='\r')) {s = 4;}

				else if ((LA3_1==',')) {s = 5;}

				else if ((LA3_1==';')) {s = 6;}

				else if ((LA3_1=='\'')) {s = 7;}

				else if ((LA3_1=='('||LA3_1=='['||LA3_1=='{')) {s = 8;}

				else if ((LA3_1==')'||LA3_1==']'||LA3_1=='}')) {s = 9;}

				else if (((LA3_1>='\u0000' && LA3_1<='\b')||(LA3_1>='\u000B' && LA3_1<='\f')||(LA3_1>='\u000E' && LA3_1<='\u001F')||(LA3_1>='!' && LA3_1<='$')||LA3_1=='&'||(LA3_1>='*' && LA3_1<='+')||LA3_1=='-'||(LA3_1>='/' && LA3_1<=':')||(LA3_1>='<' && LA3_1<='Z')||LA3_1=='\\'||(LA3_1>='^' && LA3_1<='z')||LA3_1=='|'||(LA3_1>='~' && LA3_1<='\uFFFF'))) {s = 10;}

				input.Seek(index3_1);
				break;
			}
		case 1:
			{
				input.Rewind();
				if ((LA3_1=='{') && ((Spaces_SpacesPrecedeInLine()))) {s = 11;}

				else if (((!Spaces_SpacesPrecedeInLine()))) {s = 12;}

				else if (((Spaces_SpacesPrecedeInLine()))) {s = 13;}

				input.Seek(index3_1);
				break;
			}
		case 2:
			{
				input.Rewind();
				if ((LA3_1=='.') && (((Text_ThreeDotsFollow())||(!Text_ThreeDotsFollow())))) {s = 14;}

				else s = 15;

				input.Seek(index3_1);
				break;
			}
		case 3:
			{
				input.Rewind();
				if ((LA3_1=='\t'||LA3_1==' ') && ((Spaces_SpacesPrecedeInLine()))) {s = 16;}

				else if (((LA3_1>='\u0000' && LA3_1<='\b')||(LA3_1>='\u000B' && LA3_1<='\f')||(LA3_1>='\u000E' && LA3_1<='\u001F')||(LA3_1>='!' && LA3_1<='\uFFFF')) && ((Spaces_SpacesPrecedeInLine()))) {s = 17;}

				else if ((LA3_1=='\n'||LA3_1=='\r') && ((Spaces_SpacesPrecedeInLine()))) {s = 18;}

				input.Seek(index3_1);
				break;
			}
		case 4:
			{
				input.Rewind();
				if ((LA3_1=='.') && ((Text_ThreeDotsFollow()))) {s = 19;}

				else s = 15;

				input.Seek(index3_1);
				break;
			}
		case 5:
			{
				input.Rewind();
				if (((LA3_1>='\u0000' && LA3_1<='\b')||(LA3_1>='\u000B' && LA3_1<='\f')||(LA3_1>='\u000E' && LA3_1<='\u001F')||(LA3_1>='!' && LA3_1<='\uFFFF')) && ((Spaces_SpacesPrecedeInLine()))) {s = 17;}

				else if ((LA3_1=='\t'||LA3_1==' ') && ((Spaces_SpacesPrecedeInLine()))) {s = 16;}

				else if ((LA3_1=='\n'||LA3_1=='\r') && ((Spaces_SpacesPrecedeInLine()))) {s = 18;}

				input.Seek(index3_1);
				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 3, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA29 : DFA
	{
		private const string DFA29_eotS =
			"\x14\xFFFF";
		private const string DFA29_eofS =
			"\x14\xFFFF";
		private const string DFA29_minS =
			"\x3\x0\x2\xFFFF\x3\x0\x2\xFFFF\x2\x0\x2\xFFFF\x1\x0\x1\xFFFF\x1\x0\x3"+
			"\xFFFF";
		private const string DFA29_maxS =
			"\x3\xFFFF\x2\xFFFF\x3\xFFFF\x2\xFFFF\x2\xFFFF\x2\xFFFF\x1\xFFFF\x1\xFFFF"+
			"\x1\xFFFF\x3\xFFFF";
		private const string DFA29_acceptS =
			"\x3\xFFFF\x1\x2\x1\x3\x3\xFFFF\x1\x5\x1\x4\x2\xFFFF\x1\x7\x1\x6\x1\xFFFF"+
			"\x1\x1\x1\xFFFF\x3\x1";
		private const string DFA29_specialS =
			"\x1\x0\x1\x1\x1\x2\x2\xFFFF\x1\x3\x1\x4\x1\x5\x2\xFFFF\x1\x6\x1\x7\x2"+
			"\xFFFF\x1\x8\x1\xFFFF\x1\x9\x3\xFFFF}>";
		private static readonly string[] DFA29_transitionS =
			{
				"\x9\x4\x1\x1\x1\x3\x2\x4\x1\x3\x12\x4\x1\x1\x4\x4\x1\x2\xFFDA\x4",
				"\x9\x4\x1\x1\x1\x3\x2\x4\x1\x3\x12\x4\x1\x1\x4\x4\x1\x5\xFFDA\x4",
				"\xA\x8\x1\x9\x2\x8\x1\x9\x6D\x8\x1\x7\x1\x8\x1\x6\xFF82\x8",
				"",
				"",
				"\xA\x8\x1\x9\x2\x8\x1\x9\x6D\x8\x1\xA\x1\x8\x1\x6\xFF82\x8",
				"\x9\xD\x1\xB\x1\xC\x2\xD\x1\xC\x12\xD\x1\xB\xFFDF\xD",
				"\x9\xD\x1\xE\x1\xF\x2\xD\x1\xF\x12\xD\x1\xE\xFFDF\xD",
				"",
				"",
				"\x9\xD\x1\x10\x1\x11\x2\xD\x1\x11\x12\xD\x1\x10\xFFDF\xD",
				"\x9\xD\x1\xB\x1\xC\x2\xD\x1\xC\x12\xD\x1\xB\xFFDF\xD",
				"",
				"",
				"\x9\xD\x1\xE\x1\x12\x2\xD\x1\xF\x12\xD\x1\xE\xFFDF\xD",
				"",
				"\x9\xD\x1\x10\x1\x13\x2\xD\x1\x11\x12\xD\x1\x10\xFFDF\xD",
				"",
				"",
				""
			};

		private static readonly short[] DFA29_eot = DFA.UnpackEncodedString(DFA29_eotS);
		private static readonly short[] DFA29_eof = DFA.UnpackEncodedString(DFA29_eofS);
		private static readonly char[] DFA29_min = DFA.UnpackEncodedStringToUnsignedChars(DFA29_minS);
		private static readonly char[] DFA29_max = DFA.UnpackEncodedStringToUnsignedChars(DFA29_maxS);
		private static readonly short[] DFA29_accept = DFA.UnpackEncodedString(DFA29_acceptS);
		private static readonly short[] DFA29_special = DFA.UnpackEncodedString(DFA29_specialS);
		private static readonly short[][] DFA29_transition;

		static DFA29()
		{
			int numStates = DFA29_transitionS.Length;
			DFA29_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA29_transition[i] = DFA.UnpackEncodedString(DFA29_transitionS[i]);
			}
		}

		public DFA29( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 29;
			this.eot = DFA29_eot;
			this.eof = DFA29_eof;
			this.min = DFA29_min;
			this.max = DFA29_max;
			this.accept = DFA29_accept;
			this.special = DFA29_special;
			this.transition = DFA29_transition;
		}

		public override string Description { get { return "()* loopback of 216:25: ( ( WS )* BLOCKCOMMENT | ( WS )* EOL | ( WS )* ~ ( '%' | ' ' | '\\t' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* EOL | ( WS )* '%' EOL | ( WS )* '%' ~ ( '{' | '}' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* EOL | ( WS )* '%' ( '{' | '}' ) ( WS )* ~ ( ' ' | '\\t' | '\\r' | '\\n' ) (~ ( '\\r' | '\\n' ) )* EOL )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition29(DFA dfa, int s, IIntStream _input)
	{
		IIntStream input = _input;
		int _s = s;
		s = -1;
		int LA29_1 = input.LA(1);
		int index29_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				if ((LA29_1=='\t'||LA29_1==' ')) {s = 1;}

				else if ((LA29_1=='%')) {s = 2;}

				else if ((LA29_1=='\n'||LA29_1=='\r')) {s = 3;}

				else if (((LA29_1>='\u0000' && LA29_1<='\b')||(LA29_1>='\u000B' && LA29_1<='\f')||(LA29_1>='\u000E' && LA29_1<='\u001F')||(LA29_1>='!' && LA29_1<='$')||(LA29_1>='&' && LA29_1<='\uFFFF'))) {s = 4;}

				break;
			}
		case 1:
			{
				if ((LA29_1=='%')) {s = 5;}

				else if ((LA29_1=='\t'||LA29_1==' ')) {s = 1;}

				else if ((LA29_1=='\n'||LA29_1=='\r')) {s = 3;}

				else if (((LA29_1>='\u0000' && LA29_1<='\b')||(LA29_1>='\u000B' && LA29_1<='\f')||(LA29_1>='\u000E' && LA29_1<='\u001F')||(LA29_1>='!' && LA29_1<='$')||(LA29_1>='&' && LA29_1<='\uFFFF'))) {s = 4;}

				break;
			}
		case 2:
			{
				if ((LA29_1=='}')) {s = 6;}

				else if ((LA29_1=='{')) {s = 7;}

				else if (((LA29_1>='\u0000' && LA29_1<='\t')||(LA29_1>='\u000B' && LA29_1<='\f')||(LA29_1>='\u000E' && LA29_1<='z')||LA29_1=='|'||(LA29_1>='~' && LA29_1<='\uFFFF'))) {s = 8;}

				else if ((LA29_1=='\n'||LA29_1=='\r')) {s = 9;}

				break;
			}
		case 3:
			{
				if ((LA29_1=='}')) {s = 6;}

				else if ((LA29_1=='{')) {s = 10;}

				else if (((LA29_1>='\u0000' && LA29_1<='\t')||(LA29_1>='\u000B' && LA29_1<='\f')||(LA29_1>='\u000E' && LA29_1<='z')||LA29_1=='|'||(LA29_1>='~' && LA29_1<='\uFFFF'))) {s = 8;}

				else if ((LA29_1=='\n'||LA29_1=='\r')) {s = 9;}

				break;
			}
		case 4:
			{
				if ((LA29_1=='\t'||LA29_1==' ')) {s = 11;}

				else if ((LA29_1=='\n'||LA29_1=='\r')) {s = 12;}

				else if (((LA29_1>='\u0000' && LA29_1<='\b')||(LA29_1>='\u000B' && LA29_1<='\f')||(LA29_1>='\u000E' && LA29_1<='\u001F')||(LA29_1>='!' && LA29_1<='\uFFFF'))) {s = 13;}

				break;
			}
		case 5:
			{
				input.Rewind();
				if ((LA29_1=='\t'||LA29_1==' ')) {s = 14;}

				else if ((LA29_1=='\n'||LA29_1=='\r') && ((Spaces_SpacesPrecedeInLine()))) {s = 15;}

				else if (((LA29_1>='\u0000' && LA29_1<='\b')||(LA29_1>='\u000B' && LA29_1<='\f')||(LA29_1>='\u000E' && LA29_1<='\u001F')||(LA29_1>='!' && LA29_1<='\uFFFF'))) {s = 13;}

				input.Seek(index29_1);
				break;
			}
		case 6:
			{
				if ((LA29_1=='\t'||LA29_1==' ')) {s = 16;}

				else if ((LA29_1=='\n'||LA29_1=='\r')) {s = 17;}

				else if (((LA29_1>='\u0000' && LA29_1<='\b')||(LA29_1>='\u000B' && LA29_1<='\f')||(LA29_1>='\u000E' && LA29_1<='\u001F')||(LA29_1>='!' && LA29_1<='\uFFFF'))) {s = 13;}

				break;
			}
		case 7:
			{
				if ((LA29_1=='\n'||LA29_1=='\r')) {s = 12;}

				else if ((LA29_1=='\t'||LA29_1==' ')) {s = 11;}

				else if (((LA29_1>='\u0000' && LA29_1<='\b')||(LA29_1>='\u000B' && LA29_1<='\f')||(LA29_1>='\u000E' && LA29_1<='\u001F')||(LA29_1>='!' && LA29_1<='\uFFFF'))) {s = 13;}

				break;
			}
		case 8:
			{
				input.Rewind();
				if ((LA29_1=='\r') && ((Spaces_SpacesPrecedeInLine()))) {s = 15;}

				else if ((LA29_1=='\n') && ((Spaces_SpacesPrecedeInLine()))) {s = 18;}

				else if ((LA29_1=='\t'||LA29_1==' ')) {s = 14;}

				else if (((LA29_1>='\u0000' && LA29_1<='\b')||(LA29_1>='\u000B' && LA29_1<='\f')||(LA29_1>='\u000E' && LA29_1<='\u001F')||(LA29_1>='!' && LA29_1<='\uFFFF'))) {s = 13;}

				input.Seek(index29_1);
				break;
			}
		case 9:
			{
				if ((LA29_1=='\r')) {s = 17;}

				else if ((LA29_1=='\n')) {s = 19;}

				else if ((LA29_1=='\t'||LA29_1==' ')) {s = 16;}

				else if (((LA29_1>='\u0000' && LA29_1<='\b')||(LA29_1>='\u000B' && LA29_1<='\f')||(LA29_1>='\u000E' && LA29_1<='\u001F')||(LA29_1>='!' && LA29_1<='\uFFFF'))) {s = 13;}

				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 29, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}

	#endregion

}

} // namespace Matlab.Recognizer
