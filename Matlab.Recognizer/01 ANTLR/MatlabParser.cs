//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.2 d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3 2015-09-27 18:24:05

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


/* 
 * [The BSD 3-Clause License]
 * Copyright (c) 2015, Samuel Suffos
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification, 
 * are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list 
 *    of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this 
 *    list of conditions and the following disclaimer in the documentation and/or other 
 *    materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its contributors may be 
 *    used to endorse or promote products derived from this software without specific 
 *    prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
 * SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED 
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR 
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 *
 */


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace Matlab.Recognizer
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.2")]
[System.CLSCompliant(false)]
internal partial class MatlabParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "ASSIGN", "AT", "BANG_MODE", "BLOCKCOMMENT", "BREAK", "CASE", "CATCH", "CLASSDEF", "COLON", "COMMA", "COMMAND", "COMMAND_MODE", "CONTINUE", "CTRANS", "DEFAULTBLOCK", "DEFAULTBLOCK1", "DEFAULTBLOCK2", "DEFAULTBLOCK3", "DEFAULTBLOCK4", "DEFAULT_MODE", "DIGIT", "DOT", "ELLIPSIS", "ELSE", "ELSEIF", "END", "EOL", "EQ", "EXCLAMATION", "EXP", "FOR", "FUNCTION", "GLOBAL", "GT", "GTEQ", "ID", "IF", "IMAGINARY", "IMG", "LCURLY", "LDIV", "LETTER", "LINE", "LINECOMMENT", "LINECOMMENT1", "LINECOMMENT2", "LINECOMMENT3", "LPAREN", "LSQUARE", "LT", "LTEQ", "MINUS", "MLDIV", "MPOW", "MRDIV", "MTIMES", "NOT", "NOTEQ", "NUMBER", "OR", "OTHERWISE", "PARFOR", "PERSISTENT", "PLUS", "POINT", "POW", "QUESTION", "QUOTATION", "RCURLY", "RDIV", "REAL", "RETURN", "RPAREN", "RSQUARE", "SEMICOLON", "SHORTAND", "SHORTOR", "SIGN", "SPACES", "SPMD", "START", "STRING", "STRINGBLOCK", "SWITCH", "TIMES", "TRANS", "TRY", "UNKNOWN", "WHILE", "WS", "ABORT", "ACTION", "ALL", "ANONYMOUSFUNCTION", "ATBASE", "ATTRIBUTE", "CELLARRAY", "CLASSFILE", "CLASSREF", "CURLYBRACE", "DOTEXPRESSION", "DOTNAME", "ENUMERATION", "ENUMERATIONSECTION", "EVENT", "EVENTSECTION", "EXTERNALMETHOD", "FUNCTIONFILE", "FUNCTIONHANDLE", "FUNCTIONREF", "HCAT", "IFELSE", "INPUT", "METHODSECTION", "NAME", "NEGATIVE", "NESTEDFUNCTION", "NOPRINT", "OUTPUT", "PARENTHESIS", "POSITIVE", "PRINT", "PROPERTY", "PROPERTYSECTION", "REGULARARRAY", "REGULARMETHOD", "SCRIPTFILE", "STORAGE", "SWITCHCASE", "TRYCATCH", "VAR", "VCAT"
	};
	public const int EOF=-1;
	public const int AND=4;
	public const int ASSIGN=5;
	public const int AT=6;
	public const int BANG_MODE=7;
	public const int BLOCKCOMMENT=8;
	public const int BREAK=9;
	public const int CASE=10;
	public const int CATCH=11;
	public const int CLASSDEF=12;
	public const int COLON=13;
	public const int COMMA=14;
	public const int COMMAND=15;
	public const int COMMAND_MODE=16;
	public const int CONTINUE=17;
	public const int CTRANS=18;
	public const int DEFAULTBLOCK=19;
	public const int DEFAULTBLOCK1=20;
	public const int DEFAULTBLOCK2=21;
	public const int DEFAULTBLOCK3=22;
	public const int DEFAULTBLOCK4=23;
	public const int DEFAULT_MODE=24;
	public const int DIGIT=25;
	public const int DOT=26;
	public const int ELLIPSIS=27;
	public const int ELSE=28;
	public const int ELSEIF=29;
	public const int END=30;
	public const int EOL=31;
	public const int EQ=32;
	public const int EXCLAMATION=33;
	public const int EXP=34;
	public const int FOR=35;
	public const int FUNCTION=36;
	public const int GLOBAL=37;
	public const int GT=38;
	public const int GTEQ=39;
	public const int ID=40;
	public const int IF=41;
	public const int IMAGINARY=42;
	public const int IMG=43;
	public const int LCURLY=44;
	public const int LDIV=45;
	public const int LETTER=46;
	public const int LINE=47;
	public const int LINECOMMENT=48;
	public const int LINECOMMENT1=49;
	public const int LINECOMMENT2=50;
	public const int LINECOMMENT3=51;
	public const int LPAREN=52;
	public const int LSQUARE=53;
	public const int LT=54;
	public const int LTEQ=55;
	public const int MINUS=56;
	public const int MLDIV=57;
	public const int MPOW=58;
	public const int MRDIV=59;
	public const int MTIMES=60;
	public const int NOT=61;
	public const int NOTEQ=62;
	public const int NUMBER=63;
	public const int OR=64;
	public const int OTHERWISE=65;
	public const int PARFOR=66;
	public const int PERSISTENT=67;
	public const int PLUS=68;
	public const int POINT=69;
	public const int POW=70;
	public const int QUESTION=71;
	public const int QUOTATION=72;
	public const int RCURLY=73;
	public const int RDIV=74;
	public const int REAL=75;
	public const int RETURN=76;
	public const int RPAREN=77;
	public const int RSQUARE=78;
	public const int SEMICOLON=79;
	public const int SHORTAND=80;
	public const int SHORTOR=81;
	public const int SIGN=82;
	public const int SPACES=83;
	public const int SPMD=84;
	public const int START=85;
	public const int STRING=86;
	public const int STRINGBLOCK=87;
	public const int SWITCH=88;
	public const int TIMES=89;
	public const int TRANS=90;
	public const int TRY=91;
	public const int UNKNOWN=92;
	public const int WHILE=93;
	public const int WS=94;
	public const int ABORT=95;
	public const int ACTION=96;
	public const int ALL=97;
	public const int ANONYMOUSFUNCTION=98;
	public const int ATBASE=99;
	public const int ATTRIBUTE=100;
	public const int CELLARRAY=101;
	public const int CLASSFILE=102;
	public const int CLASSREF=103;
	public const int CURLYBRACE=104;
	public const int DOTEXPRESSION=105;
	public const int DOTNAME=106;
	public const int ENUMERATION=107;
	public const int ENUMERATIONSECTION=108;
	public const int EVENT=109;
	public const int EVENTSECTION=110;
	public const int EXTERNALMETHOD=111;
	public const int FUNCTIONFILE=112;
	public const int FUNCTIONHANDLE=113;
	public const int FUNCTIONREF=114;
	public const int HCAT=115;
	public const int IFELSE=116;
	public const int INPUT=117;
	public const int METHODSECTION=118;
	public const int NAME=119;
	public const int NEGATIVE=120;
	public const int NESTEDFUNCTION=121;
	public const int NOPRINT=122;
	public const int OUTPUT=123;
	public const int PARENTHESIS=124;
	public const int POSITIVE=125;
	public const int PRINT=126;
	public const int PROPERTY=127;
	public const int PROPERTYSECTION=128;
	public const int REGULARARRAY=129;
	public const int REGULARMETHOD=130;
	public const int SCRIPTFILE=131;
	public const int STORAGE=132;
	public const int SWITCHCASE=133;
	public const int TRYCATCH=134;
	public const int VAR=135;
	public const int VCAT=136;

	public MatlabParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public MatlabParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return MatlabParser.tokenNames; } }
	public override string GrammarFileName { get { return "d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_file();
	partial void LeaveRule_file();
	// $ANTLR start "file"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:115:8: public file : ( scriptFile -> scriptFile | functionFile -> functionFile | classFile -> classFile );
	[GrammarRule("file")]
	public AstParserRuleReturnScope<object, IToken> file()
	{
		EnterRule_file();
		EnterRule("file", 1);
		TraceIn("file", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> scriptFile1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionFile2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classFile3 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_scriptFile=new RewriteRuleSubtreeStream(adaptor,"rule scriptFile");
		RewriteRuleSubtreeStream stream_functionFile=new RewriteRuleSubtreeStream(adaptor,"rule functionFile");
		RewriteRuleSubtreeStream stream_classFile=new RewriteRuleSubtreeStream(adaptor,"rule classFile");
		try { DebugEnterRule(GrammarFileName, "file");
		DebugLocation(115, 3);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:115:13: ( scriptFile -> scriptFile | functionFile -> functionFile | classFile -> classFile )
			int alt1=3;
			try { DebugEnterDecision(1, false);
			try
			{
				alt1 = dfa1.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:115:15: scriptFile
				{
				DebugLocation(115, 15);
				PushFollow(Follow._scriptFile_in_file296);
				scriptFile1=scriptFile();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_scriptFile.Add(scriptFile1.Tree);


				{
				// AST REWRITE
				// elements: scriptFile
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 115:26: -> scriptFile
				{
					DebugLocation(115, 29);
					adaptor.AddChild(root_0, stream_scriptFile.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:116:6: functionFile
				{
				DebugLocation(116, 6);
				PushFollow(Follow._functionFile_in_file308);
				functionFile2=functionFile();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_functionFile.Add(functionFile2.Tree);


				{
				// AST REWRITE
				// elements: functionFile
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 116:19: -> functionFile
				{
					DebugLocation(116, 22);
					adaptor.AddChild(root_0, stream_functionFile.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:117:6: classFile
				{
				DebugLocation(117, 6);
				PushFollow(Follow._classFile_in_file320);
				classFile3=classFile();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_classFile.Add(classFile3.Tree);


				{
				// AST REWRITE
				// elements: classFile
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 117:16: -> classFile
				{
					DebugLocation(117, 19);
					adaptor.AddChild(root_0, stream_classFile.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("file", 1);
			LeaveRule("file", 1);
			LeaveRule_file();
		}
		DebugLocation(118, 3);
		} finally { DebugExitRule(GrammarFileName, "file"); }
		return retval;

	}
	// $ANTLR end "file"

	partial void EnterRule_scriptFile();
	partial void LeaveRule_scriptFile();
	// $ANTLR start "scriptFile"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:122:1: scriptFile : statements EOF -> ^( SCRIPTFILE[\"\"] ( statements )? ) ;
	[GrammarRule("scriptFile")]
	private AstParserRuleReturnScope<object, IToken> scriptFile()
	{
		EnterRule_scriptFile();
		EnterRule("scriptFile", 2);
		TraceIn("scriptFile", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOF5 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statements4 = default(AstParserRuleReturnScope<object, IToken>);

		object EOF5_tree = default(object);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		try { DebugEnterRule(GrammarFileName, "scriptFile");
		DebugLocation(122, 63);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:122:12: ( statements EOF -> ^( SCRIPTFILE[\"\"] ( statements )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:122:14: statements EOF
			{
			DebugLocation(122, 14);
			PushFollow(Follow._statements_in_scriptFile339);
			statements4=statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statements.Add(statements4.Tree);
			DebugLocation(122, 25);
			EOF5=(IToken)Match(input,EOF,Follow._EOF_in_scriptFile341); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF5);



			{
			// AST REWRITE
			// elements: statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 122:29: -> ^( SCRIPTFILE[\"\"] ( statements )? )
			{
				DebugLocation(122, 32);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:122:32: ^( SCRIPTFILE[\"\"] ( statements )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(122, 34);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SCRIPTFILE, ""), root_1);

				DebugLocation(122, 49);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:122:49: ( statements )?
				if (stream_statements.HasNext)
				{
					DebugLocation(122, 50);
					adaptor.AddChild(root_1, stream_statements.NextTree());

				}
				stream_statements.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("scriptFile", 2);
			LeaveRule("scriptFile", 2);
			LeaveRule_scriptFile();
		}
		DebugLocation(122, 63);
		} finally { DebugExitRule(GrammarFileName, "scriptFile"); }
		return retval;

	}
	// $ANTLR end "scriptFile"

	partial void EnterRule_statements();
	partial void LeaveRule_statements();
	// $ANTLR start "statements"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:124:1: statements : ( statement | xEOS )* -> ( statement )* ;
	[GrammarRule("statements")]
	private AstParserRuleReturnScope<object, IToken> statements()
	{
		EnterRule_statements();
		EnterRule("statements", 3);
		TraceIn("statements", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> statement6 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS7 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "statements");
		DebugLocation(124, 49);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:124:12: ( ( statement | xEOS )* -> ( statement )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:124:14: ( statement | xEOS )*
			{
			DebugLocation(124, 14);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:124:14: ( statement | xEOS )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=3;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==END))
				{
					int LA2_2 = input.LA(2);

					if ((LA2_2==SEMICOLON))
					{
						int LA2_3 = input.LA(3);

						if ((((True())&&(Index_IsActive()))))
						{
							alt2 = 1;
						}


					}
					else if ((LA2_2==COMMA))
					{
						int LA2_3 = input.LA(3);

						if ((((True())&&(Index_IsActive()))))
						{
							alt2 = 1;
						}


					}
					else if ((LA2_2==EOL))
					{
						int LA2_3 = input.LA(3);

						if ((((True())&&(Index_IsActive()))))
						{
							alt2 = 1;
						}


					}
					else if ((LA2_2==AND||LA2_2==COLON||LA2_2==CTRANS||LA2_2==EQ||(LA2_2>=GT && LA2_2<=GTEQ)||LA2_2==LDIV||(LA2_2>=LT && LA2_2<=MTIMES)||LA2_2==NOTEQ||LA2_2==OR||LA2_2==PLUS||LA2_2==POW||LA2_2==RDIV||(LA2_2>=SHORTAND && LA2_2<=SHORTOR)||(LA2_2>=TIMES && LA2_2<=TRANS)) && (((True())&&(Index_IsActive()))))
					{
						alt2 = 1;
					}


				}
				else if ((LA2_1==ID) && (((True())||(Command_IsEnabled()))))
				{
					alt2 = 1;
				}
				else if ((LA2_1==AT||LA2_1==IMAGINARY||LA2_1==LCURLY||(LA2_1>=LPAREN && LA2_1<=LSQUARE)||LA2_1==MINUS||LA2_1==NOT||LA2_1==PLUS||LA2_1==QUESTION||LA2_1==REAL||LA2_1==STRING) && ((True())))
				{
					alt2 = 1;
				}
				else if ((LA2_1==BREAK||LA2_1==COMMAND||LA2_1==CONTINUE||LA2_1==EXCLAMATION||LA2_1==FOR||LA2_1==GLOBAL||LA2_1==IF||(LA2_1>=PARFOR && LA2_1<=PERSISTENT)||LA2_1==RETURN||LA2_1==SPMD||LA2_1==SWITCH||LA2_1==TRY||LA2_1==WHILE))
				{
					alt2 = 1;
				}
				else if ((LA2_1==COMMA||LA2_1==EOL||LA2_1==SEMICOLON))
				{
					alt2 = 2;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:124:15: statement
					{
					DebugLocation(124, 15);
					PushFollow(Follow._statement_in_statements363);
					statement6=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement6.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:124:27: xEOS
					{
					DebugLocation(124, 27);
					PushFollow(Follow._xEOS_in_statements367);
					xEOS7=xEOS();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_xEOS.Add(xEOS7.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }



			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 124:34: -> ( statement )*
			{
				DebugLocation(124, 37);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:124:37: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(124, 38);
					adaptor.AddChild(root_0, stream_statement.NextTree());

				}
				stream_statement.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statements", 3);
			LeaveRule("statements", 3);
			LeaveRule_statements();
		}
		DebugLocation(124, 49);
		} finally { DebugExitRule(GrammarFileName, "statements"); }
		return retval;

	}
	// $ANTLR end "statements"

	partial void EnterRule_functionFile();
	partial void LeaveRule_functionFile();
	// $ANTLR start "functionFile"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:128:1: functionFile : ( ( openFunctionFile )=> openFunctionFile -> openFunctionFile | closeFunctionFile -> closeFunctionFile );
	[GrammarRule("functionFile")]
	private AstParserRuleReturnScope<object, IToken> functionFile()
	{
		EnterRule_functionFile();
		EnterRule("functionFile", 4);
		TraceIn("functionFile", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> openFunctionFile8 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> closeFunctionFile9 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_openFunctionFile=new RewriteRuleSubtreeStream(adaptor,"rule openFunctionFile");
		RewriteRuleSubtreeStream stream_closeFunctionFile=new RewriteRuleSubtreeStream(adaptor,"rule closeFunctionFile");
		try { DebugEnterRule(GrammarFileName, "functionFile");
		DebugLocation(128, 4);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:128:14: ( ( openFunctionFile )=> openFunctionFile -> openFunctionFile | closeFunctionFile -> closeFunctionFile )
			int alt3=2;
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if ((LA3_1==EOL))
			{
				int LA3_2 = input.LA(2);

				if ((EvaluatePredicate(synpred1_MatlabParser_fragment)))
				{
					alt3 = 1;
				}
				else if ((true))
				{
					alt3 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 3, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA3_1==FUNCTION))
			{
				int LA3_2 = input.LA(2);

				if ((EvaluatePredicate(synpred1_MatlabParser_fragment)))
				{
					alt3 = 1;
				}
				else if ((true))
				{
					alt3 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 3, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:128:16: ( openFunctionFile )=> openFunctionFile
				{
				DebugLocation(128, 37);
				PushFollow(Follow._openFunctionFile_in_functionFile392);
				openFunctionFile8=openFunctionFile();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_openFunctionFile.Add(openFunctionFile8.Tree);


				{
				// AST REWRITE
				// elements: openFunctionFile
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 128:54: -> openFunctionFile
				{
					DebugLocation(128, 57);
					adaptor.AddChild(root_0, stream_openFunctionFile.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:129:7: closeFunctionFile
				{
				DebugLocation(129, 7);
				PushFollow(Follow._closeFunctionFile_in_functionFile405);
				closeFunctionFile9=closeFunctionFile();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_closeFunctionFile.Add(closeFunctionFile9.Tree);


				{
				// AST REWRITE
				// elements: closeFunctionFile
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 129:25: -> closeFunctionFile
				{
					DebugLocation(129, 28);
					adaptor.AddChild(root_0, stream_closeFunctionFile.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionFile", 4);
			LeaveRule("functionFile", 4);
			LeaveRule_functionFile();
		}
		DebugLocation(130, 4);
		} finally { DebugExitRule(GrammarFileName, "functionFile"); }
		return retval;

	}
	// $ANTLR end "functionFile"

	partial void EnterRule_openFunctionFile();
	partial void LeaveRule_openFunctionFile();
	// $ANTLR start "openFunctionFile"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:134:1: openFunctionFile : ( EOL )* openFunctions EOF -> ^( FUNCTIONFILE[\"\"] openFunctions ) ;
	[GrammarRule("openFunctionFile")]
	private AstParserRuleReturnScope<object, IToken> openFunctionFile()
	{
		EnterRule_openFunctionFile();
		EnterRule("openFunctionFile", 5);
		TraceIn("openFunctionFile", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOL10 = default(IToken);
		IToken EOF12 = default(IToken);
		AstParserRuleReturnScope<object, IToken> openFunctions11 = default(AstParserRuleReturnScope<object, IToken>);

		object EOL10_tree = default(object);
		object EOF12_tree = default(object);
		RewriteRuleITokenStream stream_EOL=new RewriteRuleITokenStream(adaptor,"token EOL");
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_openFunctions=new RewriteRuleSubtreeStream(adaptor,"rule openFunctions");
		try { DebugEnterRule(GrammarFileName, "openFunctionFile");
		DebugLocation(134, 81);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:134:18: ( ( EOL )* openFunctions EOF -> ^( FUNCTIONFILE[\"\"] openFunctions ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:134:20: ( EOL )* openFunctions EOF
			{
			DebugLocation(134, 20);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:134:20: ( EOL )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==EOL))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:134:21: EOL
					{
					DebugLocation(134, 21);
					EOL10=(IToken)Match(input,EOL,Follow._EOL_in_openFunctionFile426); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_EOL.Add(EOL10);


					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(134, 27);
			PushFollow(Follow._openFunctions_in_openFunctionFile430);
			openFunctions11=openFunctions();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_openFunctions.Add(openFunctions11.Tree);
			DebugLocation(134, 41);
			EOF12=(IToken)Match(input,EOF,Follow._EOF_in_openFunctionFile432); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF12);



			{
			// AST REWRITE
			// elements: openFunctions
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 134:45: -> ^( FUNCTIONFILE[\"\"] openFunctions )
			{
				DebugLocation(134, 48);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:134:48: ^( FUNCTIONFILE[\"\"] openFunctions )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(134, 50);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTIONFILE, ""), root_1);

				DebugLocation(134, 67);
				adaptor.AddChild(root_1, stream_openFunctions.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("openFunctionFile", 5);
			LeaveRule("openFunctionFile", 5);
			LeaveRule_openFunctionFile();
		}
		DebugLocation(134, 81);
		} finally { DebugExitRule(GrammarFileName, "openFunctionFile"); }
		return retval;

	}
	// $ANTLR end "openFunctionFile"

	partial void EnterRule_openFunctions();
	partial void LeaveRule_openFunctions();
	// $ANTLR start "openFunctions"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:136:1: openFunctions : ( openFunction )+ -> ( openFunction )+ ;
	[GrammarRule("openFunctions")]
	private AstParserRuleReturnScope<object, IToken> openFunctions()
	{
		EnterRule_openFunctions();
		EnterRule("openFunctions", 6);
		TraceIn("openFunctions", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> openFunction13 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_openFunction=new RewriteRuleSubtreeStream(adaptor,"rule openFunction");
		try { DebugEnterRule(GrammarFileName, "openFunctions");
		DebugLocation(136, 51);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:136:15: ( ( openFunction )+ -> ( openFunction )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:136:17: ( openFunction )+
			{
			DebugLocation(136, 17);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:136:17: ( openFunction )+
			int cnt5=0;
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if ((LA5_1==FUNCTION))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch (alt5)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:136:18: openFunction
					{
					DebugLocation(136, 18);
					PushFollow(Follow._openFunction_in_openFunctions451);
					openFunction13=openFunction();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_openFunction.Add(openFunction13.Tree);

					}
					break;

				default:
					if (cnt5 >= 1)
						goto loop5;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee5 = new EarlyExitException( 5, input );
					DebugRecognitionException(eee5);
					throw eee5;
				}
				cnt5++;
			}
			loop5:
				;

			} finally { DebugExitSubRule(5); }



			{
			// AST REWRITE
			// elements: openFunction
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 136:33: -> ( openFunction )+
			{
				DebugLocation(136, 36);
				if (!(stream_openFunction.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_openFunction.HasNext )
				{
					DebugLocation(136, 37);
					adaptor.AddChild(root_0, stream_openFunction.NextTree());

				}
				stream_openFunction.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("openFunctions", 6);
			LeaveRule("openFunctions", 6);
			LeaveRule_openFunctions();
		}
		DebugLocation(136, 51);
		} finally { DebugExitRule(GrammarFileName, "openFunctions"); }
		return retval;

	}
	// $ANTLR end "openFunctions"

	partial void EnterRule_openFunction();
	partial void LeaveRule_openFunction();
	// $ANTLR start "openFunction"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:138:1: openFunction : FUNCTION functionSignature openBody -> ^( FUNCTION functionSignature ( openBody )? ) ;
	[GrammarRule("openFunction")]
	private AstParserRuleReturnScope<object, IToken> openFunction()
	{
		EnterRule_openFunction();
		EnterRule("openFunction", 7);
		TraceIn("openFunction", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FUNCTION14 = default(IToken);
		AstParserRuleReturnScope<object, IToken> functionSignature15 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> openBody16 = default(AstParserRuleReturnScope<object, IToken>);

		object FUNCTION14_tree = default(object);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleSubtreeStream stream_functionSignature=new RewriteRuleSubtreeStream(adaptor,"rule functionSignature");
		RewriteRuleSubtreeStream stream_openBody=new RewriteRuleSubtreeStream(adaptor,"rule openBody");
		try { DebugEnterRule(GrammarFileName, "openFunction");
		DebugLocation(138, 96);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:138:14: ( FUNCTION functionSignature openBody -> ^( FUNCTION functionSignature ( openBody )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:138:16: FUNCTION functionSignature openBody
			{
			DebugLocation(138, 16);
			FUNCTION14=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_openFunction469); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION14);

			DebugLocation(138, 25);
			PushFollow(Follow._functionSignature_in_openFunction471);
			functionSignature15=functionSignature();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_functionSignature.Add(functionSignature15.Tree);
			DebugLocation(138, 43);
			PushFollow(Follow._openBody_in_openFunction473);
			openBody16=openBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_openBody.Add(openBody16.Tree);


			{
			// AST REWRITE
			// elements: FUNCTION, functionSignature, openBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 138:52: -> ^( FUNCTION functionSignature ( openBody )? )
			{
				DebugLocation(138, 55);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:138:55: ^( FUNCTION functionSignature ( openBody )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(138, 57);
				root_1 = (object)adaptor.BecomeRoot(stream_FUNCTION.NextNode(), root_1);

				DebugLocation(138, 66);
				adaptor.AddChild(root_1, stream_functionSignature.NextTree());
				DebugLocation(138, 84);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:138:84: ( openBody )?
				if (stream_openBody.HasNext)
				{
					DebugLocation(138, 85);
					adaptor.AddChild(root_1, stream_openBody.NextTree());

				}
				stream_openBody.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("openFunction", 7);
			LeaveRule("openFunction", 7);
			LeaveRule_openFunction();
		}
		DebugLocation(138, 96);
		} finally { DebugExitRule(GrammarFileName, "openFunction"); }
		return retval;

	}
	// $ANTLR end "openFunction"

	partial void EnterRule_functionSignature();
	partial void LeaveRule_functionSignature();
	// $ANTLR start "functionSignature"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:140:1: functionSignature : ( outputPortion functionName ( inputPortion )? -> functionName ( inputPortion )? ( outputPortion )? | name ( inputPortion )? -> name ( inputPortion )? );
	[GrammarRule("functionSignature")]
	private AstParserRuleReturnScope<object, IToken> functionSignature()
	{
		EnterRule_functionSignature();
		EnterRule("functionSignature", 8);
		TraceIn("functionSignature", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> outputPortion17 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionName18 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> inputPortion19 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> name20 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> inputPortion21 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_outputPortion=new RewriteRuleSubtreeStream(adaptor,"rule outputPortion");
		RewriteRuleSubtreeStream stream_functionName=new RewriteRuleSubtreeStream(adaptor,"rule functionName");
		RewriteRuleSubtreeStream stream_inputPortion=new RewriteRuleSubtreeStream(adaptor,"rule inputPortion");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		try { DebugEnterRule(GrammarFileName, "functionSignature");
		DebugLocation(140, 6);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:140:19: ( outputPortion functionName ( inputPortion )? -> functionName ( inputPortion )? ( outputPortion )? | name ( inputPortion )? -> name ( inputPortion )? )
			int alt8=2;
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==ID))
			{
				int LA8_2 = input.LA(2);

				if ((LA8_2==ASSIGN))
				{
					alt8 = 1;
				}
				else if ((LA8_2==EOF||LA8_2==COMMA||(LA8_2>=END && LA8_2<=EOL)||LA8_2==FUNCTION||LA8_2==LPAREN||LA8_2==SEMICOLON))
				{
					alt8 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 8, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA8_1==LSQUARE))
			{
				alt8 = 1;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:140:21: outputPortion functionName ( inputPortion )?
				{
				DebugLocation(140, 21);
				PushFollow(Follow._outputPortion_in_functionSignature495);
				outputPortion17=outputPortion();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_outputPortion.Add(outputPortion17.Tree);
				DebugLocation(140, 35);
				PushFollow(Follow._functionName_in_functionSignature497);
				functionName18=functionName();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_functionName.Add(functionName18.Tree);
				DebugLocation(140, 48);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:140:48: ( inputPortion )?
				int alt6=2;
				try { DebugEnterSubRule(6);
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==LPAREN))
				{
					alt6 = 1;
				}
				} finally { DebugExitDecision(6); }
				switch (alt6)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:140:49: inputPortion
					{
					DebugLocation(140, 49);
					PushFollow(Follow._inputPortion_in_functionSignature500);
					inputPortion19=inputPortion();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_inputPortion.Add(inputPortion19.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(6); }



				{
				// AST REWRITE
				// elements: functionName, inputPortion, outputPortion
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 140:64: -> functionName ( inputPortion )? ( outputPortion )?
				{
					DebugLocation(140, 67);
					adaptor.AddChild(root_0, stream_functionName.NextTree());
					DebugLocation(140, 80);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:140:80: ( inputPortion )?
					if (stream_inputPortion.HasNext)
					{
						DebugLocation(140, 81);
						adaptor.AddChild(root_0, stream_inputPortion.NextTree());

					}
					stream_inputPortion.Reset();
					DebugLocation(140, 96);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:140:96: ( outputPortion )?
					if (stream_outputPortion.HasNext)
					{
						DebugLocation(140, 97);
						adaptor.AddChild(root_0, stream_outputPortion.NextTree());

					}
					stream_outputPortion.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:141:9: name ( inputPortion )?
				{
				DebugLocation(141, 9);
				PushFollow(Follow._name_in_functionSignature526);
				name20=name();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name.Add(name20.Tree);
				DebugLocation(141, 14);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:141:14: ( inputPortion )?
				int alt7=2;
				try { DebugEnterSubRule(7);
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==LPAREN))
				{
					alt7 = 1;
				}
				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:141:15: inputPortion
					{
					DebugLocation(141, 15);
					PushFollow(Follow._inputPortion_in_functionSignature529);
					inputPortion21=inputPortion();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_inputPortion.Add(inputPortion21.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(7); }



				{
				// AST REWRITE
				// elements: name, inputPortion
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 141:30: -> name ( inputPortion )?
				{
					DebugLocation(141, 33);
					adaptor.AddChild(root_0, stream_name.NextTree());
					DebugLocation(141, 38);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:141:38: ( inputPortion )?
					if (stream_inputPortion.HasNext)
					{
						DebugLocation(141, 39);
						adaptor.AddChild(root_0, stream_inputPortion.NextTree());

					}
					stream_inputPortion.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionSignature", 8);
			LeaveRule("functionSignature", 8);
			LeaveRule_functionSignature();
		}
		DebugLocation(142, 6);
		} finally { DebugExitRule(GrammarFileName, "functionSignature"); }
		return retval;

	}
	// $ANTLR end "functionSignature"

	partial void EnterRule_outputPortion();
	partial void LeaveRule_outputPortion();
	// $ANTLR start "outputPortion"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:144:1: outputPortion : ( output ASSIGN -> output | outputVector ASSIGN -> ( outputVector )? );
	[GrammarRule("outputPortion")]
	private AstParserRuleReturnScope<object, IToken> outputPortion()
	{
		EnterRule_outputPortion();
		EnterRule("outputPortion", 9);
		TraceIn("outputPortion", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ASSIGN23 = default(IToken);
		IToken ASSIGN25 = default(IToken);
		AstParserRuleReturnScope<object, IToken> output22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> outputVector24 = default(AstParserRuleReturnScope<object, IToken>);

		object ASSIGN23_tree = default(object);
		object ASSIGN25_tree = default(object);
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_output=new RewriteRuleSubtreeStream(adaptor,"rule output");
		RewriteRuleSubtreeStream stream_outputVector=new RewriteRuleSubtreeStream(adaptor,"rule outputVector");
		try { DebugEnterRule(GrammarFileName, "outputPortion");
		DebugLocation(144, 5);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:144:15: ( output ASSIGN -> output | outputVector ASSIGN -> ( outputVector )? )
			int alt9=2;
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==ID))
			{
				alt9 = 1;
			}
			else if ((LA9_1==LSQUARE))
			{
				alt9 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 9, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:144:17: output ASSIGN
				{
				DebugLocation(144, 17);
				PushFollow(Follow._output_in_outputPortion555);
				output22=output();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_output.Add(output22.Tree);
				DebugLocation(144, 24);
				ASSIGN23=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_outputPortion557); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN23);



				{
				// AST REWRITE
				// elements: output
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 144:31: -> output
				{
					DebugLocation(144, 34);
					adaptor.AddChild(root_0, stream_output.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:145:8: outputVector ASSIGN
				{
				DebugLocation(145, 8);
				PushFollow(Follow._outputVector_in_outputPortion571);
				outputVector24=outputVector();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_outputVector.Add(outputVector24.Tree);
				DebugLocation(145, 21);
				ASSIGN25=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_outputPortion573); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN25);



				{
				// AST REWRITE
				// elements: outputVector
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 145:28: -> ( outputVector )?
				{
					DebugLocation(145, 31);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:145:31: ( outputVector )?
					if (stream_outputVector.HasNext)
					{
						DebugLocation(145, 32);
						adaptor.AddChild(root_0, stream_outputVector.NextTree());

					}
					stream_outputVector.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("outputPortion", 9);
			LeaveRule("outputPortion", 9);
			LeaveRule_outputPortion();
		}
		DebugLocation(146, 5);
		} finally { DebugExitRule(GrammarFileName, "outputPortion"); }
		return retval;

	}
	// $ANTLR end "outputPortion"

	partial void EnterRule_output();
	partial void LeaveRule_output();
	// $ANTLR start "output"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:148:1: output : name -> ^( OUTPUT[\"\"] name ) ;
	[GrammarRule("output")]
	private AstParserRuleReturnScope<object, IToken> output()
	{
		EnterRule_output();
		EnterRule("output", 10);
		TraceIn("output", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> name26 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		try { DebugEnterRule(GrammarFileName, "output");
		DebugLocation(148, 36);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:148:8: ( name -> ^( OUTPUT[\"\"] name ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:148:10: name
			{
			DebugLocation(148, 10);
			PushFollow(Follow._name_in_output594);
			name26=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(name26.Tree);


			{
			// AST REWRITE
			// elements: name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 148:15: -> ^( OUTPUT[\"\"] name )
			{
				DebugLocation(148, 18);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:148:18: ^( OUTPUT[\"\"] name )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(148, 20);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(OUTPUT, ""), root_1);

				DebugLocation(148, 31);
				adaptor.AddChild(root_1, stream_name.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("output", 10);
			LeaveRule("output", 10);
			LeaveRule_output();
		}
		DebugLocation(148, 36);
		} finally { DebugExitRule(GrammarFileName, "output"); }
		return retval;

	}
	// $ANTLR end "output"

	partial void EnterRule_name();
	partial void LeaveRule_name();
	// $ANTLR start "name"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:150:1: name : xID -> ^( NAME[\"\"] xID ) ;
	[GrammarRule("name")]
	private AstParserRuleReturnScope<object, IToken> name()
	{
		EnterRule_name();
		EnterRule("name", 11);
		TraceIn("name", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> xID27 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_xID=new RewriteRuleSubtreeStream(adaptor,"rule xID");
		try { DebugEnterRule(GrammarFileName, "name");
		DebugLocation(150, 30);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:150:6: ( xID -> ^( NAME[\"\"] xID ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:150:8: xID
			{
			DebugLocation(150, 8);
			PushFollow(Follow._xID_in_name612);
			xID27=xID();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xID.Add(xID27.Tree);


			{
			// AST REWRITE
			// elements: xID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 150:12: -> ^( NAME[\"\"] xID )
			{
				DebugLocation(150, 15);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:150:15: ^( NAME[\"\"] xID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(150, 17);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAME, ""), root_1);

				DebugLocation(150, 26);
				adaptor.AddChild(root_1, stream_xID.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("name", 11);
			LeaveRule("name", 11);
			LeaveRule_name();
		}
		DebugLocation(150, 30);
		} finally { DebugExitRule(GrammarFileName, "name"); }
		return retval;

	}
	// $ANTLR end "name"

	partial void EnterRule_outputVector();
	partial void LeaveRule_outputVector();
	// $ANTLR start "outputVector"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:152:1: outputVector : LSQUARE ( vectorOutputs )? RSQUARE -> ( vectorOutputs )? ;
	[GrammarRule("outputVector")]
	private AstParserRuleReturnScope<object, IToken> outputVector()
	{
		EnterRule_outputVector();
		EnterRule("outputVector", 12);
		TraceIn("outputVector", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LSQUARE28 = default(IToken);
		IToken RSQUARE30 = default(IToken);
		AstParserRuleReturnScope<object, IToken> vectorOutputs29 = default(AstParserRuleReturnScope<object, IToken>);

		object LSQUARE28_tree = default(object);
		object RSQUARE30_tree = default(object);
		RewriteRuleITokenStream stream_LSQUARE=new RewriteRuleITokenStream(adaptor,"token LSQUARE");
		RewriteRuleITokenStream stream_RSQUARE=new RewriteRuleITokenStream(adaptor,"token RSQUARE");
		RewriteRuleSubtreeStream stream_vectorOutputs=new RewriteRuleSubtreeStream(adaptor,"rule vectorOutputs");
		try { DebugEnterRule(GrammarFileName, "outputVector");
		DebugLocation(152, 68);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:152:14: ( LSQUARE ( vectorOutputs )? RSQUARE -> ( vectorOutputs )? )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:152:16: LSQUARE ( vectorOutputs )? RSQUARE
			{
			DebugLocation(152, 16);
			LSQUARE28=(IToken)Match(input,LSQUARE,Follow._LSQUARE_in_outputVector630); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LSQUARE.Add(LSQUARE28);

			DebugLocation(152, 24);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:152:24: ( vectorOutputs )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==ID))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:152:25: vectorOutputs
				{
				DebugLocation(152, 25);
				PushFollow(Follow._vectorOutputs_in_outputVector633);
				vectorOutputs29=vectorOutputs();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_vectorOutputs.Add(vectorOutputs29.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(152, 41);
			RSQUARE30=(IToken)Match(input,RSQUARE,Follow._RSQUARE_in_outputVector637); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RSQUARE.Add(RSQUARE30);



			{
			// AST REWRITE
			// elements: vectorOutputs
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 152:49: -> ( vectorOutputs )?
			{
				DebugLocation(152, 52);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:152:52: ( vectorOutputs )?
				if (stream_vectorOutputs.HasNext)
				{
					DebugLocation(152, 53);
					adaptor.AddChild(root_0, stream_vectorOutputs.NextTree());

				}
				stream_vectorOutputs.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("outputVector", 12);
			LeaveRule("outputVector", 12);
			LeaveRule_outputVector();
		}
		DebugLocation(152, 68);
		} finally { DebugExitRule(GrammarFileName, "outputVector"); }
		return retval;

	}
	// $ANTLR end "outputVector"

	partial void EnterRule_vectorOutputs();
	partial void LeaveRule_vectorOutputs();
	// $ANTLR start "vectorOutputs"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:154:1: vectorOutputs : vectorOutput ({...}? => ( COMMA )? vectorOutput )* -> ( vectorOutput )+ ;
	[GrammarRule("vectorOutputs")]
	private AstParserRuleReturnScope<object, IToken> vectorOutputs()
	{
		EnterRule_vectorOutputs();
		EnterRule("vectorOutputs", 13);
		TraceIn("vectorOutputs", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA32 = default(IToken);
		AstParserRuleReturnScope<object, IToken> vectorOutput31 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> vectorOutput33 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA32_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_vectorOutput=new RewriteRuleSubtreeStream(adaptor,"rule vectorOutput");
		try { DebugEnterRule(GrammarFileName, "vectorOutputs");
		DebugLocation(154, 118);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:154:15: ( vectorOutput ({...}? => ( COMMA )? vectorOutput )* -> ( vectorOutput )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:154:17: vectorOutput ({...}? => ( COMMA )? vectorOutput )*
			{
			DebugLocation(154, 17);
			PushFollow(Follow._vectorOutput_in_vectorOutputs653);
			vectorOutput31=vectorOutput();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_vectorOutput.Add(vectorOutput31.Tree);
			DebugLocation(154, 30);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:154:30: ({...}? => ( COMMA )? vectorOutput )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1==COMMA||LA12_1==ID) && ((Separator_CommaFollowsOrSpacesPrecede())))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:154:31: {...}? => ( COMMA )? vectorOutput
					{
					DebugLocation(154, 31);
					if (!((Separator_CommaFollowsOrSpacesPrecede())))
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "vectorOutputs", "Separator_CommaFollowsOrSpacesPrecede()");
					}
					DebugLocation(154, 76);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:154:76: ( COMMA )?
					int alt11=2;
					try { DebugEnterSubRule(11);
					try { DebugEnterDecision(11, false);
					int LA11_1 = input.LA(1);

					if ((LA11_1==COMMA))
					{
						alt11 = 1;
					}
					} finally { DebugExitDecision(11); }
					switch (alt11)
					{
					case 1:
						DebugEnterAlt(1);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:154:77: COMMA
						{
						DebugLocation(154, 77);
						COMMA32=(IToken)Match(input,COMMA,Follow._COMMA_in_vectorOutputs660); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA32);


						}
						break;

					}
					} finally { DebugExitSubRule(11); }

					DebugLocation(154, 85);
					PushFollow(Follow._vectorOutput_in_vectorOutputs664);
					vectorOutput33=vectorOutput();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_vectorOutput.Add(vectorOutput33.Tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }



			{
			// AST REWRITE
			// elements: vectorOutput
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 154:100: -> ( vectorOutput )+
			{
				DebugLocation(154, 103);
				if (!(stream_vectorOutput.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_vectorOutput.HasNext )
				{
					DebugLocation(154, 104);
					adaptor.AddChild(root_0, stream_vectorOutput.NextTree());

				}
				stream_vectorOutput.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("vectorOutputs", 13);
			LeaveRule("vectorOutputs", 13);
			LeaveRule_vectorOutputs();
		}
		DebugLocation(154, 118);
		} finally { DebugExitRule(GrammarFileName, "vectorOutputs"); }
		return retval;

	}
	// $ANTLR end "vectorOutputs"

	partial void EnterRule_vectorOutput();
	partial void LeaveRule_vectorOutput();
	// $ANTLR start "vectorOutput"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:156:1: vectorOutput : name ({...}? => filter )? -> ^( OUTPUT[\"\"] name ( filter )? ) ;
	[GrammarRule("vectorOutput")]
	private AstParserRuleReturnScope<object, IToken> vectorOutput()
	{
		EnterRule_vectorOutput();
		EnterRule("vectorOutput", 14);
		TraceIn("vectorOutput", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> name34 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> filter35 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_filter=new RewriteRuleSubtreeStream(adaptor,"rule filter");
		try { DebugEnterRule(GrammarFileName, "vectorOutput");
		DebugLocation(156, 94);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:156:14: ( name ({...}? => filter )? -> ^( OUTPUT[\"\"] name ( filter )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:156:16: name ({...}? => filter )?
			{
			DebugLocation(156, 16);
			PushFollow(Follow._name_in_vectorOutput682);
			name34=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(name34.Tree);
			DebugLocation(156, 21);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:156:21: ({...}? => filter )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if ((LA13_1==AT) && ((Method_SignatureIsActive())))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:156:22: {...}? => filter
				{
				DebugLocation(156, 22);
				if (!((Method_SignatureIsActive())))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "vectorOutput", "Method_SignatureIsActive()");
				}
				DebugLocation(156, 54);
				PushFollow(Follow._filter_in_vectorOutput688);
				filter35=filter();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_filter.Add(filter35.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(13); }



			{
			// AST REWRITE
			// elements: name, filter
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 156:63: -> ^( OUTPUT[\"\"] name ( filter )? )
			{
				DebugLocation(156, 66);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:156:66: ^( OUTPUT[\"\"] name ( filter )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(156, 68);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(OUTPUT, ""), root_1);

				DebugLocation(156, 79);
				adaptor.AddChild(root_1, stream_name.NextTree());
				DebugLocation(156, 84);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:156:84: ( filter )?
				if (stream_filter.HasNext)
				{
					DebugLocation(156, 85);
					adaptor.AddChild(root_1, stream_filter.NextTree());

				}
				stream_filter.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("vectorOutput", 14);
			LeaveRule("vectorOutput", 14);
			LeaveRule_vectorOutput();
		}
		DebugLocation(156, 94);
		} finally { DebugExitRule(GrammarFileName, "vectorOutput"); }
		return retval;

	}
	// $ANTLR end "vectorOutput"

	partial void EnterRule_filter();
	partial void LeaveRule_filter();
	// $ANTLR start "filter"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:158:1: filter : AT classReference -> classReference ;
	[GrammarRule("filter")]
	private AstParserRuleReturnScope<object, IToken> filter()
	{
		EnterRule_filter();
		EnterRule("filter", 15);
		TraceIn("filter", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AT36 = default(IToken);
		AstParserRuleReturnScope<object, IToken> classReference37 = default(AstParserRuleReturnScope<object, IToken>);

		object AT36_tree = default(object);
		RewriteRuleITokenStream stream_AT=new RewriteRuleITokenStream(adaptor,"token AT");
		RewriteRuleSubtreeStream stream_classReference=new RewriteRuleSubtreeStream(adaptor,"rule classReference");
		try { DebugEnterRule(GrammarFileName, "filter");
		DebugLocation(158, 45);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:158:8: ( AT classReference -> classReference )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:158:10: AT classReference
			{
			DebugLocation(158, 10);
			AT36=(IToken)Match(input,AT,Follow._AT_in_filter713); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_AT.Add(AT36);

			DebugLocation(158, 13);
			PushFollow(Follow._classReference_in_filter715);
			classReference37=classReference();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_classReference.Add(classReference37.Tree);


			{
			// AST REWRITE
			// elements: classReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 158:28: -> classReference
			{
				DebugLocation(158, 31);
				adaptor.AddChild(root_0, stream_classReference.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("filter", 15);
			LeaveRule("filter", 15);
			LeaveRule_filter();
		}
		DebugLocation(158, 45);
		} finally { DebugExitRule(GrammarFileName, "filter"); }
		return retval;

	}
	// $ANTLR end "filter"

	partial void EnterRule_functionName();
	partial void LeaveRule_functionName();
	// $ANTLR start "functionName"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:160:1: functionName : xFUNCTIONID -> ^( NAME[\"\"] xFUNCTIONID ) ;
	[GrammarRule("functionName")]
	private AstParserRuleReturnScope<object, IToken> functionName()
	{
		EnterRule_functionName();
		EnterRule("functionName", 16);
		TraceIn("functionName", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> xFUNCTIONID38 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_xFUNCTIONID=new RewriteRuleSubtreeStream(adaptor,"rule xFUNCTIONID");
		try { DebugEnterRule(GrammarFileName, "functionName");
		DebugLocation(160, 54);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:160:14: ( xFUNCTIONID -> ^( NAME[\"\"] xFUNCTIONID ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:160:16: xFUNCTIONID
			{
			DebugLocation(160, 16);
			PushFollow(Follow._xFUNCTIONID_in_functionName728);
			xFUNCTIONID38=xFUNCTIONID();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xFUNCTIONID.Add(xFUNCTIONID38.Tree);


			{
			// AST REWRITE
			// elements: xFUNCTIONID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 160:28: -> ^( NAME[\"\"] xFUNCTIONID )
			{
				DebugLocation(160, 31);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:160:31: ^( NAME[\"\"] xFUNCTIONID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(160, 33);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAME, ""), root_1);

				DebugLocation(160, 42);
				adaptor.AddChild(root_1, stream_xFUNCTIONID.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionName", 16);
			LeaveRule("functionName", 16);
			LeaveRule_functionName();
		}
		DebugLocation(160, 54);
		} finally { DebugExitRule(GrammarFileName, "functionName"); }
		return retval;

	}
	// $ANTLR end "functionName"

	partial void EnterRule_inputPortion();
	partial void LeaveRule_inputPortion();
	// $ANTLR start "inputPortion"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:162:1: inputPortion : LPAREN ( parameters )? RPAREN -> ( parameters )? ;
	[GrammarRule("inputPortion")]
	private AstParserRuleReturnScope<object, IToken> inputPortion()
	{
		EnterRule_inputPortion();
		EnterRule("inputPortion", 17);
		TraceIn("inputPortion", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN39 = default(IToken);
		IToken RPAREN41 = default(IToken);
		AstParserRuleReturnScope<object, IToken> parameters40 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN39_tree = default(object);
		object RPAREN41_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_parameters=new RewriteRuleSubtreeStream(adaptor,"rule parameters");
		try { DebugEnterRule(GrammarFileName, "inputPortion");
		DebugLocation(162, 60);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:162:14: ( LPAREN ( parameters )? RPAREN -> ( parameters )? )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:162:16: LPAREN ( parameters )? RPAREN
			{
			DebugLocation(162, 16);
			LPAREN39=(IToken)Match(input,LPAREN,Follow._LPAREN_in_inputPortion746); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN39);

			DebugLocation(162, 23);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:162:23: ( parameters )?
			int alt14=2;
			try { DebugEnterSubRule(14);
			try { DebugEnterDecision(14, false);
			int LA14_1 = input.LA(1);

			if ((LA14_1==ID||LA14_1==NOT))
			{
				alt14 = 1;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:162:24: parameters
				{
				DebugLocation(162, 24);
				PushFollow(Follow._parameters_in_inputPortion749);
				parameters40=parameters();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameters.Add(parameters40.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(14); }

			DebugLocation(162, 37);
			RPAREN41=(IToken)Match(input,RPAREN,Follow._RPAREN_in_inputPortion753); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN41);



			{
			// AST REWRITE
			// elements: parameters
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 162:44: -> ( parameters )?
			{
				DebugLocation(162, 47);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:162:47: ( parameters )?
				if (stream_parameters.HasNext)
				{
					DebugLocation(162, 48);
					adaptor.AddChild(root_0, stream_parameters.NextTree());

				}
				stream_parameters.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("inputPortion", 17);
			LeaveRule("inputPortion", 17);
			LeaveRule_inputPortion();
		}
		DebugLocation(162, 60);
		} finally { DebugExitRule(GrammarFileName, "inputPortion"); }
		return retval;

	}
	// $ANTLR end "inputPortion"

	partial void EnterRule_parameters();
	partial void LeaveRule_parameters();
	// $ANTLR start "parameters"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:164:1: parameters : parameter ( COMMA parameter )* -> ( parameter )+ ;
	[GrammarRule("parameters")]
	private AstParserRuleReturnScope<object, IToken> parameters()
	{
		EnterRule_parameters();
		EnterRule("parameters", 18);
		TraceIn("parameters", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA43 = default(IToken);
		AstParserRuleReturnScope<object, IToken> parameter42 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parameter44 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA43_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_parameter=new RewriteRuleSubtreeStream(adaptor,"rule parameter");
		try { DebugEnterRule(GrammarFileName, "parameters");
		DebugLocation(164, 58);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:164:12: ( parameter ( COMMA parameter )* -> ( parameter )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:164:14: parameter ( COMMA parameter )*
			{
			DebugLocation(164, 14);
			PushFollow(Follow._parameter_in_parameters769);
			parameter42=parameter();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_parameter.Add(parameter42.Tree);
			DebugLocation(164, 24);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:164:24: ( COMMA parameter )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if ((LA15_1==COMMA))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:164:25: COMMA parameter
					{
					DebugLocation(164, 25);
					COMMA43=(IToken)Match(input,COMMA,Follow._COMMA_in_parameters772); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA43);

					DebugLocation(164, 31);
					PushFollow(Follow._parameter_in_parameters774);
					parameter44=parameter();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_parameter.Add(parameter44.Tree);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }



			{
			// AST REWRITE
			// elements: parameter
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 164:43: -> ( parameter )+
			{
				DebugLocation(164, 46);
				if (!(stream_parameter.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_parameter.HasNext )
				{
					DebugLocation(164, 47);
					adaptor.AddChild(root_0, stream_parameter.NextTree());

				}
				stream_parameter.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameters", 18);
			LeaveRule("parameters", 18);
			LeaveRule_parameters();
		}
		DebugLocation(164, 58);
		} finally { DebugExitRule(GrammarFileName, "parameters"); }
		return retval;

	}
	// $ANTLR end "parameters"

	partial void EnterRule_parameter();
	partial void LeaveRule_parameter();
	// $ANTLR start "parameter"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:166:1: parameter : parameterName ({...}? => filter )? -> ^( INPUT[\"\"] parameterName ( filter )? ) ;
	[GrammarRule("parameter")]
	private AstParserRuleReturnScope<object, IToken> parameter()
	{
		EnterRule_parameter();
		EnterRule("parameter", 19);
		TraceIn("parameter", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> parameterName45 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> filter46 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_parameterName=new RewriteRuleSubtreeStream(adaptor,"rule parameterName");
		RewriteRuleSubtreeStream stream_filter=new RewriteRuleSubtreeStream(adaptor,"rule filter");
		try { DebugEnterRule(GrammarFileName, "parameter");
		DebugLocation(166, 108);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:166:11: ( parameterName ({...}? => filter )? -> ^( INPUT[\"\"] parameterName ( filter )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:166:13: parameterName ({...}? => filter )?
			{
			DebugLocation(166, 13);
			PushFollow(Follow._parameterName_in_parameter792);
			parameterName45=parameterName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_parameterName.Add(parameterName45.Tree);
			DebugLocation(166, 27);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:166:27: ({...}? => filter )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_1 = input.LA(1);

			if ((LA16_1==AT) && ((Method_SignatureIsActive())))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:166:28: {...}? => filter
				{
				DebugLocation(166, 28);
				if (!((Method_SignatureIsActive())))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "parameter", "Method_SignatureIsActive()");
				}
				DebugLocation(166, 60);
				PushFollow(Follow._filter_in_parameter798);
				filter46=filter();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_filter.Add(filter46.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(16); }



			{
			// AST REWRITE
			// elements: parameterName, filter
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 166:69: -> ^( INPUT[\"\"] parameterName ( filter )? )
			{
				DebugLocation(166, 72);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:166:72: ^( INPUT[\"\"] parameterName ( filter )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(166, 74);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(INPUT, ""), root_1);

				DebugLocation(166, 84);
				adaptor.AddChild(root_1, stream_parameterName.NextTree());
				DebugLocation(166, 98);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:166:98: ( filter )?
				if (stream_filter.HasNext)
				{
					DebugLocation(166, 99);
					adaptor.AddChild(root_1, stream_filter.NextTree());

				}
				stream_filter.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameter", 19);
			LeaveRule("parameter", 19);
			LeaveRule_parameter();
		}
		DebugLocation(166, 108);
		} finally { DebugExitRule(GrammarFileName, "parameter"); }
		return retval;

	}
	// $ANTLR end "parameter"

	partial void EnterRule_parameterName();
	partial void LeaveRule_parameterName();
	// $ANTLR start "parameterName"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:168:1: parameterName : xPARAMETERID -> ^( NAME[\"\"] xPARAMETERID ) ;
	[GrammarRule("parameterName")]
	private AstParserRuleReturnScope<object, IToken> parameterName()
	{
		EnterRule_parameterName();
		EnterRule("parameterName", 20);
		TraceIn("parameterName", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> xPARAMETERID47 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_xPARAMETERID=new RewriteRuleSubtreeStream(adaptor,"rule xPARAMETERID");
		try { DebugEnterRule(GrammarFileName, "parameterName");
		DebugLocation(168, 57);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:168:15: ( xPARAMETERID -> ^( NAME[\"\"] xPARAMETERID ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:168:17: xPARAMETERID
			{
			DebugLocation(168, 17);
			PushFollow(Follow._xPARAMETERID_in_parameterName823);
			xPARAMETERID47=xPARAMETERID();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xPARAMETERID.Add(xPARAMETERID47.Tree);


			{
			// AST REWRITE
			// elements: xPARAMETERID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 168:30: -> ^( NAME[\"\"] xPARAMETERID )
			{
				DebugLocation(168, 33);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:168:33: ^( NAME[\"\"] xPARAMETERID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(168, 35);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAME, ""), root_1);

				DebugLocation(168, 44);
				adaptor.AddChild(root_1, stream_xPARAMETERID.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameterName", 20);
			LeaveRule("parameterName", 20);
			LeaveRule_parameterName();
		}
		DebugLocation(168, 57);
		} finally { DebugExitRule(GrammarFileName, "parameterName"); }
		return retval;

	}
	// $ANTLR end "parameterName"

	partial void EnterRule_openBody();
	partial void LeaveRule_openBody();
	// $ANTLR start "openBody"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:170:1: openBody : ( xEOS openItems )? -> ( openItems )? ;
	[GrammarRule("openBody")]
	private AstParserRuleReturnScope<object, IToken> openBody()
	{
		EnterRule_openBody();
		EnterRule("openBody", 21);
		TraceIn("openBody", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> xEOS48 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> openItems49 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_openItems=new RewriteRuleSubtreeStream(adaptor,"rule openItems");
		try { DebugEnterRule(GrammarFileName, "openBody");
		DebugLocation(170, 45);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:170:10: ( ( xEOS openItems )? -> ( openItems )? )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:170:12: ( xEOS openItems )?
			{
			DebugLocation(170, 12);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:170:12: ( xEOS openItems )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			int LA17_1 = input.LA(1);

			if ((LA17_1==COMMA||LA17_1==EOL||LA17_1==SEMICOLON))
			{
				alt17 = 1;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:170:13: xEOS openItems
				{
				DebugLocation(170, 13);
				PushFollow(Follow._xEOS_in_openBody842);
				xEOS48=xEOS();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_xEOS.Add(xEOS48.Tree);
				DebugLocation(170, 18);
				PushFollow(Follow._openItems_in_openBody844);
				openItems49=openItems();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_openItems.Add(openItems49.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(17); }



			{
			// AST REWRITE
			// elements: openItems
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 170:30: -> ( openItems )?
			{
				DebugLocation(170, 33);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:170:33: ( openItems )?
				if (stream_openItems.HasNext)
				{
					DebugLocation(170, 34);
					adaptor.AddChild(root_0, stream_openItems.NextTree());

				}
				stream_openItems.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("openBody", 21);
			LeaveRule("openBody", 21);
			LeaveRule_openBody();
		}
		DebugLocation(170, 45);
		} finally { DebugExitRule(GrammarFileName, "openBody"); }
		return retval;

	}
	// $ANTLR end "openBody"

	partial void EnterRule_openItems();
	partial void LeaveRule_openItems();
	// $ANTLR start "openItems"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:172:1: openItems : ( openItem | xEOS )* -> ( openItem )* ;
	[GrammarRule("openItems")]
	private AstParserRuleReturnScope<object, IToken> openItems()
	{
		EnterRule_openItems();
		EnterRule("openItems", 22);
		TraceIn("openItems", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> openItem50 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS51 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_openItem=new RewriteRuleSubtreeStream(adaptor,"rule openItem");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "openItems");
		DebugLocation(172, 46);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:172:11: ( ( openItem | xEOS )* -> ( openItem )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:172:13: ( openItem | xEOS )*
			{
			DebugLocation(172, 13);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:172:13: ( openItem | xEOS )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=3;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1==ID) && (((True())||(Command_IsEnabled()))))
				{
					alt18 = 1;
				}
				else if ((LA18_1==IMAGINARY||LA18_1==LCURLY||(LA18_1>=LPAREN && LA18_1<=LSQUARE)||LA18_1==MINUS||LA18_1==NOT||LA18_1==PLUS||LA18_1==REAL||LA18_1==STRING) && ((True())))
				{
					alt18 = 1;
				}
				else if ((LA18_1==END) && (((True())&&(Index_IsActive()))))
				{
					alt18 = 1;
				}
				else if ((LA18_1==AT||LA18_1==QUESTION) && ((True())))
				{
					alt18 = 1;
				}
				else if ((LA18_1==BREAK||LA18_1==COMMAND||LA18_1==CONTINUE||LA18_1==EXCLAMATION||LA18_1==FOR||LA18_1==GLOBAL||LA18_1==IF||(LA18_1>=PARFOR && LA18_1<=PERSISTENT)||LA18_1==RETURN||LA18_1==SPMD||LA18_1==SWITCH||LA18_1==TRY||LA18_1==WHILE))
				{
					alt18 = 1;
				}
				else if ((LA18_1==COMMA||LA18_1==EOL||LA18_1==SEMICOLON))
				{
					alt18 = 2;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:172:14: openItem
					{
					DebugLocation(172, 14);
					PushFollow(Follow._openItem_in_openItems863);
					openItem50=openItem();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_openItem.Add(openItem50.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:172:25: xEOS
					{
					DebugLocation(172, 25);
					PushFollow(Follow._xEOS_in_openItems867);
					xEOS51=xEOS();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_xEOS.Add(xEOS51.Tree);

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }



			{
			// AST REWRITE
			// elements: openItem
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 172:32: -> ( openItem )*
			{
				DebugLocation(172, 35);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:172:35: ( openItem )*
				while ( stream_openItem.HasNext )
				{
					DebugLocation(172, 36);
					adaptor.AddChild(root_0, stream_openItem.NextTree());

				}
				stream_openItem.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("openItems", 22);
			LeaveRule("openItems", 22);
			LeaveRule_openItems();
		}
		DebugLocation(172, 46);
		} finally { DebugExitRule(GrammarFileName, "openItems"); }
		return retval;

	}
	// $ANTLR end "openItems"

	partial void EnterRule_openItem();
	partial void LeaveRule_openItem();
	// $ANTLR start "openItem"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:174:1: openItem : statement -> statement ;
	[GrammarRule("openItem")]
	private AstParserRuleReturnScope<object, IToken> openItem()
	{
		EnterRule_openItem();
		EnterRule("openItem", 23);
		TraceIn("openItem", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> statement52 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "openItem");
		DebugLocation(174, 34);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:174:10: ( statement -> statement )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:174:12: statement
			{
			DebugLocation(174, 12);
			PushFollow(Follow._statement_in_openItem885);
			statement52=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement52.Tree);


			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 174:22: -> statement
			{
				DebugLocation(174, 25);
				adaptor.AddChild(root_0, stream_statement.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("openItem", 23);
			LeaveRule("openItem", 23);
			LeaveRule_openItem();
		}
		DebugLocation(174, 34);
		} finally { DebugExitRule(GrammarFileName, "openItem"); }
		return retval;

	}
	// $ANTLR end "openItem"

	partial void EnterRule_closeFunctionFile();
	partial void LeaveRule_closeFunctionFile();
	// $ANTLR start "closeFunctionFile"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:178:1: closeFunctionFile : ( EOL )* closeFunctions ( EOL )* EOF -> ^( FUNCTIONFILE[\"\"] closeFunctions ) ;
	[GrammarRule("closeFunctionFile")]
	private AstParserRuleReturnScope<object, IToken> closeFunctionFile()
	{
		EnterRule_closeFunctionFile();
		EnterRule("closeFunctionFile", 24);
		TraceIn("closeFunctionFile", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOL53 = default(IToken);
		IToken EOL55 = default(IToken);
		IToken EOF56 = default(IToken);
		AstParserRuleReturnScope<object, IToken> closeFunctions54 = default(AstParserRuleReturnScope<object, IToken>);

		object EOL53_tree = default(object);
		object EOL55_tree = default(object);
		object EOF56_tree = default(object);
		RewriteRuleITokenStream stream_EOL=new RewriteRuleITokenStream(adaptor,"token EOL");
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_closeFunctions=new RewriteRuleSubtreeStream(adaptor,"rule closeFunctions");
		try { DebugEnterRule(GrammarFileName, "closeFunctionFile");
		DebugLocation(178, 91);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:178:19: ( ( EOL )* closeFunctions ( EOL )* EOF -> ^( FUNCTIONFILE[\"\"] closeFunctions ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:178:21: ( EOL )* closeFunctions ( EOL )* EOF
			{
			DebugLocation(178, 21);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:178:21: ( EOL )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==EOL))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:178:22: EOL
					{
					DebugLocation(178, 22);
					EOL53=(IToken)Match(input,EOL,Follow._EOL_in_closeFunctionFile901); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_EOL.Add(EOL53);


					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(178, 28);
			PushFollow(Follow._closeFunctions_in_closeFunctionFile905);
			closeFunctions54=closeFunctions();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_closeFunctions.Add(closeFunctions54.Tree);
			DebugLocation(178, 43);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:178:43: ( EOL )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if ((LA20_1==EOL))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:178:44: EOL
					{
					DebugLocation(178, 44);
					EOL55=(IToken)Match(input,EOL,Follow._EOL_in_closeFunctionFile908); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_EOL.Add(EOL55);


					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }

			DebugLocation(178, 50);
			EOF56=(IToken)Match(input,EOF,Follow._EOF_in_closeFunctionFile912); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF56);



			{
			// AST REWRITE
			// elements: closeFunctions
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 178:54: -> ^( FUNCTIONFILE[\"\"] closeFunctions )
			{
				DebugLocation(178, 57);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:178:57: ^( FUNCTIONFILE[\"\"] closeFunctions )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(178, 59);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTIONFILE, ""), root_1);

				DebugLocation(178, 76);
				adaptor.AddChild(root_1, stream_closeFunctions.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("closeFunctionFile", 24);
			LeaveRule("closeFunctionFile", 24);
			LeaveRule_closeFunctionFile();
		}
		DebugLocation(178, 91);
		} finally { DebugExitRule(GrammarFileName, "closeFunctionFile"); }
		return retval;

	}
	// $ANTLR end "closeFunctionFile"

	partial void EnterRule_closeFunctions();
	partial void LeaveRule_closeFunctions();
	// $ANTLR start "closeFunctions"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:180:1: closeFunctions : closeFunction ( ( EOL )* closeFunction )* -> ( closeFunction )+ ;
	[GrammarRule("closeFunctions")]
	private AstParserRuleReturnScope<object, IToken> closeFunctions()
	{
		EnterRule_closeFunctions();
		EnterRule("closeFunctions", 25);
		TraceIn("closeFunctions", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOL58 = default(IToken);
		AstParserRuleReturnScope<object, IToken> closeFunction57 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> closeFunction59 = default(AstParserRuleReturnScope<object, IToken>);

		object EOL58_tree = default(object);
		RewriteRuleITokenStream stream_EOL=new RewriteRuleITokenStream(adaptor,"token EOL");
		RewriteRuleSubtreeStream stream_closeFunction=new RewriteRuleSubtreeStream(adaptor,"rule closeFunction");
		try { DebugEnterRule(GrammarFileName, "closeFunctions");
		DebugLocation(180, 75);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:180:16: ( closeFunction ( ( EOL )* closeFunction )* -> ( closeFunction )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:180:18: closeFunction ( ( EOL )* closeFunction )*
			{
			DebugLocation(180, 18);
			PushFollow(Follow._closeFunction_in_closeFunctions930);
			closeFunction57=closeFunction();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_closeFunction.Add(closeFunction57.Tree);
			DebugLocation(180, 32);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:180:32: ( ( EOL )* closeFunction )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				try
				{
					alt22 = dfa22.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:180:33: ( EOL )* closeFunction
					{
					DebugLocation(180, 33);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:180:33: ( EOL )*
					try { DebugEnterSubRule(21);
					while (true)
					{
						int alt21=2;
						try { DebugEnterDecision(21, false);
						int LA21_1 = input.LA(1);

						if ((LA21_1==EOL))
						{
							alt21 = 1;
						}


						} finally { DebugExitDecision(21); }
						switch ( alt21 )
						{
						case 1:
							DebugEnterAlt(1);
							// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:180:34: EOL
							{
							DebugLocation(180, 34);
							EOL58=(IToken)Match(input,EOL,Follow._EOL_in_closeFunctions934); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_EOL.Add(EOL58);


							}
							break;

						default:
							goto loop21;
						}
					}

					loop21:
						;

					} finally { DebugExitSubRule(21); }

					DebugLocation(180, 40);
					PushFollow(Follow._closeFunction_in_closeFunctions938);
					closeFunction59=closeFunction();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_closeFunction.Add(closeFunction59.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }



			{
			// AST REWRITE
			// elements: closeFunction
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 180:56: -> ( closeFunction )+
			{
				DebugLocation(180, 59);
				if (!(stream_closeFunction.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_closeFunction.HasNext )
				{
					DebugLocation(180, 60);
					adaptor.AddChild(root_0, stream_closeFunction.NextTree());

				}
				stream_closeFunction.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("closeFunctions", 25);
			LeaveRule("closeFunctions", 25);
			LeaveRule_closeFunctions();
		}
		DebugLocation(180, 75);
		} finally { DebugExitRule(GrammarFileName, "closeFunctions"); }
		return retval;

	}
	// $ANTLR end "closeFunctions"

	partial void EnterRule_closeFunction();
	partial void LeaveRule_closeFunction();
	// $ANTLR start "closeFunction"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:182:1: closeFunction : FUNCTION functionSignature closeBody END -> ^( FUNCTION functionSignature ( closeBody )? ) ;
	[GrammarRule("closeFunction")]
	private AstParserRuleReturnScope<object, IToken> closeFunction()
	{
		EnterRule_closeFunction();
		EnterRule("closeFunction", 26);
		TraceIn("closeFunction", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FUNCTION60 = default(IToken);
		IToken END63 = default(IToken);
		AstParserRuleReturnScope<object, IToken> functionSignature61 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> closeBody62 = default(AstParserRuleReturnScope<object, IToken>);

		object FUNCTION60_tree = default(object);
		object END63_tree = default(object);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_functionSignature=new RewriteRuleSubtreeStream(adaptor,"rule functionSignature");
		RewriteRuleSubtreeStream stream_closeBody=new RewriteRuleSubtreeStream(adaptor,"rule closeBody");
		try { DebugEnterRule(GrammarFileName, "closeFunction");
		DebugLocation(182, 103);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:182:15: ( FUNCTION functionSignature closeBody END -> ^( FUNCTION functionSignature ( closeBody )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:182:17: FUNCTION functionSignature closeBody END
			{
			DebugLocation(182, 17);
			FUNCTION60=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_closeFunction956); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION60);

			DebugLocation(182, 26);
			PushFollow(Follow._functionSignature_in_closeFunction958);
			functionSignature61=functionSignature();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_functionSignature.Add(functionSignature61.Tree);
			DebugLocation(182, 44);
			PushFollow(Follow._closeBody_in_closeFunction960);
			closeBody62=closeBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_closeBody.Add(closeBody62.Tree);
			DebugLocation(182, 54);
			END63=(IToken)Match(input,END,Follow._END_in_closeFunction962); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END63);



			{
			// AST REWRITE
			// elements: FUNCTION, functionSignature, closeBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 182:58: -> ^( FUNCTION functionSignature ( closeBody )? )
			{
				DebugLocation(182, 61);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:182:61: ^( FUNCTION functionSignature ( closeBody )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(182, 63);
				root_1 = (object)adaptor.BecomeRoot(stream_FUNCTION.NextNode(), root_1);

				DebugLocation(182, 72);
				adaptor.AddChild(root_1, stream_functionSignature.NextTree());
				DebugLocation(182, 90);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:182:90: ( closeBody )?
				if (stream_closeBody.HasNext)
				{
					DebugLocation(182, 91);
					adaptor.AddChild(root_1, stream_closeBody.NextTree());

				}
				stream_closeBody.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("closeFunction", 26);
			LeaveRule("closeFunction", 26);
			LeaveRule_closeFunction();
		}
		DebugLocation(182, 103);
		} finally { DebugExitRule(GrammarFileName, "closeFunction"); }
		return retval;

	}
	// $ANTLR end "closeFunction"

	partial void EnterRule_closeBody();
	partial void LeaveRule_closeBody();
	// $ANTLR start "closeBody"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:184:1: closeBody : ( xEOS closeItems )? -> ( closeItems )? ;
	[GrammarRule("closeBody")]
	private AstParserRuleReturnScope<object, IToken> closeBody()
	{
		EnterRule_closeBody();
		EnterRule("closeBody", 27);
		TraceIn("closeBody", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> xEOS64 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> closeItems65 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_closeItems=new RewriteRuleSubtreeStream(adaptor,"rule closeItems");
		try { DebugEnterRule(GrammarFileName, "closeBody");
		DebugLocation(184, 48);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:184:11: ( ( xEOS closeItems )? -> ( closeItems )? )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:184:13: ( xEOS closeItems )?
			{
			DebugLocation(184, 13);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:184:13: ( xEOS closeItems )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_1 = input.LA(1);

			if ((LA23_1==COMMA||LA23_1==EOL||LA23_1==SEMICOLON))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:184:14: xEOS closeItems
				{
				DebugLocation(184, 14);
				PushFollow(Follow._xEOS_in_closeBody985);
				xEOS64=xEOS();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_xEOS.Add(xEOS64.Tree);
				DebugLocation(184, 19);
				PushFollow(Follow._closeItems_in_closeBody987);
				closeItems65=closeItems();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_closeItems.Add(closeItems65.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(23); }



			{
			// AST REWRITE
			// elements: closeItems
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 184:32: -> ( closeItems )?
			{
				DebugLocation(184, 35);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:184:35: ( closeItems )?
				if (stream_closeItems.HasNext)
				{
					DebugLocation(184, 36);
					adaptor.AddChild(root_0, stream_closeItems.NextTree());

				}
				stream_closeItems.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("closeBody", 27);
			LeaveRule("closeBody", 27);
			LeaveRule_closeBody();
		}
		DebugLocation(184, 48);
		} finally { DebugExitRule(GrammarFileName, "closeBody"); }
		return retval;

	}
	// $ANTLR end "closeBody"

	partial void EnterRule_closeItems();
	partial void LeaveRule_closeItems();
	// $ANTLR start "closeItems"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:186:1: closeItems : ( closeItem | xEOS )* -> ( closeItem )* ;
	[GrammarRule("closeItems")]
	private AstParserRuleReturnScope<object, IToken> closeItems()
	{
		EnterRule_closeItems();
		EnterRule("closeItems", 28);
		TraceIn("closeItems", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> closeItem66 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS67 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_closeItem=new RewriteRuleSubtreeStream(adaptor,"rule closeItem");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "closeItems");
		DebugLocation(186, 49);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:186:12: ( ( closeItem | xEOS )* -> ( closeItem )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:186:14: ( closeItem | xEOS )*
			{
			DebugLocation(186, 14);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:186:14: ( closeItem | xEOS )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=3;
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if ((LA24_1==END))
				{
					int LA24_2 = input.LA(2);

					if ((((True())&&(Index_IsActive()))))
					{
						alt24 = 1;
					}


				}
				else if ((LA24_1==FUNCTION))
				{
					alt24 = 1;
				}
				else if ((LA24_1==ID) && (((True())||(Command_IsEnabled()))))
				{
					alt24 = 1;
				}
				else if ((LA24_1==AT||LA24_1==IMAGINARY||LA24_1==LCURLY||(LA24_1>=LPAREN && LA24_1<=LSQUARE)||LA24_1==MINUS||LA24_1==NOT||LA24_1==PLUS||LA24_1==QUESTION||LA24_1==REAL||LA24_1==STRING) && ((True())))
				{
					alt24 = 1;
				}
				else if ((LA24_1==BREAK||LA24_1==COMMAND||LA24_1==CONTINUE||LA24_1==EXCLAMATION||LA24_1==FOR||LA24_1==GLOBAL||LA24_1==IF||(LA24_1>=PARFOR && LA24_1<=PERSISTENT)||LA24_1==RETURN||LA24_1==SPMD||LA24_1==SWITCH||LA24_1==TRY||LA24_1==WHILE))
				{
					alt24 = 1;
				}
				else if ((LA24_1==COMMA||LA24_1==EOL||LA24_1==SEMICOLON))
				{
					alt24 = 2;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:186:15: closeItem
					{
					DebugLocation(186, 15);
					PushFollow(Follow._closeItem_in_closeItems1006);
					closeItem66=closeItem();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_closeItem.Add(closeItem66.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:186:27: xEOS
					{
					DebugLocation(186, 27);
					PushFollow(Follow._xEOS_in_closeItems1010);
					xEOS67=xEOS();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_xEOS.Add(xEOS67.Tree);

					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }



			{
			// AST REWRITE
			// elements: closeItem
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 186:34: -> ( closeItem )*
			{
				DebugLocation(186, 37);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:186:37: ( closeItem )*
				while ( stream_closeItem.HasNext )
				{
					DebugLocation(186, 38);
					adaptor.AddChild(root_0, stream_closeItem.NextTree());

				}
				stream_closeItem.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("closeItems", 28);
			LeaveRule("closeItems", 28);
			LeaveRule_closeItems();
		}
		DebugLocation(186, 49);
		} finally { DebugExitRule(GrammarFileName, "closeItems"); }
		return retval;

	}
	// $ANTLR end "closeItems"

	partial void EnterRule_closeItem();
	partial void LeaveRule_closeItem();
	// $ANTLR start "closeItem"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:188:1: closeItem : ( nestedFunction -> nestedFunction | statement -> statement );
	[GrammarRule("closeItem")]
	private AstParserRuleReturnScope<object, IToken> closeItem()
	{
		EnterRule_closeItem();
		EnterRule("closeItem", 29);
		TraceIn("closeItem", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> nestedFunction68 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statement69 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_nestedFunction=new RewriteRuleSubtreeStream(adaptor,"rule nestedFunction");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "closeItem");
		DebugLocation(188, 4);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:188:11: ( nestedFunction -> nestedFunction | statement -> statement )
			int alt25=2;
			try { DebugEnterDecision(25, false);
			int LA25_1 = input.LA(1);

			if ((LA25_1==FUNCTION))
			{
				alt25 = 1;
			}
			else if ((LA25_1==ID) && (((True())||(Command_IsEnabled()))))
			{
				alt25 = 2;
			}
			else if ((LA25_1==IMAGINARY||LA25_1==LCURLY||(LA25_1>=LPAREN && LA25_1<=LSQUARE)||LA25_1==MINUS||LA25_1==NOT||LA25_1==PLUS||LA25_1==REAL||LA25_1==STRING) && ((True())))
			{
				alt25 = 2;
			}
			else if ((LA25_1==END) && (((True())&&(Index_IsActive()))))
			{
				alt25 = 2;
			}
			else if ((LA25_1==AT||LA25_1==QUESTION) && ((True())))
			{
				alt25 = 2;
			}
			else if ((LA25_1==BREAK||LA25_1==COMMAND||LA25_1==CONTINUE||LA25_1==EXCLAMATION||LA25_1==FOR||LA25_1==GLOBAL||LA25_1==IF||(LA25_1>=PARFOR && LA25_1<=PERSISTENT)||LA25_1==RETURN||LA25_1==SPMD||LA25_1==SWITCH||LA25_1==TRY||LA25_1==WHILE))
			{
				alt25 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 25, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(25); }
			switch (alt25)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:188:13: nestedFunction
				{
				DebugLocation(188, 13);
				PushFollow(Follow._nestedFunction_in_closeItem1028);
				nestedFunction68=nestedFunction();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_nestedFunction.Add(nestedFunction68.Tree);


				{
				// AST REWRITE
				// elements: nestedFunction
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 188:28: -> nestedFunction
				{
					DebugLocation(188, 31);
					adaptor.AddChild(root_0, stream_nestedFunction.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:189:13: statement
				{
				DebugLocation(189, 13);
				PushFollow(Follow._statement_in_closeItem1047);
				statement69=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statement.Add(statement69.Tree);


				{
				// AST REWRITE
				// elements: statement
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 189:23: -> statement
				{
					DebugLocation(189, 26);
					adaptor.AddChild(root_0, stream_statement.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("closeItem", 29);
			LeaveRule("closeItem", 29);
			LeaveRule_closeItem();
		}
		DebugLocation(190, 4);
		} finally { DebugExitRule(GrammarFileName, "closeItem"); }
		return retval;

	}
	// $ANTLR end "closeItem"

	partial void EnterRule_nestedFunction();
	partial void LeaveRule_nestedFunction();
	// $ANTLR start "nestedFunction"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:192:1: nestedFunction : FUNCTION functionSignature closeBody END -> ^( NESTEDFUNCTION[$FUNCTION] functionSignature ( closeBody )? ) ;
	[GrammarRule("nestedFunction")]
	private AstParserRuleReturnScope<object, IToken> nestedFunction()
	{
		EnterRule_nestedFunction();
		EnterRule("nestedFunction", 30);
		TraceIn("nestedFunction", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FUNCTION70 = default(IToken);
		IToken END73 = default(IToken);
		AstParserRuleReturnScope<object, IToken> functionSignature71 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> closeBody72 = default(AstParserRuleReturnScope<object, IToken>);

		object FUNCTION70_tree = default(object);
		object END73_tree = default(object);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_functionSignature=new RewriteRuleSubtreeStream(adaptor,"rule functionSignature");
		RewriteRuleSubtreeStream stream_closeBody=new RewriteRuleSubtreeStream(adaptor,"rule closeBody");
		try { DebugEnterRule(GrammarFileName, "nestedFunction");
		DebugLocation(192, 121);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:192:16: ( FUNCTION functionSignature closeBody END -> ^( NESTEDFUNCTION[$FUNCTION] functionSignature ( closeBody )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:192:18: FUNCTION functionSignature closeBody END
			{
			DebugLocation(192, 18);
			FUNCTION70=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_nestedFunction1065); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION70);

			DebugLocation(192, 27);
			PushFollow(Follow._functionSignature_in_nestedFunction1067);
			functionSignature71=functionSignature();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_functionSignature.Add(functionSignature71.Tree);
			DebugLocation(192, 45);
			PushFollow(Follow._closeBody_in_nestedFunction1069);
			closeBody72=closeBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_closeBody.Add(closeBody72.Tree);
			DebugLocation(192, 55);
			END73=(IToken)Match(input,END,Follow._END_in_nestedFunction1071); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END73);



			{
			// AST REWRITE
			// elements: functionSignature, closeBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 192:59: -> ^( NESTEDFUNCTION[$FUNCTION] functionSignature ( closeBody )? )
			{
				DebugLocation(192, 62);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:192:62: ^( NESTEDFUNCTION[$FUNCTION] functionSignature ( closeBody )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(192, 64);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NESTEDFUNCTION, FUNCTION70), root_1);

				DebugLocation(192, 90);
				adaptor.AddChild(root_1, stream_functionSignature.NextTree());
				DebugLocation(192, 108);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:192:108: ( closeBody )?
				if (stream_closeBody.HasNext)
				{
					DebugLocation(192, 109);
					adaptor.AddChild(root_1, stream_closeBody.NextTree());

				}
				stream_closeBody.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nestedFunction", 30);
			LeaveRule("nestedFunction", 30);
			LeaveRule_nestedFunction();
		}
		DebugLocation(192, 121);
		} finally { DebugExitRule(GrammarFileName, "nestedFunction"); }
		return retval;

	}
	// $ANTLR end "nestedFunction"

	partial void EnterRule_classFile();
	partial void LeaveRule_classFile();
	// $ANTLR start "classFile"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:196:1: classFile : ( EOL )* class ( EOL )* ( closeFunctions ( EOL )* )? EOF -> ^( CLASSFILE[\"\"] class ( closeFunctions )? ) ;
	[GrammarRule("classFile")]
	private AstParserRuleReturnScope<object, IToken> classFile()
	{
		EnterRule_classFile();
		EnterRule("classFile", 31);
		TraceIn("classFile", 31);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOL74 = default(IToken);
		IToken EOL76 = default(IToken);
		IToken EOL78 = default(IToken);
		IToken EOF79 = default(IToken);
		AstParserRuleReturnScope<object, IToken> class75 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> closeFunctions77 = default(AstParserRuleReturnScope<object, IToken>);

		object EOL74_tree = default(object);
		object EOL76_tree = default(object);
		object EOL78_tree = default(object);
		object EOF79_tree = default(object);
		RewriteRuleITokenStream stream_EOL=new RewriteRuleITokenStream(adaptor,"token EOL");
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_class=new RewriteRuleSubtreeStream(adaptor,"rule class");
		RewriteRuleSubtreeStream stream_closeFunctions=new RewriteRuleSubtreeStream(adaptor,"rule closeFunctions");
		try { DebugEnterRule(GrammarFileName, "classFile");
		DebugLocation(196, 105);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:196:11: ( ( EOL )* class ( EOL )* ( closeFunctions ( EOL )* )? EOF -> ^( CLASSFILE[\"\"] class ( closeFunctions )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:196:13: ( EOL )* class ( EOL )* ( closeFunctions ( EOL )* )? EOF
			{
			DebugLocation(196, 13);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:196:13: ( EOL )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_1 = input.LA(1);

				if ((LA26_1==EOL))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:196:14: EOL
					{
					DebugLocation(196, 14);
					EOL74=(IToken)Match(input,EOL,Follow._EOL_in_classFile1097); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_EOL.Add(EOL74);


					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }

			DebugLocation(196, 20);
			PushFollow(Follow._class_in_classFile1101);
			class75=@class();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_class.Add(class75.Tree);
			DebugLocation(196, 26);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:196:26: ( EOL )*
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				int LA27_1 = input.LA(1);

				if ((LA27_1==EOL))
				{
					alt27 = 1;
				}


				} finally { DebugExitDecision(27); }
				switch ( alt27 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:196:27: EOL
					{
					DebugLocation(196, 27);
					EOL76=(IToken)Match(input,EOL,Follow._EOL_in_classFile1104); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_EOL.Add(EOL76);


					}
					break;

				default:
					goto loop27;
				}
			}

			loop27:
				;

			} finally { DebugExitSubRule(27); }

			DebugLocation(196, 33);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:196:33: ( closeFunctions ( EOL )* )?
			int alt29=2;
			try { DebugEnterSubRule(29);
			try { DebugEnterDecision(29, false);
			int LA29_1 = input.LA(1);

			if ((LA29_1==FUNCTION))
			{
				alt29 = 1;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:196:34: closeFunctions ( EOL )*
				{
				DebugLocation(196, 34);
				PushFollow(Follow._closeFunctions_in_classFile1109);
				closeFunctions77=closeFunctions();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_closeFunctions.Add(closeFunctions77.Tree);
				DebugLocation(196, 49);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:196:49: ( EOL )*
				try { DebugEnterSubRule(28);
				while (true)
				{
					int alt28=2;
					try { DebugEnterDecision(28, false);
					int LA28_1 = input.LA(1);

					if ((LA28_1==EOL))
					{
						alt28 = 1;
					}


					} finally { DebugExitDecision(28); }
					switch ( alt28 )
					{
					case 1:
						DebugEnterAlt(1);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:196:50: EOL
						{
						DebugLocation(196, 50);
						EOL78=(IToken)Match(input,EOL,Follow._EOL_in_classFile1112); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_EOL.Add(EOL78);


						}
						break;

					default:
						goto loop28;
					}
				}

				loop28:
					;

				} finally { DebugExitSubRule(28); }


				}
				break;

			}
			} finally { DebugExitSubRule(29); }

			DebugLocation(196, 58);
			EOF79=(IToken)Match(input,EOF,Follow._EOF_in_classFile1118); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF79);



			{
			// AST REWRITE
			// elements: class, closeFunctions
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 196:62: -> ^( CLASSFILE[\"\"] class ( closeFunctions )? )
			{
				DebugLocation(196, 65);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:196:65: ^( CLASSFILE[\"\"] class ( closeFunctions )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(196, 67);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CLASSFILE, ""), root_1);

				DebugLocation(196, 81);
				adaptor.AddChild(root_1, stream_class.NextTree());
				DebugLocation(196, 87);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:196:87: ( closeFunctions )?
				if (stream_closeFunctions.HasNext)
				{
					DebugLocation(196, 88);
					adaptor.AddChild(root_1, stream_closeFunctions.NextTree());

				}
				stream_closeFunctions.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classFile", 31);
			LeaveRule("classFile", 31);
			LeaveRule_classFile();
		}
		DebugLocation(196, 105);
		} finally { DebugExitRule(GrammarFileName, "classFile"); }
		return retval;

	}
	// $ANTLR end "classFile"

	partial void EnterRule_class();
	partial void LeaveRule_class();
	// $ANTLR start "class"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:198:1: class : CLASSDEF ( annotationPortion )? name ( genealogyPortion )? xEOS sections END -> ^( CLASSDEF name ( genealogyPortion )? ( annotationPortion )? ( sections )? ) ;
	[GrammarRule("class")]
	private AstParserRuleReturnScope<object, IToken> @class()
	{
		EnterRule_class();
		EnterRule("class", 32);
		TraceIn("class", 32);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CLASSDEF80 = default(IToken);
		IToken END86 = default(IToken);
		AstParserRuleReturnScope<object, IToken> annotationPortion81 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> name82 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> genealogyPortion83 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS84 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> sections85 = default(AstParserRuleReturnScope<object, IToken>);

		object CLASSDEF80_tree = default(object);
		object END86_tree = default(object);
		RewriteRuleITokenStream stream_CLASSDEF=new RewriteRuleITokenStream(adaptor,"token CLASSDEF");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_annotationPortion=new RewriteRuleSubtreeStream(adaptor,"rule annotationPortion");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_genealogyPortion=new RewriteRuleSubtreeStream(adaptor,"rule genealogyPortion");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_sections=new RewriteRuleSubtreeStream(adaptor,"rule sections");
		try { DebugEnterRule(GrammarFileName, "class");
		DebugLocation(198, 154);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:198:7: ( CLASSDEF ( annotationPortion )? name ( genealogyPortion )? xEOS sections END -> ^( CLASSDEF name ( genealogyPortion )? ( annotationPortion )? ( sections )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:198:9: CLASSDEF ( annotationPortion )? name ( genealogyPortion )? xEOS sections END
			{
			DebugLocation(198, 9);
			CLASSDEF80=(IToken)Match(input,CLASSDEF,Follow._CLASSDEF_in_class1141); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CLASSDEF.Add(CLASSDEF80);

			DebugLocation(198, 18);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:198:18: ( annotationPortion )?
			int alt30=2;
			try { DebugEnterSubRule(30);
			try { DebugEnterDecision(30, false);
			int LA30_1 = input.LA(1);

			if ((LA30_1==LPAREN))
			{
				alt30 = 1;
			}
			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:198:19: annotationPortion
				{
				DebugLocation(198, 19);
				PushFollow(Follow._annotationPortion_in_class1144);
				annotationPortion81=annotationPortion();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_annotationPortion.Add(annotationPortion81.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(30); }

			DebugLocation(198, 39);
			PushFollow(Follow._name_in_class1148);
			name82=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(name82.Tree);
			DebugLocation(198, 44);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:198:44: ( genealogyPortion )?
			int alt31=2;
			try { DebugEnterSubRule(31);
			try { DebugEnterDecision(31, false);
			int LA31_1 = input.LA(1);

			if ((LA31_1==LT))
			{
				alt31 = 1;
			}
			} finally { DebugExitDecision(31); }
			switch (alt31)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:198:45: genealogyPortion
				{
				DebugLocation(198, 45);
				PushFollow(Follow._genealogyPortion_in_class1151);
				genealogyPortion83=genealogyPortion();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_genealogyPortion.Add(genealogyPortion83.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(31); }

			DebugLocation(198, 64);
			PushFollow(Follow._xEOS_in_class1155);
			xEOS84=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS84.Tree);
			DebugLocation(198, 69);
			PushFollow(Follow._sections_in_class1157);
			sections85=sections();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_sections.Add(sections85.Tree);
			DebugLocation(198, 78);
			END86=(IToken)Match(input,END,Follow._END_in_class1159); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END86);



			{
			// AST REWRITE
			// elements: CLASSDEF, name, genealogyPortion, annotationPortion, sections
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 198:82: -> ^( CLASSDEF name ( genealogyPortion )? ( annotationPortion )? ( sections )? )
			{
				DebugLocation(198, 85);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:198:85: ^( CLASSDEF name ( genealogyPortion )? ( annotationPortion )? ( sections )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(198, 87);
				root_1 = (object)adaptor.BecomeRoot(stream_CLASSDEF.NextNode(), root_1);

				DebugLocation(198, 96);
				adaptor.AddChild(root_1, stream_name.NextTree());
				DebugLocation(198, 101);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:198:101: ( genealogyPortion )?
				if (stream_genealogyPortion.HasNext)
				{
					DebugLocation(198, 102);
					adaptor.AddChild(root_1, stream_genealogyPortion.NextTree());

				}
				stream_genealogyPortion.Reset();
				DebugLocation(198, 121);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:198:121: ( annotationPortion )?
				if (stream_annotationPortion.HasNext)
				{
					DebugLocation(198, 122);
					adaptor.AddChild(root_1, stream_annotationPortion.NextTree());

				}
				stream_annotationPortion.Reset();
				DebugLocation(198, 142);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:198:142: ( sections )?
				if (stream_sections.HasNext)
				{
					DebugLocation(198, 143);
					adaptor.AddChild(root_1, stream_sections.NextTree());

				}
				stream_sections.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("class", 32);
			LeaveRule("class", 32);
			LeaveRule_class();
		}
		DebugLocation(198, 154);
		} finally { DebugExitRule(GrammarFileName, "class"); }
		return retval;

	}
	// $ANTLR end "class"

	partial void EnterRule_annotationPortion();
	partial void LeaveRule_annotationPortion();
	// $ANTLR start "annotationPortion"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:200:1: annotationPortion : LPAREN attributes RPAREN -> attributes ;
	[GrammarRule("annotationPortion")]
	private AstParserRuleReturnScope<object, IToken> annotationPortion()
	{
		EnterRule_annotationPortion();
		EnterRule("annotationPortion", 33);
		TraceIn("annotationPortion", 33);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN87 = default(IToken);
		IToken RPAREN89 = default(IToken);
		AstParserRuleReturnScope<object, IToken> attributes88 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN87_tree = default(object);
		object RPAREN89_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_attributes=new RewriteRuleSubtreeStream(adaptor,"rule attributes");
		try { DebugEnterRule(GrammarFileName, "annotationPortion");
		DebugLocation(200, 59);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:200:19: ( LPAREN attributes RPAREN -> attributes )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:200:21: LPAREN attributes RPAREN
			{
			DebugLocation(200, 21);
			LPAREN87=(IToken)Match(input,LPAREN,Follow._LPAREN_in_annotationPortion1191); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN87);

			DebugLocation(200, 28);
			PushFollow(Follow._attributes_in_annotationPortion1193);
			attributes88=attributes();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_attributes.Add(attributes88.Tree);
			DebugLocation(200, 39);
			RPAREN89=(IToken)Match(input,RPAREN,Follow._RPAREN_in_annotationPortion1195); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN89);



			{
			// AST REWRITE
			// elements: attributes
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 200:46: -> attributes
			{
				DebugLocation(200, 49);
				adaptor.AddChild(root_0, stream_attributes.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("annotationPortion", 33);
			LeaveRule("annotationPortion", 33);
			LeaveRule_annotationPortion();
		}
		DebugLocation(200, 59);
		} finally { DebugExitRule(GrammarFileName, "annotationPortion"); }
		return retval;

	}
	// $ANTLR end "annotationPortion"

	partial void EnterRule_attributes();
	partial void LeaveRule_attributes();
	// $ANTLR start "attributes"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:202:1: attributes : attribute ( COMMA attribute )* -> ( attribute )+ ;
	[GrammarRule("attributes")]
	private AstParserRuleReturnScope<object, IToken> attributes()
	{
		EnterRule_attributes();
		EnterRule("attributes", 34);
		TraceIn("attributes", 34);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA91 = default(IToken);
		AstParserRuleReturnScope<object, IToken> attribute90 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> attribute92 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA91_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_attribute=new RewriteRuleSubtreeStream(adaptor,"rule attribute");
		try { DebugEnterRule(GrammarFileName, "attributes");
		DebugLocation(202, 58);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:202:12: ( attribute ( COMMA attribute )* -> ( attribute )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:202:14: attribute ( COMMA attribute )*
			{
			DebugLocation(202, 14);
			PushFollow(Follow._attribute_in_attributes1208);
			attribute90=attribute();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_attribute.Add(attribute90.Tree);
			DebugLocation(202, 24);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:202:24: ( COMMA attribute )*
			try { DebugEnterSubRule(32);
			while (true)
			{
				int alt32=2;
				try { DebugEnterDecision(32, false);
				int LA32_1 = input.LA(1);

				if ((LA32_1==COMMA))
				{
					alt32 = 1;
				}


				} finally { DebugExitDecision(32); }
				switch ( alt32 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:202:25: COMMA attribute
					{
					DebugLocation(202, 25);
					COMMA91=(IToken)Match(input,COMMA,Follow._COMMA_in_attributes1211); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA91);

					DebugLocation(202, 31);
					PushFollow(Follow._attribute_in_attributes1213);
					attribute92=attribute();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_attribute.Add(attribute92.Tree);

					}
					break;

				default:
					goto loop32;
				}
			}

			loop32:
				;

			} finally { DebugExitSubRule(32); }



			{
			// AST REWRITE
			// elements: attribute
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 202:43: -> ( attribute )+
			{
				DebugLocation(202, 46);
				if (!(stream_attribute.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_attribute.HasNext )
				{
					DebugLocation(202, 47);
					adaptor.AddChild(root_0, stream_attribute.NextTree());

				}
				stream_attribute.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("attributes", 34);
			LeaveRule("attributes", 34);
			LeaveRule_attributes();
		}
		DebugLocation(202, 58);
		} finally { DebugExitRule(GrammarFileName, "attributes"); }
		return retval;

	}
	// $ANTLR end "attributes"

	partial void EnterRule_attribute();
	partial void LeaveRule_attribute();
	// $ANTLR start "attribute"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:204:1: attribute : ( NOT name -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"false\"] ) ) ) ) | name -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"true\"] ) ) ) ) | name ASSIGN expression -> ^( ATTRIBUTE[\"\"] name expression ) );
	[GrammarRule("attribute")]
	private AstParserRuleReturnScope<object, IToken> attribute()
	{
		EnterRule_attribute();
		EnterRule("attribute", 35);
		TraceIn("attribute", 35);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NOT93 = default(IToken);
		IToken ASSIGN97 = default(IToken);
		AstParserRuleReturnScope<object, IToken> name94 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> name95 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> name96 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression98 = default(AstParserRuleReturnScope<object, IToken>);

		object NOT93_tree = default(object);
		object ASSIGN97_tree = default(object);
		RewriteRuleITokenStream stream_NOT=new RewriteRuleITokenStream(adaptor,"token NOT");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "attribute");
		DebugLocation(204, 4);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:204:11: ( NOT name -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"false\"] ) ) ) ) | name -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"true\"] ) ) ) ) | name ASSIGN expression -> ^( ATTRIBUTE[\"\"] name expression ) )
			int alt33=3;
			try { DebugEnterDecision(33, false);
			int LA33_1 = input.LA(1);

			if ((LA33_1==NOT))
			{
				alt33 = 1;
			}
			else if ((LA33_1==ID))
			{
				int LA33_2 = input.LA(2);

				if ((LA33_2==COMMA||LA33_2==RPAREN))
				{
					alt33 = 2;
				}
				else if ((LA33_2==ASSIGN))
				{
					alt33 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 33, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 33, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(33); }
			switch (alt33)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:204:13: NOT name
				{
				DebugLocation(204, 13);
				NOT93=(IToken)Match(input,NOT,Follow._NOT_in_attribute1231); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NOT.Add(NOT93);

				DebugLocation(204, 17);
				PushFollow(Follow._name_in_attribute1233);
				name94=name();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name.Add(name94.Tree);


				{
				// AST REWRITE
				// elements: name
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 204:22: -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"false\"] ) ) ) )
				{
					DebugLocation(204, 25);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:204:25: ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"false\"] ) ) ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(204, 27);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ATTRIBUTE, ""), root_1);

					DebugLocation(204, 41);
					adaptor.AddChild(root_1, stream_name.NextTree());
					DebugLocation(204, 46);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:204:46: ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"false\"] ) ) )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(204, 48);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, ""), root_2);

					DebugLocation(204, 56);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:204:56: ^( NAME[\"\"] ^( ID[\"false\"] ) )
					{
					object root_3 = (object)adaptor.Nil();
					DebugLocation(204, 58);
					root_3 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAME, ""), root_3);

					DebugLocation(204, 67);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:204:67: ^( ID[\"false\"] )
					{
					object root_4 = (object)adaptor.Nil();
					DebugLocation(204, 69);
					root_4 = (object)adaptor.BecomeRoot((object)adaptor.Create(ID, "false"), root_4);

					adaptor.AddChild(root_3, root_4);
					}

					adaptor.AddChild(root_2, root_3);
					}

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:205:7: name
				{
				DebugLocation(205, 7);
				PushFollow(Follow._name_in_attribute1266);
				name95=name();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name.Add(name95.Tree);


				{
				// AST REWRITE
				// elements: name
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 205:12: -> ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"true\"] ) ) ) )
				{
					DebugLocation(205, 15);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:205:15: ^( ATTRIBUTE[\"\"] name ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"true\"] ) ) ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(205, 17);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ATTRIBUTE, ""), root_1);

					DebugLocation(205, 31);
					adaptor.AddChild(root_1, stream_name.NextTree());
					DebugLocation(205, 36);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:205:36: ^( VAR[\"\"] ^( NAME[\"\"] ^( ID[\"true\"] ) ) )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(205, 38);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, ""), root_2);

					DebugLocation(205, 46);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:205:46: ^( NAME[\"\"] ^( ID[\"true\"] ) )
					{
					object root_3 = (object)adaptor.Nil();
					DebugLocation(205, 48);
					root_3 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAME, ""), root_3);

					DebugLocation(205, 57);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:205:57: ^( ID[\"true\"] )
					{
					object root_4 = (object)adaptor.Nil();
					DebugLocation(205, 59);
					root_4 = (object)adaptor.BecomeRoot((object)adaptor.Create(ID, "true"), root_4);

					adaptor.AddChild(root_3, root_4);
					}

					adaptor.AddChild(root_2, root_3);
					}

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:206:13: name ASSIGN expression
				{
				DebugLocation(206, 13);
				PushFollow(Follow._name_in_attribute1305);
				name96=name();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_name.Add(name96.Tree);
				DebugLocation(206, 18);
				ASSIGN97=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_attribute1307); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN97);

				DebugLocation(206, 25);
				PushFollow(Follow._expression_in_attribute1309);
				expression98=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression98.Tree);


				{
				// AST REWRITE
				// elements: name, expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 206:36: -> ^( ATTRIBUTE[\"\"] name expression )
				{
					DebugLocation(206, 39);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:206:39: ^( ATTRIBUTE[\"\"] name expression )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(206, 41);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ATTRIBUTE, ""), root_1);

					DebugLocation(206, 55);
					adaptor.AddChild(root_1, stream_name.NextTree());
					DebugLocation(206, 60);
					adaptor.AddChild(root_1, stream_expression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("attribute", 35);
			LeaveRule("attribute", 35);
			LeaveRule_attribute();
		}
		DebugLocation(207, 4);
		} finally { DebugExitRule(GrammarFileName, "attribute"); }
		return retval;

	}
	// $ANTLR end "attribute"

	partial void EnterRule_genealogyPortion();
	partial void LeaveRule_genealogyPortion();
	// $ANTLR start "genealogyPortion"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:209:1: genealogyPortion : LT baseClasses -> baseClasses ;
	[GrammarRule("genealogyPortion")]
	private AstParserRuleReturnScope<object, IToken> genealogyPortion()
	{
		EnterRule_genealogyPortion();
		EnterRule("genealogyPortion", 36);
		TraceIn("genealogyPortion", 36);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LT99 = default(IToken);
		AstParserRuleReturnScope<object, IToken> baseClasses100 = default(AstParserRuleReturnScope<object, IToken>);

		object LT99_tree = default(object);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_baseClasses=new RewriteRuleSubtreeStream(adaptor,"rule baseClasses");
		try { DebugEnterRule(GrammarFileName, "genealogyPortion");
		DebugLocation(209, 49);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:209:18: ( LT baseClasses -> baseClasses )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:209:20: LT baseClasses
			{
			DebugLocation(209, 20);
			LT99=(IToken)Match(input,LT,Follow._LT_in_genealogyPortion1334); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LT.Add(LT99);

			DebugLocation(209, 23);
			PushFollow(Follow._baseClasses_in_genealogyPortion1336);
			baseClasses100=baseClasses();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_baseClasses.Add(baseClasses100.Tree);


			{
			// AST REWRITE
			// elements: baseClasses
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 209:35: -> baseClasses
			{
				DebugLocation(209, 38);
				adaptor.AddChild(root_0, stream_baseClasses.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("genealogyPortion", 36);
			LeaveRule("genealogyPortion", 36);
			LeaveRule_genealogyPortion();
		}
		DebugLocation(209, 49);
		} finally { DebugExitRule(GrammarFileName, "genealogyPortion"); }
		return retval;

	}
	// $ANTLR end "genealogyPortion"

	partial void EnterRule_baseClasses();
	partial void LeaveRule_baseClasses();
	// $ANTLR start "baseClasses"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:211:1: baseClasses : classReference ( AND classReference )* -> ( classReference )+ ;
	[GrammarRule("baseClasses")]
	private AstParserRuleReturnScope<object, IToken> baseClasses()
	{
		EnterRule_baseClasses();
		EnterRule("baseClasses", 37);
		TraceIn("baseClasses", 37);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AND102 = default(IToken);
		AstParserRuleReturnScope<object, IToken> classReference101 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> classReference103 = default(AstParserRuleReturnScope<object, IToken>);

		object AND102_tree = default(object);
		RewriteRuleITokenStream stream_AND=new RewriteRuleITokenStream(adaptor,"token AND");
		RewriteRuleSubtreeStream stream_classReference=new RewriteRuleSubtreeStream(adaptor,"rule classReference");
		try { DebugEnterRule(GrammarFileName, "baseClasses");
		DebugLocation(211, 72);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:211:13: ( classReference ( AND classReference )* -> ( classReference )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:211:15: classReference ( AND classReference )*
			{
			DebugLocation(211, 15);
			PushFollow(Follow._classReference_in_baseClasses1349);
			classReference101=classReference();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_classReference.Add(classReference101.Tree);
			DebugLocation(211, 30);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:211:30: ( AND classReference )*
			try { DebugEnterSubRule(34);
			while (true)
			{
				int alt34=2;
				try { DebugEnterDecision(34, false);
				int LA34_1 = input.LA(1);

				if ((LA34_1==AND))
				{
					alt34 = 1;
				}


				} finally { DebugExitDecision(34); }
				switch ( alt34 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:211:31: AND classReference
					{
					DebugLocation(211, 31);
					AND102=(IToken)Match(input,AND,Follow._AND_in_baseClasses1352); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_AND.Add(AND102);

					DebugLocation(211, 35);
					PushFollow(Follow._classReference_in_baseClasses1354);
					classReference103=classReference();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_classReference.Add(classReference103.Tree);

					}
					break;

				default:
					goto loop34;
				}
			}

			loop34:
				;

			} finally { DebugExitSubRule(34); }



			{
			// AST REWRITE
			// elements: classReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 211:52: -> ( classReference )+
			{
				DebugLocation(211, 55);
				if (!(stream_classReference.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_classReference.HasNext )
				{
					DebugLocation(211, 56);
					adaptor.AddChild(root_0, stream_classReference.NextTree());

				}
				stream_classReference.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("baseClasses", 37);
			LeaveRule("baseClasses", 37);
			LeaveRule_baseClasses();
		}
		DebugLocation(211, 72);
		} finally { DebugExitRule(GrammarFileName, "baseClasses"); }
		return retval;

	}
	// $ANTLR end "baseClasses"

	partial void EnterRule_classReference();
	partial void LeaveRule_classReference();
	// $ANTLR start "classReference"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:213:1: classReference : fullClassName -> ^( CLASSREF[\"\"] fullClassName ) ;
	[GrammarRule("classReference")]
	private AstParserRuleReturnScope<object, IToken> classReference()
	{
		EnterRule_classReference();
		EnterRule("classReference", 38);
		TraceIn("classReference", 38);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> fullClassName104 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_fullClassName=new RewriteRuleSubtreeStream(adaptor,"rule fullClassName");
		try { DebugEnterRule(GrammarFileName, "classReference");
		DebugLocation(213, 64);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:213:16: ( fullClassName -> ^( CLASSREF[\"\"] fullClassName ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:213:18: fullClassName
			{
			DebugLocation(213, 18);
			PushFollow(Follow._fullClassName_in_classReference1372);
			fullClassName104=fullClassName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_fullClassName.Add(fullClassName104.Tree);


			{
			// AST REWRITE
			// elements: fullClassName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 213:32: -> ^( CLASSREF[\"\"] fullClassName )
			{
				DebugLocation(213, 35);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:213:35: ^( CLASSREF[\"\"] fullClassName )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(213, 37);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CLASSREF, ""), root_1);

				DebugLocation(213, 50);
				adaptor.AddChild(root_1, stream_fullClassName.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classReference", 38);
			LeaveRule("classReference", 38);
			LeaveRule_classReference();
		}
		DebugLocation(213, 64);
		} finally { DebugExitRule(GrammarFileName, "classReference"); }
		return retval;

	}
	// $ANTLR end "classReference"

	partial void EnterRule_fullClassName();
	partial void LeaveRule_fullClassName();
	// $ANTLR start "fullClassName"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:215:1: fullClassName : xID ({...}? => DOT xANYID )* -> ^( NAME[\"\"] xID ( xANYID )* ) ;
	[GrammarRule("fullClassName")]
	private AstParserRuleReturnScope<object, IToken> fullClassName()
	{
		EnterRule_fullClassName();
		EnterRule("fullClassName", 39);
		TraceIn("fullClassName", 39);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DOT106 = default(IToken);
		AstParserRuleReturnScope<object, IToken> xID105 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xANYID107 = default(AstParserRuleReturnScope<object, IToken>);

		object DOT106_tree = default(object);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_xID=new RewriteRuleSubtreeStream(adaptor,"rule xID");
		RewriteRuleSubtreeStream stream_xANYID=new RewriteRuleSubtreeStream(adaptor,"rule xANYID");
		try { DebugEnterRule(GrammarFileName, "fullClassName");
		DebugLocation(215, 73);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:215:15: ( xID ({...}? => DOT xANYID )* -> ^( NAME[\"\"] xID ( xANYID )* ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:215:17: xID ({...}? => DOT xANYID )*
			{
			DebugLocation(215, 17);
			PushFollow(Follow._xID_in_fullClassName1390);
			xID105=xID();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xID.Add(xID105.Tree);
			DebugLocation(215, 21);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:215:21: ({...}? => DOT xANYID )*
			try { DebugEnterSubRule(35);
			while (true)
			{
				int alt35=2;
				try { DebugEnterDecision(35, false);
				int LA35_1 = input.LA(1);

				if ((LA35_1==DOT) && (((Chain_MayAddDotExpression())||(Chain_MayAddDotName())||(true))))
				{
					int LA35_2 = input.LA(2);

					if ((LA35_2==ID) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==BREAK) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==CASE) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==CATCH) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==CLASSDEF) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==CONTINUE) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==ELSE) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==ELSEIF) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==END) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==FOR) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==FUNCTION) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==GLOBAL) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==IF) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==OTHERWISE) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==PARFOR) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==PERSISTENT) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==RETURN) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==SPMD) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==SWITCH) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==TRY) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}
					else if ((LA35_2==WHILE) && (((Chain_MayAddDotName())||(true))))
					{
						int LA35_3 = input.LA(3);

						if (((true)))
						{
							alt35 = 1;
						}


					}


				}


				} finally { DebugExitDecision(35); }
				switch ( alt35 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:215:22: {...}? => DOT xANYID
					{
					DebugLocation(215, 22);
					if (!((true)))
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "fullClassName", "true");
					}
					DebugLocation(215, 32);
					DOT106=(IToken)Match(input,DOT,Follow._DOT_in_fullClassName1396); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_DOT.Add(DOT106);

					DebugLocation(215, 36);
					PushFollow(Follow._xANYID_in_fullClassName1398);
					xANYID107=xANYID();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_xANYID.Add(xANYID107.Tree);

					}
					break;

				default:
					goto loop35;
				}
			}

			loop35:
				;

			} finally { DebugExitSubRule(35); }



			{
			// AST REWRITE
			// elements: xID, xANYID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 215:45: -> ^( NAME[\"\"] xID ( xANYID )* )
			{
				DebugLocation(215, 48);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:215:48: ^( NAME[\"\"] xID ( xANYID )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(215, 50);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAME, ""), root_1);

				DebugLocation(215, 59);
				adaptor.AddChild(root_1, stream_xID.NextTree());
				DebugLocation(215, 63);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:215:63: ( xANYID )*
				while ( stream_xANYID.HasNext )
				{
					DebugLocation(215, 64);
					adaptor.AddChild(root_1, stream_xANYID.NextTree());

				}
				stream_xANYID.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fullClassName", 39);
			LeaveRule("fullClassName", 39);
			LeaveRule_fullClassName();
		}
		DebugLocation(215, 73);
		} finally { DebugExitRule(GrammarFileName, "fullClassName"); }
		return retval;

	}
	// $ANTLR end "fullClassName"

	partial void EnterRule_sections();
	partial void LeaveRule_sections();
	// $ANTLR start "sections"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:217:1: sections : ( section | xEOS )* -> ( section )* ;
	[GrammarRule("sections")]
	private AstParserRuleReturnScope<object, IToken> sections()
	{
		EnterRule_sections();
		EnterRule("sections", 40);
		TraceIn("sections", 40);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> section108 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS109 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_section=new RewriteRuleSubtreeStream(adaptor,"rule section");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "sections");
		DebugLocation(217, 43);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:217:10: ( ( section | xEOS )* -> ( section )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:217:12: ( section | xEOS )*
			{
			DebugLocation(217, 12);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:217:12: ( section | xEOS )*
			try { DebugEnterSubRule(36);
			while (true)
			{
				int alt36=3;
				try { DebugEnterDecision(36, false);
				int LA36_1 = input.LA(1);

				if ((LA36_1==ID) && (((Keyword_EventsIdFollows())||(Keyword_PropertiesIdFollows())||(Keyword_MethodsIdFollows())||(Keyword_EnumerationIdFollows()))))
				{
					alt36 = 1;
				}
				else if ((LA36_1==COMMA||LA36_1==EOL||LA36_1==SEMICOLON))
				{
					alt36 = 2;
				}


				} finally { DebugExitDecision(36); }
				switch ( alt36 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:217:13: section
					{
					DebugLocation(217, 13);
					PushFollow(Follow._section_in_sections1424);
					section108=section();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_section.Add(section108.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:217:23: xEOS
					{
					DebugLocation(217, 23);
					PushFollow(Follow._xEOS_in_sections1428);
					xEOS109=xEOS();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_xEOS.Add(xEOS109.Tree);

					}
					break;

				default:
					goto loop36;
				}
			}

			loop36:
				;

			} finally { DebugExitSubRule(36); }



			{
			// AST REWRITE
			// elements: section
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 217:30: -> ( section )*
			{
				DebugLocation(217, 33);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:217:33: ( section )*
				while ( stream_section.HasNext )
				{
					DebugLocation(217, 34);
					adaptor.AddChild(root_0, stream_section.NextTree());

				}
				stream_section.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sections", 40);
			LeaveRule("sections", 40);
			LeaveRule_sections();
		}
		DebugLocation(217, 43);
		} finally { DebugExitRule(GrammarFileName, "sections"); }
		return retval;

	}
	// $ANTLR end "sections"

	partial void EnterRule_section();
	partial void LeaveRule_section();
	// $ANTLR start "section"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:219:1: section : ( eventSection -> eventSection | propertySection -> propertySection | methodSection -> methodSection | enumerationSection -> enumerationSection );
	[GrammarRule("section")]
	private AstParserRuleReturnScope<object, IToken> section()
	{
		EnterRule_section();
		EnterRule("section", 41);
		TraceIn("section", 41);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> eventSection110 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> propertySection111 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> methodSection112 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enumerationSection113 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_eventSection=new RewriteRuleSubtreeStream(adaptor,"rule eventSection");
		RewriteRuleSubtreeStream stream_propertySection=new RewriteRuleSubtreeStream(adaptor,"rule propertySection");
		RewriteRuleSubtreeStream stream_methodSection=new RewriteRuleSubtreeStream(adaptor,"rule methodSection");
		RewriteRuleSubtreeStream stream_enumerationSection=new RewriteRuleSubtreeStream(adaptor,"rule enumerationSection");
		try { DebugEnterRule(GrammarFileName, "section");
		DebugLocation(219, 2);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:219:9: ( eventSection -> eventSection | propertySection -> propertySection | methodSection -> methodSection | enumerationSection -> enumerationSection )
			int alt37=4;
			try { DebugEnterDecision(37, false);
			int LA37_1 = input.LA(1);

			if ((LA37_1==ID) && (((Keyword_EventsIdFollows())||(Keyword_PropertiesIdFollows())||(Keyword_MethodsIdFollows())||(Keyword_EnumerationIdFollows()))))
			{
				int LA37_2 = input.LA(2);

				if (((Keyword_EventsIdFollows())))
				{
					alt37 = 1;
				}
				else if (((Keyword_PropertiesIdFollows())))
				{
					alt37 = 2;
				}
				else if (((Keyword_MethodsIdFollows())))
				{
					alt37 = 3;
				}
				else if (((Keyword_EnumerationIdFollows())))
				{
					alt37 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 37, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 37, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(37); }
			switch (alt37)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:219:11: eventSection
				{
				DebugLocation(219, 11);
				PushFollow(Follow._eventSection_in_section1446);
				eventSection110=eventSection();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_eventSection.Add(eventSection110.Tree);


				{
				// AST REWRITE
				// elements: eventSection
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 219:24: -> eventSection
				{
					DebugLocation(219, 27);
					adaptor.AddChild(root_0, stream_eventSection.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:220:5: propertySection
				{
				DebugLocation(220, 5);
				PushFollow(Follow._propertySection_in_section1458);
				propertySection111=propertySection();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_propertySection.Add(propertySection111.Tree);


				{
				// AST REWRITE
				// elements: propertySection
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 220:21: -> propertySection
				{
					DebugLocation(220, 24);
					adaptor.AddChild(root_0, stream_propertySection.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:221:5: methodSection
				{
				DebugLocation(221, 5);
				PushFollow(Follow._methodSection_in_section1470);
				methodSection112=methodSection();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_methodSection.Add(methodSection112.Tree);


				{
				// AST REWRITE
				// elements: methodSection
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 221:19: -> methodSection
				{
					DebugLocation(221, 22);
					adaptor.AddChild(root_0, stream_methodSection.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:222:5: enumerationSection
				{
				DebugLocation(222, 5);
				PushFollow(Follow._enumerationSection_in_section1481);
				enumerationSection113=enumerationSection();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_enumerationSection.Add(enumerationSection113.Tree);


				{
				// AST REWRITE
				// elements: enumerationSection
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 222:24: -> enumerationSection
				{
					DebugLocation(222, 27);
					adaptor.AddChild(root_0, stream_enumerationSection.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("section", 41);
			LeaveRule("section", 41);
			LeaveRule_section();
		}
		DebugLocation(223, 2);
		} finally { DebugExitRule(GrammarFileName, "section"); }
		return retval;

	}
	// $ANTLR end "section"

	partial void EnterRule_eventSection();
	partial void LeaveRule_eventSection();
	// $ANTLR start "eventSection"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:227:1: eventSection : xEVENTS ( annotationPortion )? events END -> ^( EVENTSECTION[$xEVENTS.start] ( annotationPortion )? ( events )? ) ;
	[GrammarRule("eventSection")]
	private AstParserRuleReturnScope<object, IToken> eventSection()
	{
		EnterRule_eventSection();
		EnterRule("eventSection", 42);
		TraceIn("eventSection", 42);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken END117 = default(IToken);
		AstParserRuleReturnScope<object, IToken> xEVENTS114 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> annotationPortion115 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> events116 = default(AstParserRuleReturnScope<object, IToken>);

		object END117_tree = default(object);
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xEVENTS=new RewriteRuleSubtreeStream(adaptor,"rule xEVENTS");
		RewriteRuleSubtreeStream stream_annotationPortion=new RewriteRuleSubtreeStream(adaptor,"rule annotationPortion");
		RewriteRuleSubtreeStream stream_events=new RewriteRuleSubtreeStream(adaptor,"rule events");
		try { DebugEnterRule(GrammarFileName, "eventSection");
		DebugLocation(227, 121);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:227:14: ( xEVENTS ( annotationPortion )? events END -> ^( EVENTSECTION[$xEVENTS.start] ( annotationPortion )? ( events )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:227:16: xEVENTS ( annotationPortion )? events END
			{
			DebugLocation(227, 16);
			PushFollow(Follow._xEVENTS_in_eventSection1499);
			xEVENTS114=xEVENTS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEVENTS.Add(xEVENTS114.Tree);
			DebugLocation(227, 24);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:227:24: ( annotationPortion )?
			int alt38=2;
			try { DebugEnterSubRule(38);
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1==LPAREN))
			{
				alt38 = 1;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:227:25: annotationPortion
				{
				DebugLocation(227, 25);
				PushFollow(Follow._annotationPortion_in_eventSection1502);
				annotationPortion115=annotationPortion();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_annotationPortion.Add(annotationPortion115.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(38); }

			DebugLocation(227, 45);
			PushFollow(Follow._events_in_eventSection1506);
			events116=events();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_events.Add(events116.Tree);
			DebugLocation(227, 52);
			END117=(IToken)Match(input,END,Follow._END_in_eventSection1508); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END117);



			{
			// AST REWRITE
			// elements: annotationPortion, events
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 227:56: -> ^( EVENTSECTION[$xEVENTS.start] ( annotationPortion )? ( events )? )
			{
				DebugLocation(227, 59);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:227:59: ^( EVENTSECTION[$xEVENTS.start] ( annotationPortion )? ( events )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(227, 61);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EVENTSECTION, (xEVENTS114!=null?((IToken)xEVENTS114.Start):default(IToken))), root_1);

				DebugLocation(227, 90);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:227:90: ( annotationPortion )?
				if (stream_annotationPortion.HasNext)
				{
					DebugLocation(227, 91);
					adaptor.AddChild(root_1, stream_annotationPortion.NextTree());

				}
				stream_annotationPortion.Reset();
				DebugLocation(227, 111);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:227:111: ( events )?
				if (stream_events.HasNext)
				{
					DebugLocation(227, 112);
					adaptor.AddChild(root_1, stream_events.NextTree());

				}
				stream_events.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("eventSection", 42);
			LeaveRule("eventSection", 42);
			LeaveRule_eventSection();
		}
		DebugLocation(227, 121);
		} finally { DebugExitRule(GrammarFileName, "eventSection"); }
		return retval;

	}
	// $ANTLR end "eventSection"

	partial void EnterRule_events();
	partial void LeaveRule_events();
	// $ANTLR start "events"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:229:1: events : ( event | xEOS )* -> ( event )* ;
	[GrammarRule("events")]
	private AstParserRuleReturnScope<object, IToken> events()
	{
		EnterRule_events();
		EnterRule("events", 43);
		TraceIn("events", 43);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> event118 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS119 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_event=new RewriteRuleSubtreeStream(adaptor,"rule event");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "events");
		DebugLocation(229, 37);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:229:8: ( ( event | xEOS )* -> ( event )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:229:10: ( event | xEOS )*
			{
			DebugLocation(229, 10);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:229:10: ( event | xEOS )*
			try { DebugEnterSubRule(39);
			while (true)
			{
				int alt39=3;
				try { DebugEnterDecision(39, false);
				int LA39_1 = input.LA(1);

				if ((LA39_1==ID))
				{
					alt39 = 1;
				}
				else if ((LA39_1==COMMA||LA39_1==EOL||LA39_1==SEMICOLON))
				{
					alt39 = 2;
				}


				} finally { DebugExitDecision(39); }
				switch ( alt39 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:229:11: event
					{
					DebugLocation(229, 11);
					PushFollow(Follow._event_in_events1535);
					event118=@event();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_event.Add(event118.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:229:19: xEOS
					{
					DebugLocation(229, 19);
					PushFollow(Follow._xEOS_in_events1539);
					xEOS119=xEOS();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_xEOS.Add(xEOS119.Tree);

					}
					break;

				default:
					goto loop39;
				}
			}

			loop39:
				;

			} finally { DebugExitSubRule(39); }



			{
			// AST REWRITE
			// elements: event
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 229:26: -> ( event )*
			{
				DebugLocation(229, 29);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:229:29: ( event )*
				while ( stream_event.HasNext )
				{
					DebugLocation(229, 30);
					adaptor.AddChild(root_0, stream_event.NextTree());

				}
				stream_event.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("events", 43);
			LeaveRule("events", 43);
			LeaveRule_events();
		}
		DebugLocation(229, 37);
		} finally { DebugExitRule(GrammarFileName, "events"); }
		return retval;

	}
	// $ANTLR end "events"

	partial void EnterRule_event();
	partial void LeaveRule_event();
	// $ANTLR start "event"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:231:1: event : name xEOS -> ^( EVENT[\"\"] name ) ;
	[GrammarRule("event")]
	private AstParserRuleReturnScope<object, IToken> @event()
	{
		EnterRule_event();
		EnterRule("event", 44);
		TraceIn("event", 44);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> name120 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS121 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "event");
		DebugLocation(231, 39);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:231:7: ( name xEOS -> ^( EVENT[\"\"] name ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:231:9: name xEOS
			{
			DebugLocation(231, 9);
			PushFollow(Follow._name_in_event1557);
			name120=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(name120.Tree);
			DebugLocation(231, 14);
			PushFollow(Follow._xEOS_in_event1559);
			xEOS121=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS121.Tree);


			{
			// AST REWRITE
			// elements: name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 231:19: -> ^( EVENT[\"\"] name )
			{
				DebugLocation(231, 22);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:231:22: ^( EVENT[\"\"] name )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(231, 24);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EVENT, ""), root_1);

				DebugLocation(231, 34);
				adaptor.AddChild(root_1, stream_name.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("event", 44);
			LeaveRule("event", 44);
			LeaveRule_event();
		}
		DebugLocation(231, 39);
		} finally { DebugExitRule(GrammarFileName, "event"); }
		return retval;

	}
	// $ANTLR end "event"

	partial void EnterRule_propertySection();
	partial void LeaveRule_propertySection();
	// $ANTLR start "propertySection"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:235:1: propertySection : xPROPERTIES ( annotationPortion )? properties END -> ^( PROPERTYSECTION[$xPROPERTIES.start] ( annotationPortion )? ( properties )? ) ;
	[GrammarRule("propertySection")]
	private AstParserRuleReturnScope<object, IToken> propertySection()
	{
		EnterRule_propertySection();
		EnterRule("propertySection", 45);
		TraceIn("propertySection", 45);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken END125 = default(IToken);
		AstParserRuleReturnScope<object, IToken> xPROPERTIES122 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> annotationPortion123 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> properties124 = default(AstParserRuleReturnScope<object, IToken>);

		object END125_tree = default(object);
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xPROPERTIES=new RewriteRuleSubtreeStream(adaptor,"rule xPROPERTIES");
		RewriteRuleSubtreeStream stream_annotationPortion=new RewriteRuleSubtreeStream(adaptor,"rule annotationPortion");
		RewriteRuleSubtreeStream stream_properties=new RewriteRuleSubtreeStream(adaptor,"rule properties");
		try { DebugEnterRule(GrammarFileName, "propertySection");
		DebugLocation(235, 143);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:235:17: ( xPROPERTIES ( annotationPortion )? properties END -> ^( PROPERTYSECTION[$xPROPERTIES.start] ( annotationPortion )? ( properties )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:235:19: xPROPERTIES ( annotationPortion )? properties END
			{
			DebugLocation(235, 19);
			PushFollow(Follow._xPROPERTIES_in_propertySection1579);
			xPROPERTIES122=xPROPERTIES();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xPROPERTIES.Add(xPROPERTIES122.Tree);
			DebugLocation(235, 31);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:235:31: ( annotationPortion )?
			int alt40=2;
			try { DebugEnterSubRule(40);
			try { DebugEnterDecision(40, false);
			int LA40_1 = input.LA(1);

			if ((LA40_1==LPAREN))
			{
				alt40 = 1;
			}
			} finally { DebugExitDecision(40); }
			switch (alt40)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:235:32: annotationPortion
				{
				DebugLocation(235, 32);
				PushFollow(Follow._annotationPortion_in_propertySection1582);
				annotationPortion123=annotationPortion();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_annotationPortion.Add(annotationPortion123.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(40); }

			DebugLocation(235, 52);
			PushFollow(Follow._properties_in_propertySection1586);
			properties124=properties();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_properties.Add(properties124.Tree);
			DebugLocation(235, 63);
			END125=(IToken)Match(input,END,Follow._END_in_propertySection1588); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END125);



			{
			// AST REWRITE
			// elements: annotationPortion, properties
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 235:67: -> ^( PROPERTYSECTION[$xPROPERTIES.start] ( annotationPortion )? ( properties )? )
			{
				DebugLocation(235, 70);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:235:70: ^( PROPERTYSECTION[$xPROPERTIES.start] ( annotationPortion )? ( properties )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(235, 72);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROPERTYSECTION, (xPROPERTIES122!=null?((IToken)xPROPERTIES122.Start):default(IToken))), root_1);

				DebugLocation(235, 108);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:235:108: ( annotationPortion )?
				if (stream_annotationPortion.HasNext)
				{
					DebugLocation(235, 109);
					adaptor.AddChild(root_1, stream_annotationPortion.NextTree());

				}
				stream_annotationPortion.Reset();
				DebugLocation(235, 129);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:235:129: ( properties )?
				if (stream_properties.HasNext)
				{
					DebugLocation(235, 130);
					adaptor.AddChild(root_1, stream_properties.NextTree());

				}
				stream_properties.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertySection", 45);
			LeaveRule("propertySection", 45);
			LeaveRule_propertySection();
		}
		DebugLocation(235, 143);
		} finally { DebugExitRule(GrammarFileName, "propertySection"); }
		return retval;

	}
	// $ANTLR end "propertySection"

	partial void EnterRule_properties();
	partial void LeaveRule_properties();
	// $ANTLR start "properties"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:237:1: properties : ( property | xEOS )* -> ( property )* ;
	[GrammarRule("properties")]
	private AstParserRuleReturnScope<object, IToken> properties()
	{
		EnterRule_properties();
		EnterRule("properties", 46);
		TraceIn("properties", 46);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> property126 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS127 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_property=new RewriteRuleSubtreeStream(adaptor,"rule property");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "properties");
		DebugLocation(237, 47);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:237:12: ( ( property | xEOS )* -> ( property )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:237:14: ( property | xEOS )*
			{
			DebugLocation(237, 14);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:237:14: ( property | xEOS )*
			try { DebugEnterSubRule(41);
			while (true)
			{
				int alt41=3;
				try { DebugEnterDecision(41, false);
				int LA41_1 = input.LA(1);

				if ((LA41_1==ID))
				{
					alt41 = 1;
				}
				else if ((LA41_1==COMMA||LA41_1==EOL||LA41_1==SEMICOLON))
				{
					alt41 = 2;
				}


				} finally { DebugExitDecision(41); }
				switch ( alt41 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:237:15: property
					{
					DebugLocation(237, 15);
					PushFollow(Follow._property_in_properties1615);
					property126=property();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_property.Add(property126.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:237:26: xEOS
					{
					DebugLocation(237, 26);
					PushFollow(Follow._xEOS_in_properties1619);
					xEOS127=xEOS();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_xEOS.Add(xEOS127.Tree);

					}
					break;

				default:
					goto loop41;
				}
			}

			loop41:
				;

			} finally { DebugExitSubRule(41); }



			{
			// AST REWRITE
			// elements: property
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 237:33: -> ( property )*
			{
				DebugLocation(237, 36);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:237:36: ( property )*
				while ( stream_property.HasNext )
				{
					DebugLocation(237, 37);
					adaptor.AddChild(root_0, stream_property.NextTree());

				}
				stream_property.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("properties", 46);
			LeaveRule("properties", 46);
			LeaveRule_properties();
		}
		DebugLocation(237, 47);
		} finally { DebugExitRule(GrammarFileName, "properties"); }
		return retval;

	}
	// $ANTLR end "properties"

	partial void EnterRule_property();
	partial void LeaveRule_property();
	// $ANTLR start "property"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:239:1: property : name ( filter )? ( ASSIGN expression )? -> ^( PROPERTY[\"\"] name ( filter )? ( expression )? ) ;
	[GrammarRule("property")]
	private AstParserRuleReturnScope<object, IToken> property()
	{
		EnterRule_property();
		EnterRule("property", 47);
		TraceIn("property", 47);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ASSIGN130 = default(IToken);
		AstParserRuleReturnScope<object, IToken> name128 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> filter129 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression131 = default(AstParserRuleReturnScope<object, IToken>);

		object ASSIGN130_tree = default(object);
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_filter=new RewriteRuleSubtreeStream(adaptor,"rule filter");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "property");
		DebugLocation(239, 95);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:239:10: ( name ( filter )? ( ASSIGN expression )? -> ^( PROPERTY[\"\"] name ( filter )? ( expression )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:239:12: name ( filter )? ( ASSIGN expression )?
			{
			DebugLocation(239, 12);
			PushFollow(Follow._name_in_property1637);
			name128=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(name128.Tree);
			DebugLocation(239, 17);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:239:17: ( filter )?
			int alt42=2;
			try { DebugEnterSubRule(42);
			try { DebugEnterDecision(42, false);
			int LA42_1 = input.LA(1);

			if ((LA42_1==AT))
			{
				alt42 = 1;
			}
			} finally { DebugExitDecision(42); }
			switch (alt42)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:239:18: filter
				{
				DebugLocation(239, 18);
				PushFollow(Follow._filter_in_property1640);
				filter129=filter();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_filter.Add(filter129.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(42); }

			DebugLocation(239, 27);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:239:27: ( ASSIGN expression )?
			int alt43=2;
			try { DebugEnterSubRule(43);
			try { DebugEnterDecision(43, false);
			int LA43_1 = input.LA(1);

			if ((LA43_1==ASSIGN))
			{
				alt43 = 1;
			}
			} finally { DebugExitDecision(43); }
			switch (alt43)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:239:28: ASSIGN expression
				{
				DebugLocation(239, 28);
				ASSIGN130=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_property1645); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN130);

				DebugLocation(239, 35);
				PushFollow(Follow._expression_in_property1647);
				expression131=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression131.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(43); }



			{
			// AST REWRITE
			// elements: name, filter, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 239:48: -> ^( PROPERTY[\"\"] name ( filter )? ( expression )? )
			{
				DebugLocation(239, 51);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:239:51: ^( PROPERTY[\"\"] name ( filter )? ( expression )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(239, 53);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROPERTY, ""), root_1);

				DebugLocation(239, 66);
				adaptor.AddChild(root_1, stream_name.NextTree());
				DebugLocation(239, 71);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:239:71: ( filter )?
				if (stream_filter.HasNext)
				{
					DebugLocation(239, 72);
					adaptor.AddChild(root_1, stream_filter.NextTree());

				}
				stream_filter.Reset();
				DebugLocation(239, 81);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:239:81: ( expression )?
				if (stream_expression.HasNext)
				{
					DebugLocation(239, 82);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("property", 47);
			LeaveRule("property", 47);
			LeaveRule_property();
		}
		DebugLocation(239, 95);
		} finally { DebugExitRule(GrammarFileName, "property"); }
		return retval;

	}
	// $ANTLR end "property"

	partial void EnterRule_methodSection();
	partial void LeaveRule_methodSection();
	// $ANTLR start "methodSection"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:243:1: methodSection : xMETHODS ( annotationPortion )? methods END -> ^( METHODSECTION[$xMETHODS.start] ( annotationPortion )? ( methods )? ) ;
	[GrammarRule("methodSection")]
	private AstParserRuleReturnScope<object, IToken> methodSection()
	{
		EnterRule_methodSection();
		EnterRule("methodSection", 48);
		TraceIn("methodSection", 48);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken END135 = default(IToken);
		AstParserRuleReturnScope<object, IToken> xMETHODS132 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> annotationPortion133 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> methods134 = default(AstParserRuleReturnScope<object, IToken>);

		object END135_tree = default(object);
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xMETHODS=new RewriteRuleSubtreeStream(adaptor,"rule xMETHODS");
		RewriteRuleSubtreeStream stream_annotationPortion=new RewriteRuleSubtreeStream(adaptor,"rule annotationPortion");
		RewriteRuleSubtreeStream stream_methods=new RewriteRuleSubtreeStream(adaptor,"rule methods");
		try { DebugEnterRule(GrammarFileName, "methodSection");
		DebugLocation(243, 127);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:243:15: ( xMETHODS ( annotationPortion )? methods END -> ^( METHODSECTION[$xMETHODS.start] ( annotationPortion )? ( methods )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:243:17: xMETHODS ( annotationPortion )? methods END
			{
			DebugLocation(243, 17);
			PushFollow(Follow._xMETHODS_in_methodSection1679);
			xMETHODS132=xMETHODS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xMETHODS.Add(xMETHODS132.Tree);
			DebugLocation(243, 26);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:243:26: ( annotationPortion )?
			int alt44=2;
			try { DebugEnterSubRule(44);
			try { DebugEnterDecision(44, false);
			int LA44_1 = input.LA(1);

			if ((LA44_1==LPAREN))
			{
				alt44 = 1;
			}
			} finally { DebugExitDecision(44); }
			switch (alt44)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:243:27: annotationPortion
				{
				DebugLocation(243, 27);
				PushFollow(Follow._annotationPortion_in_methodSection1682);
				annotationPortion133=annotationPortion();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_annotationPortion.Add(annotationPortion133.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(44); }

			DebugLocation(243, 47);
			PushFollow(Follow._methods_in_methodSection1686);
			methods134=methods();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_methods.Add(methods134.Tree);
			DebugLocation(243, 55);
			END135=(IToken)Match(input,END,Follow._END_in_methodSection1688); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END135);



			{
			// AST REWRITE
			// elements: annotationPortion, methods
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 243:59: -> ^( METHODSECTION[$xMETHODS.start] ( annotationPortion )? ( methods )? )
			{
				DebugLocation(243, 62);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:243:62: ^( METHODSECTION[$xMETHODS.start] ( annotationPortion )? ( methods )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(243, 64);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(METHODSECTION, (xMETHODS132!=null?((IToken)xMETHODS132.Start):default(IToken))), root_1);

				DebugLocation(243, 95);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:243:95: ( annotationPortion )?
				if (stream_annotationPortion.HasNext)
				{
					DebugLocation(243, 96);
					adaptor.AddChild(root_1, stream_annotationPortion.NextTree());

				}
				stream_annotationPortion.Reset();
				DebugLocation(243, 116);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:243:116: ( methods )?
				if (stream_methods.HasNext)
				{
					DebugLocation(243, 117);
					adaptor.AddChild(root_1, stream_methods.NextTree());

				}
				stream_methods.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("methodSection", 48);
			LeaveRule("methodSection", 48);
			LeaveRule_methodSection();
		}
		DebugLocation(243, 127);
		} finally { DebugExitRule(GrammarFileName, "methodSection"); }
		return retval;

	}
	// $ANTLR end "methodSection"

	partial void EnterRule_methods();
	partial void LeaveRule_methods();
	// $ANTLR start "methods"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:245:1: methods : ( method | xEOS )* -> ( method )* ;
	[GrammarRule("methods")]
	private AstParserRuleReturnScope<object, IToken> methods()
	{
		EnterRule_methods();
		EnterRule("methods", 49);
		TraceIn("methods", 49);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> method136 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS137 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_method=new RewriteRuleSubtreeStream(adaptor,"rule method");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "methods");
		DebugLocation(245, 40);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:245:9: ( ( method | xEOS )* -> ( method )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:245:11: ( method | xEOS )*
			{
			DebugLocation(245, 11);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:245:11: ( method | xEOS )*
			try { DebugEnterSubRule(45);
			while (true)
			{
				int alt45=3;
				try { DebugEnterDecision(45, false);
				int LA45_1 = input.LA(1);

				if ((LA45_1==FUNCTION||LA45_1==ID||LA45_1==LSQUARE))
				{
					alt45 = 1;
				}
				else if ((LA45_1==COMMA||LA45_1==EOL||LA45_1==SEMICOLON))
				{
					alt45 = 2;
				}


				} finally { DebugExitDecision(45); }
				switch ( alt45 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:245:12: method
					{
					DebugLocation(245, 12);
					PushFollow(Follow._method_in_methods1715);
					method136=method();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_method.Add(method136.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:245:21: xEOS
					{
					DebugLocation(245, 21);
					PushFollow(Follow._xEOS_in_methods1719);
					xEOS137=xEOS();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_xEOS.Add(xEOS137.Tree);

					}
					break;

				default:
					goto loop45;
				}
			}

			loop45:
				;

			} finally { DebugExitSubRule(45); }



			{
			// AST REWRITE
			// elements: method
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 245:28: -> ( method )*
			{
				DebugLocation(245, 31);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:245:31: ( method )*
				while ( stream_method.HasNext )
				{
					DebugLocation(245, 32);
					adaptor.AddChild(root_0, stream_method.NextTree());

				}
				stream_method.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("methods", 49);
			LeaveRule("methods", 49);
			LeaveRule_methods();
		}
		DebugLocation(245, 40);
		} finally { DebugExitRule(GrammarFileName, "methods"); }
		return retval;

	}
	// $ANTLR end "methods"

	partial void EnterRule_method();
	partial void LeaveRule_method();
	// $ANTLR start "method"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:247:1: method : ( regularMethod -> regularMethod | externalMethod -> externalMethod );
	[GrammarRule("method")]
	private AstParserRuleReturnScope<object, IToken> method()
	{
		EnterRule_method();
		EnterRule("method", 50);
		TraceIn("method", 50);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> regularMethod138 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> externalMethod139 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_regularMethod=new RewriteRuleSubtreeStream(adaptor,"rule regularMethod");
		RewriteRuleSubtreeStream stream_externalMethod=new RewriteRuleSubtreeStream(adaptor,"rule externalMethod");
		try { DebugEnterRule(GrammarFileName, "method");
		DebugLocation(247, 4);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:247:8: ( regularMethod -> regularMethod | externalMethod -> externalMethod )
			int alt46=2;
			try { DebugEnterDecision(46, false);
			int LA46_1 = input.LA(1);

			if ((LA46_1==FUNCTION))
			{
				alt46 = 1;
			}
			else if ((LA46_1==ID||LA46_1==LSQUARE))
			{
				alt46 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 46, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:247:10: regularMethod
				{
				DebugLocation(247, 10);
				PushFollow(Follow._regularMethod_in_method1737);
				regularMethod138=regularMethod();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_regularMethod.Add(regularMethod138.Tree);


				{
				// AST REWRITE
				// elements: regularMethod
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 247:24: -> regularMethod
				{
					DebugLocation(247, 27);
					adaptor.AddChild(root_0, stream_regularMethod.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:248:7: externalMethod
				{
				DebugLocation(248, 7);
				PushFollow(Follow._externalMethod_in_method1750);
				externalMethod139=externalMethod();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_externalMethod.Add(externalMethod139.Tree);


				{
				// AST REWRITE
				// elements: externalMethod
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 248:22: -> externalMethod
				{
					DebugLocation(248, 25);
					adaptor.AddChild(root_0, stream_externalMethod.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("method", 50);
			LeaveRule("method", 50);
			LeaveRule_method();
		}
		DebugLocation(249, 4);
		} finally { DebugExitRule(GrammarFileName, "method"); }
		return retval;

	}
	// $ANTLR end "method"

	partial void EnterRule_regularMethod();
	partial void LeaveRule_regularMethod();
	// $ANTLR start "regularMethod"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:251:1: regularMethod : FUNCTION methodSignature closeBody END -> ^( REGULARMETHOD[$FUNCTION] methodSignature ( closeBody )? ) ;
	[GrammarRule("regularMethod")]
	private AstParserRuleReturnScope<object, IToken> regularMethod()
	{
		EnterRule_regularMethod();
		EnterRule("regularMethod", 51);
		TraceIn("regularMethod", 51);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FUNCTION140 = default(IToken);
		IToken END143 = default(IToken);
		AstParserRuleReturnScope<object, IToken> methodSignature141 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> closeBody142 = default(AstParserRuleReturnScope<object, IToken>);

		object FUNCTION140_tree = default(object);
		object END143_tree = default(object);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_methodSignature=new RewriteRuleSubtreeStream(adaptor,"rule methodSignature");
		RewriteRuleSubtreeStream stream_closeBody=new RewriteRuleSubtreeStream(adaptor,"rule closeBody");
		try { DebugEnterRule(GrammarFileName, "regularMethod");
		DebugLocation(251, 115);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:251:15: ( FUNCTION methodSignature closeBody END -> ^( REGULARMETHOD[$FUNCTION] methodSignature ( closeBody )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:251:17: FUNCTION methodSignature closeBody END
			{
			DebugLocation(251, 17);
			FUNCTION140=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_regularMethod1768); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION140);

			DebugLocation(251, 26);
			PushFollow(Follow._methodSignature_in_regularMethod1770);
			methodSignature141=methodSignature();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_methodSignature.Add(methodSignature141.Tree);
			DebugLocation(251, 42);
			PushFollow(Follow._closeBody_in_regularMethod1772);
			closeBody142=closeBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_closeBody.Add(closeBody142.Tree);
			DebugLocation(251, 52);
			END143=(IToken)Match(input,END,Follow._END_in_regularMethod1774); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END143);



			{
			// AST REWRITE
			// elements: methodSignature, closeBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 251:56: -> ^( REGULARMETHOD[$FUNCTION] methodSignature ( closeBody )? )
			{
				DebugLocation(251, 59);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:251:59: ^( REGULARMETHOD[$FUNCTION] methodSignature ( closeBody )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(251, 61);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(REGULARMETHOD, FUNCTION140), root_1);

				DebugLocation(251, 86);
				adaptor.AddChild(root_1, stream_methodSignature.NextTree());
				DebugLocation(251, 102);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:251:102: ( closeBody )?
				if (stream_closeBody.HasNext)
				{
					DebugLocation(251, 103);
					adaptor.AddChild(root_1, stream_closeBody.NextTree());

				}
				stream_closeBody.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("regularMethod", 51);
			LeaveRule("regularMethod", 51);
			LeaveRule_regularMethod();
		}
		DebugLocation(251, 115);
		} finally { DebugExitRule(GrammarFileName, "regularMethod"); }
		return retval;

	}
	// $ANTLR end "regularMethod"

	partial void EnterRule_methodSignature();
	partial void LeaveRule_methodSignature();
	// $ANTLR start "methodSignature"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:253:1: methodSignature : ( ( outputPortion )? methodName1 ( inputPortion )? -> methodName1 ( inputPortion )? ( outputPortion )? | outputPortion methodName2 ( inputPortion )? -> methodName2 ( inputPortion )? ( outputPortion )? | methodName3 ( inputPortion )? -> methodName3 ( inputPortion )? );
	[GrammarRule("methodSignature")]
	private AstParserRuleReturnScope<object, IToken> methodSignature()
	{
		EnterRule_methodSignature();
		EnterRule("methodSignature", 52);
		TraceIn("methodSignature", 52);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> outputPortion144 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> methodName1145 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> inputPortion146 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> outputPortion147 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> methodName2148 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> inputPortion149 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> methodName3150 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> inputPortion151 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_outputPortion=new RewriteRuleSubtreeStream(adaptor,"rule outputPortion");
		RewriteRuleSubtreeStream stream_methodName1=new RewriteRuleSubtreeStream(adaptor,"rule methodName1");
		RewriteRuleSubtreeStream stream_inputPortion=new RewriteRuleSubtreeStream(adaptor,"rule inputPortion");
		RewriteRuleSubtreeStream stream_methodName2=new RewriteRuleSubtreeStream(adaptor,"rule methodName2");
		RewriteRuleSubtreeStream stream_methodName3=new RewriteRuleSubtreeStream(adaptor,"rule methodName3");
		Method_EnterSignature();
		try { DebugEnterRule(GrammarFileName, "methodSignature");
		DebugLocation(253, 0);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:254:34: ( ( outputPortion )? methodName1 ( inputPortion )? -> methodName1 ( inputPortion )? ( outputPortion )? | outputPortion methodName2 ( inputPortion )? -> methodName2 ( inputPortion )? ( outputPortion )? | methodName3 ( inputPortion )? -> methodName3 ( inputPortion )? )
			int alt51=3;
			try { DebugEnterDecision(51, false);
			try
			{
				alt51 = dfa51.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(51); }
			switch (alt51)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:255:3: ( outputPortion )? methodName1 ( inputPortion )?
				{
				DebugLocation(255, 3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:255:3: ( outputPortion )?
				int alt47=2;
				try { DebugEnterSubRule(47);
				try { DebugEnterDecision(47, false);
				int LA47_1 = input.LA(1);

				if ((LA47_1==ID))
				{
					int LA47_2 = input.LA(2);

					if ((LA47_2==ASSIGN))
					{
						alt47 = 1;
					}
				}
				else if ((LA47_1==LSQUARE))
				{
					alt47 = 1;
				}
				} finally { DebugExitDecision(47); }
				switch (alt47)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:255:4: outputPortion
					{
					DebugLocation(255, 4);
					PushFollow(Follow._outputPortion_in_methodSignature1807);
					outputPortion144=outputPortion();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_outputPortion.Add(outputPortion144.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(47); }

				DebugLocation(255, 20);
				PushFollow(Follow._methodName1_in_methodSignature1811);
				methodName1145=methodName1();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_methodName1.Add(methodName1145.Tree);
				DebugLocation(255, 32);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:255:32: ( inputPortion )?
				int alt48=2;
				try { DebugEnterSubRule(48);
				try { DebugEnterDecision(48, false);
				int LA48_1 = input.LA(1);

				if ((LA48_1==LPAREN))
				{
					alt48 = 1;
				}
				} finally { DebugExitDecision(48); }
				switch (alt48)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:255:33: inputPortion
					{
					DebugLocation(255, 33);
					PushFollow(Follow._inputPortion_in_methodSignature1814);
					inputPortion146=inputPortion();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_inputPortion.Add(inputPortion146.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(48); }



				{
				// AST REWRITE
				// elements: methodName1, inputPortion, outputPortion
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 255:48: -> methodName1 ( inputPortion )? ( outputPortion )?
				{
					DebugLocation(255, 51);
					adaptor.AddChild(root_0, stream_methodName1.NextTree());
					DebugLocation(255, 63);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:255:63: ( inputPortion )?
					if (stream_inputPortion.HasNext)
					{
						DebugLocation(255, 64);
						adaptor.AddChild(root_0, stream_inputPortion.NextTree());

					}
					stream_inputPortion.Reset();
					DebugLocation(255, 79);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:255:79: ( outputPortion )?
					if (stream_outputPortion.HasNext)
					{
						DebugLocation(255, 80);
						adaptor.AddChild(root_0, stream_outputPortion.NextTree());

					}
					stream_outputPortion.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:256:3: outputPortion methodName2 ( inputPortion )?
				{
				DebugLocation(256, 3);
				PushFollow(Follow._outputPortion_in_methodSignature1834);
				outputPortion147=outputPortion();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_outputPortion.Add(outputPortion147.Tree);
				DebugLocation(256, 17);
				PushFollow(Follow._methodName2_in_methodSignature1836);
				methodName2148=methodName2();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_methodName2.Add(methodName2148.Tree);
				DebugLocation(256, 29);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:256:29: ( inputPortion )?
				int alt49=2;
				try { DebugEnterSubRule(49);
				try { DebugEnterDecision(49, false);
				int LA49_1 = input.LA(1);

				if ((LA49_1==LPAREN))
				{
					alt49 = 1;
				}
				} finally { DebugExitDecision(49); }
				switch (alt49)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:256:30: inputPortion
					{
					DebugLocation(256, 30);
					PushFollow(Follow._inputPortion_in_methodSignature1839);
					inputPortion149=inputPortion();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_inputPortion.Add(inputPortion149.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(49); }



				{
				// AST REWRITE
				// elements: methodName2, inputPortion, outputPortion
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 256:45: -> methodName2 ( inputPortion )? ( outputPortion )?
				{
					DebugLocation(256, 48);
					adaptor.AddChild(root_0, stream_methodName2.NextTree());
					DebugLocation(256, 60);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:256:60: ( inputPortion )?
					if (stream_inputPortion.HasNext)
					{
						DebugLocation(256, 61);
						adaptor.AddChild(root_0, stream_inputPortion.NextTree());

					}
					stream_inputPortion.Reset();
					DebugLocation(256, 76);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:256:76: ( outputPortion )?
					if (stream_outputPortion.HasNext)
					{
						DebugLocation(256, 77);
						adaptor.AddChild(root_0, stream_outputPortion.NextTree());

					}
					stream_outputPortion.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:257:3: methodName3 ( inputPortion )?
				{
				DebugLocation(257, 3);
				PushFollow(Follow._methodName3_in_methodSignature1859);
				methodName3150=methodName3();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_methodName3.Add(methodName3150.Tree);
				DebugLocation(257, 15);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:257:15: ( inputPortion )?
				int alt50=2;
				try { DebugEnterSubRule(50);
				try { DebugEnterDecision(50, false);
				int LA50_1 = input.LA(1);

				if ((LA50_1==LPAREN))
				{
					alt50 = 1;
				}
				} finally { DebugExitDecision(50); }
				switch (alt50)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:257:16: inputPortion
					{
					DebugLocation(257, 16);
					PushFollow(Follow._inputPortion_in_methodSignature1862);
					inputPortion151=inputPortion();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_inputPortion.Add(inputPortion151.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(50); }



				{
				// AST REWRITE
				// elements: methodName3, inputPortion
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 257:31: -> methodName3 ( inputPortion )?
				{
					DebugLocation(257, 34);
					adaptor.AddChild(root_0, stream_methodName3.NextTree());
					DebugLocation(257, 46);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:257:46: ( inputPortion )?
					if (stream_inputPortion.HasNext)
					{
						DebugLocation(257, 47);
						adaptor.AddChild(root_0, stream_inputPortion.NextTree());

					}
					stream_inputPortion.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("methodSignature", 52);
			LeaveRule("methodSignature", 52);
			LeaveRule_methodSignature();
			Method_ExitSignature();
		}
		DebugLocation(258, 0);
		} finally { DebugExitRule(GrammarFileName, "methodSignature"); }
		return retval;

	}
	// $ANTLR end "methodSignature"

	partial void EnterRule_methodName1();
	partial void LeaveRule_methodName1();
	// $ANTLR start "methodName1"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:261:1: methodName1 : xID DOT xFUNCTIONID -> ^( NAME[\"\"] xID xFUNCTIONID ) ;
	[GrammarRule("methodName1")]
	private AstParserRuleReturnScope<object, IToken> methodName1()
	{
		EnterRule_methodName1();
		EnterRule("methodName1", 53);
		TraceIn("methodName1", 53);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DOT153 = default(IToken);
		AstParserRuleReturnScope<object, IToken> xID152 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xFUNCTIONID154 = default(AstParserRuleReturnScope<object, IToken>);

		object DOT153_tree = default(object);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_xID=new RewriteRuleSubtreeStream(adaptor,"rule xID");
		RewriteRuleSubtreeStream stream_xFUNCTIONID=new RewriteRuleSubtreeStream(adaptor,"rule xFUNCTIONID");
		try { DebugEnterRule(GrammarFileName, "methodName1");
		DebugLocation(261, 65);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:261:13: ( xID DOT xFUNCTIONID -> ^( NAME[\"\"] xID xFUNCTIONID ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:261:15: xID DOT xFUNCTIONID
			{
			DebugLocation(261, 15);
			PushFollow(Follow._xID_in_methodName11886);
			xID152=xID();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xID.Add(xID152.Tree);
			DebugLocation(261, 19);
			DOT153=(IToken)Match(input,DOT,Follow._DOT_in_methodName11888); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DOT.Add(DOT153);

			DebugLocation(261, 23);
			PushFollow(Follow._xFUNCTIONID_in_methodName11890);
			xFUNCTIONID154=xFUNCTIONID();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xFUNCTIONID.Add(xFUNCTIONID154.Tree);


			{
			// AST REWRITE
			// elements: xID, xFUNCTIONID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 261:35: -> ^( NAME[\"\"] xID xFUNCTIONID )
			{
				DebugLocation(261, 38);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:261:38: ^( NAME[\"\"] xID xFUNCTIONID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(261, 40);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAME, ""), root_1);

				DebugLocation(261, 49);
				adaptor.AddChild(root_1, stream_xID.NextTree());
				DebugLocation(261, 53);
				adaptor.AddChild(root_1, stream_xFUNCTIONID.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("methodName1", 53);
			LeaveRule("methodName1", 53);
			LeaveRule_methodName1();
		}
		DebugLocation(261, 65);
		} finally { DebugExitRule(GrammarFileName, "methodName1"); }
		return retval;

	}
	// $ANTLR end "methodName1"

	partial void EnterRule_methodName2();
	partial void LeaveRule_methodName2();
	// $ANTLR start "methodName2"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:263:1: methodName2 : xFUNCTIONID -> ^( NAME[\"\"] xFUNCTIONID ) ;
	[GrammarRule("methodName2")]
	private AstParserRuleReturnScope<object, IToken> methodName2()
	{
		EnterRule_methodName2();
		EnterRule("methodName2", 54);
		TraceIn("methodName2", 54);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> xFUNCTIONID155 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_xFUNCTIONID=new RewriteRuleSubtreeStream(adaptor,"rule xFUNCTIONID");
		try { DebugEnterRule(GrammarFileName, "methodName2");
		DebugLocation(263, 53);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:263:13: ( xFUNCTIONID -> ^( NAME[\"\"] xFUNCTIONID ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:263:15: xFUNCTIONID
			{
			DebugLocation(263, 15);
			PushFollow(Follow._xFUNCTIONID_in_methodName21910);
			xFUNCTIONID155=xFUNCTIONID();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xFUNCTIONID.Add(xFUNCTIONID155.Tree);


			{
			// AST REWRITE
			// elements: xFUNCTIONID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 263:27: -> ^( NAME[\"\"] xFUNCTIONID )
			{
				DebugLocation(263, 30);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:263:30: ^( NAME[\"\"] xFUNCTIONID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(263, 32);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAME, ""), root_1);

				DebugLocation(263, 41);
				adaptor.AddChild(root_1, stream_xFUNCTIONID.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("methodName2", 54);
			LeaveRule("methodName2", 54);
			LeaveRule_methodName2();
		}
		DebugLocation(263, 53);
		} finally { DebugExitRule(GrammarFileName, "methodName2"); }
		return retval;

	}
	// $ANTLR end "methodName2"

	partial void EnterRule_methodName3();
	partial void LeaveRule_methodName3();
	// $ANTLR start "methodName3"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:265:1: methodName3 : xID -> ^( NAME[\"\"] xID ) ;
	[GrammarRule("methodName3")]
	private AstParserRuleReturnScope<object, IToken> methodName3()
	{
		EnterRule_methodName3();
		EnterRule("methodName3", 55);
		TraceIn("methodName3", 55);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> xID156 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_xID=new RewriteRuleSubtreeStream(adaptor,"rule xID");
		try { DebugEnterRule(GrammarFileName, "methodName3");
		DebugLocation(265, 37);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:265:13: ( xID -> ^( NAME[\"\"] xID ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:265:15: xID
			{
			DebugLocation(265, 15);
			PushFollow(Follow._xID_in_methodName31928);
			xID156=xID();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xID.Add(xID156.Tree);


			{
			// AST REWRITE
			// elements: xID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 265:19: -> ^( NAME[\"\"] xID )
			{
				DebugLocation(265, 22);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:265:22: ^( NAME[\"\"] xID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(265, 24);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAME, ""), root_1);

				DebugLocation(265, 33);
				adaptor.AddChild(root_1, stream_xID.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("methodName3", 55);
			LeaveRule("methodName3", 55);
			LeaveRule_methodName3();
		}
		DebugLocation(265, 37);
		} finally { DebugExitRule(GrammarFileName, "methodName3"); }
		return retval;

	}
	// $ANTLR end "methodName3"

	partial void EnterRule_externalMethod();
	partial void LeaveRule_externalMethod();
	// $ANTLR start "externalMethod"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:267:1: externalMethod : methodSignature xEOS -> ^( EXTERNALMETHOD[\"\"] methodSignature ) ;
	[GrammarRule("externalMethod")]
	private AstParserRuleReturnScope<object, IToken> externalMethod()
	{
		EnterRule_externalMethod();
		EnterRule("externalMethod", 56);
		TraceIn("externalMethod", 56);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> methodSignature157 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS158 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_methodSignature=new RewriteRuleSubtreeStream(adaptor,"rule methodSignature");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "externalMethod");
		DebugLocation(267, 79);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:267:16: ( methodSignature xEOS -> ^( EXTERNALMETHOD[\"\"] methodSignature ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:267:18: methodSignature xEOS
			{
			DebugLocation(267, 18);
			PushFollow(Follow._methodSignature_in_externalMethod1946);
			methodSignature157=methodSignature();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_methodSignature.Add(methodSignature157.Tree);
			DebugLocation(267, 34);
			PushFollow(Follow._xEOS_in_externalMethod1948);
			xEOS158=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS158.Tree);


			{
			// AST REWRITE
			// elements: methodSignature
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 267:39: -> ^( EXTERNALMETHOD[\"\"] methodSignature )
			{
				DebugLocation(267, 42);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:267:42: ^( EXTERNALMETHOD[\"\"] methodSignature )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(267, 44);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXTERNALMETHOD, ""), root_1);

				DebugLocation(267, 63);
				adaptor.AddChild(root_1, stream_methodSignature.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("externalMethod", 56);
			LeaveRule("externalMethod", 56);
			LeaveRule_externalMethod();
		}
		DebugLocation(267, 79);
		} finally { DebugExitRule(GrammarFileName, "externalMethod"); }
		return retval;

	}
	// $ANTLR end "externalMethod"

	partial void EnterRule_enumerationSection();
	partial void LeaveRule_enumerationSection();
	// $ANTLR start "enumerationSection"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:271:1: enumerationSection : xENUMERATION ( annotationPortion )? enumerations END -> ^( ENUMERATIONSECTION[$xENUMERATION.start] ( annotationPortion )? ( enumerations )? ) ;
	[GrammarRule("enumerationSection")]
	private AstParserRuleReturnScope<object, IToken> enumerationSection()
	{
		EnterRule_enumerationSection();
		EnterRule("enumerationSection", 57);
		TraceIn("enumerationSection", 57);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken END162 = default(IToken);
		AstParserRuleReturnScope<object, IToken> xENUMERATION159 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> annotationPortion160 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enumerations161 = default(AstParserRuleReturnScope<object, IToken>);

		object END162_tree = default(object);
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_xENUMERATION=new RewriteRuleSubtreeStream(adaptor,"rule xENUMERATION");
		RewriteRuleSubtreeStream stream_annotationPortion=new RewriteRuleSubtreeStream(adaptor,"rule annotationPortion");
		RewriteRuleSubtreeStream stream_enumerations=new RewriteRuleSubtreeStream(adaptor,"rule enumerations");
		try { DebugEnterRule(GrammarFileName, "enumerationSection");
		DebugLocation(271, 155);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:271:20: ( xENUMERATION ( annotationPortion )? enumerations END -> ^( ENUMERATIONSECTION[$xENUMERATION.start] ( annotationPortion )? ( enumerations )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:271:22: xENUMERATION ( annotationPortion )? enumerations END
			{
			DebugLocation(271, 22);
			PushFollow(Follow._xENUMERATION_in_enumerationSection1968);
			xENUMERATION159=xENUMERATION();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xENUMERATION.Add(xENUMERATION159.Tree);
			DebugLocation(271, 35);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:271:35: ( annotationPortion )?
			int alt52=2;
			try { DebugEnterSubRule(52);
			try { DebugEnterDecision(52, false);
			int LA52_1 = input.LA(1);

			if ((LA52_1==LPAREN))
			{
				alt52 = 1;
			}
			} finally { DebugExitDecision(52); }
			switch (alt52)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:271:36: annotationPortion
				{
				DebugLocation(271, 36);
				PushFollow(Follow._annotationPortion_in_enumerationSection1971);
				annotationPortion160=annotationPortion();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_annotationPortion.Add(annotationPortion160.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(52); }

			DebugLocation(271, 56);
			PushFollow(Follow._enumerations_in_enumerationSection1975);
			enumerations161=enumerations();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_enumerations.Add(enumerations161.Tree);
			DebugLocation(271, 69);
			END162=(IToken)Match(input,END,Follow._END_in_enumerationSection1977); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END162);



			{
			// AST REWRITE
			// elements: annotationPortion, enumerations
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 271:73: -> ^( ENUMERATIONSECTION[$xENUMERATION.start] ( annotationPortion )? ( enumerations )? )
			{
				DebugLocation(271, 76);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:271:76: ^( ENUMERATIONSECTION[$xENUMERATION.start] ( annotationPortion )? ( enumerations )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(271, 78);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ENUMERATIONSECTION, (xENUMERATION159!=null?((IToken)xENUMERATION159.Start):default(IToken))), root_1);

				DebugLocation(271, 118);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:271:118: ( annotationPortion )?
				if (stream_annotationPortion.HasNext)
				{
					DebugLocation(271, 119);
					adaptor.AddChild(root_1, stream_annotationPortion.NextTree());

				}
				stream_annotationPortion.Reset();
				DebugLocation(271, 139);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:271:139: ( enumerations )?
				if (stream_enumerations.HasNext)
				{
					DebugLocation(271, 140);
					adaptor.AddChild(root_1, stream_enumerations.NextTree());

				}
				stream_enumerations.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enumerationSection", 57);
			LeaveRule("enumerationSection", 57);
			LeaveRule_enumerationSection();
		}
		DebugLocation(271, 155);
		} finally { DebugExitRule(GrammarFileName, "enumerationSection"); }
		return retval;

	}
	// $ANTLR end "enumerationSection"

	partial void EnterRule_enumerations();
	partial void LeaveRule_enumerations();
	// $ANTLR start "enumerations"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:273:1: enumerations : ( enumeration | xEOS )* -> ( enumeration )* ;
	[GrammarRule("enumerations")]
	private AstParserRuleReturnScope<object, IToken> enumerations()
	{
		EnterRule_enumerations();
		EnterRule("enumerations", 58);
		TraceIn("enumerations", 58);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> enumeration163 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS164 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_enumeration=new RewriteRuleSubtreeStream(adaptor,"rule enumeration");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "enumerations");
		DebugLocation(273, 55);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:273:14: ( ( enumeration | xEOS )* -> ( enumeration )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:273:16: ( enumeration | xEOS )*
			{
			DebugLocation(273, 16);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:273:16: ( enumeration | xEOS )*
			try { DebugEnterSubRule(53);
			while (true)
			{
				int alt53=3;
				try { DebugEnterDecision(53, false);
				int LA53_1 = input.LA(1);

				if ((LA53_1==ID))
				{
					alt53 = 1;
				}
				else if ((LA53_1==COMMA||LA53_1==EOL||LA53_1==SEMICOLON))
				{
					alt53 = 2;
				}


				} finally { DebugExitDecision(53); }
				switch ( alt53 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:273:17: enumeration
					{
					DebugLocation(273, 17);
					PushFollow(Follow._enumeration_in_enumerations2004);
					enumeration163=enumeration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_enumeration.Add(enumeration163.Tree);

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:273:31: xEOS
					{
					DebugLocation(273, 31);
					PushFollow(Follow._xEOS_in_enumerations2008);
					xEOS164=xEOS();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_xEOS.Add(xEOS164.Tree);

					}
					break;

				default:
					goto loop53;
				}
			}

			loop53:
				;

			} finally { DebugExitSubRule(53); }



			{
			// AST REWRITE
			// elements: enumeration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 273:38: -> ( enumeration )*
			{
				DebugLocation(273, 41);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:273:41: ( enumeration )*
				while ( stream_enumeration.HasNext )
				{
					DebugLocation(273, 42);
					adaptor.AddChild(root_0, stream_enumeration.NextTree());

				}
				stream_enumeration.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enumerations", 58);
			LeaveRule("enumerations", 58);
			LeaveRule_enumerations();
		}
		DebugLocation(273, 55);
		} finally { DebugExitRule(GrammarFileName, "enumerations"); }
		return retval;

	}
	// $ANTLR end "enumerations"

	partial void EnterRule_enumeration();
	partial void LeaveRule_enumeration();
	// $ANTLR start "enumeration"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:275:1: enumeration : name ( call )? -> ^( ENUMERATION[\"\"] name ( call )? ) ;
	[GrammarRule("enumeration")]
	private AstParserRuleReturnScope<object, IToken> enumeration()
	{
		EnterRule_enumeration();
		EnterRule("enumeration", 59);
		TraceIn("enumeration", 59);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> name165 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> call166 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		RewriteRuleSubtreeStream stream_call=new RewriteRuleSubtreeStream(adaptor,"rule call");
		try { DebugEnterRule(GrammarFileName, "enumeration");
		DebugLocation(275, 62);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:275:13: ( name ( call )? -> ^( ENUMERATION[\"\"] name ( call )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:275:15: name ( call )?
			{
			DebugLocation(275, 15);
			PushFollow(Follow._name_in_enumeration2026);
			name165=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(name165.Tree);
			DebugLocation(275, 20);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:275:20: ( call )?
			int alt54=2;
			try { DebugEnterSubRule(54);
			try { DebugEnterDecision(54, false);
			int LA54_1 = input.LA(1);

			if ((LA54_1==LPAREN))
			{
				alt54 = 1;
			}
			} finally { DebugExitDecision(54); }
			switch (alt54)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:275:21: call
				{
				DebugLocation(275, 21);
				PushFollow(Follow._call_in_enumeration2029);
				call166=call();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_call.Add(call166.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(54); }



			{
			// AST REWRITE
			// elements: name, call
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 275:28: -> ^( ENUMERATION[\"\"] name ( call )? )
			{
				DebugLocation(275, 31);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:275:31: ^( ENUMERATION[\"\"] name ( call )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(275, 33);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ENUMERATION, ""), root_1);

				DebugLocation(275, 49);
				adaptor.AddChild(root_1, stream_name.NextTree());
				DebugLocation(275, 54);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:275:54: ( call )?
				if (stream_call.HasNext)
				{
					DebugLocation(275, 55);
					adaptor.AddChild(root_1, stream_call.NextTree());

				}
				stream_call.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enumeration", 59);
			LeaveRule("enumeration", 59);
			LeaveRule_enumeration();
		}
		DebugLocation(275, 62);
		} finally { DebugExitRule(GrammarFileName, "enumeration"); }
		return retval;

	}
	// $ANTLR end "enumeration"

	partial void EnterRule_call();
	partial void LeaveRule_call();
	// $ANTLR start "call"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:277:1: call : LPAREN ( expressions )? RPAREN -> ( expressions )? ;
	[GrammarRule("call")]
	private AstParserRuleReturnScope<object, IToken> call()
	{
		EnterRule_call();
		EnterRule("call", 60);
		TraceIn("call", 60);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN167 = default(IToken);
		IToken RPAREN169 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expressions168 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN167_tree = default(object);
		object RPAREN169_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expressions=new RewriteRuleSubtreeStream(adaptor,"rule expressions");
		Balance_EnterParenthesis(); Index_EnterParenthesis();
		try { DebugEnterRule(GrammarFileName, "call");
		DebugLocation(277, 47);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:278:63: ( LPAREN ( expressions )? RPAREN -> ( expressions )? )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:279:1: LPAREN ( expressions )? RPAREN
			{
			DebugLocation(279, 1);
			LPAREN167=(IToken)Match(input,LPAREN,Follow._LPAREN_in_call2061); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN167);

			DebugLocation(279, 8);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:279:8: ( expressions )?
			int alt55=2;
			try { DebugEnterSubRule(55);
			try { DebugEnterDecision(55, false);
			int LA55_1 = input.LA(1);

			if ((LA55_1==ID||LA55_1==IMAGINARY||LA55_1==LCURLY||(LA55_1>=LPAREN && LA55_1<=LSQUARE)||LA55_1==MINUS||LA55_1==NOT||LA55_1==PLUS||LA55_1==REAL||LA55_1==STRING))
			{
				alt55 = 1;
			}
			else if ((LA55_1==END) && ((Index_IsActive())))
			{
				alt55 = 1;
			}
			else if ((LA55_1==AT||LA55_1==QUESTION))
			{
				alt55 = 1;
			}
			} finally { DebugExitDecision(55); }
			switch (alt55)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:279:9: expressions
				{
				DebugLocation(279, 9);
				PushFollow(Follow._expressions_in_call2064);
				expressions168=expressions();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expressions.Add(expressions168.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(55); }

			DebugLocation(279, 23);
			RPAREN169=(IToken)Match(input,RPAREN,Follow._RPAREN_in_call2068); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN169);



			{
			// AST REWRITE
			// elements: expressions
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 279:30: -> ( expressions )?
			{
				DebugLocation(279, 33);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:279:33: ( expressions )?
				if (stream_expressions.HasNext)
				{
					DebugLocation(279, 34);
					adaptor.AddChild(root_0, stream_expressions.NextTree());

				}
				stream_expressions.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("call", 60);
			LeaveRule("call", 60);
			LeaveRule_call();
			Index_ExitParenthesis(); Balance_ExitParenthesis();
		}
		DebugLocation(279, 47);
		} finally { DebugExitRule(GrammarFileName, "call"); }
		return retval;

	}
	// $ANTLR end "call"

	partial void EnterRule_expressions();
	partial void LeaveRule_expressions();
	// $ANTLR start "expressions"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:282:1: expressions : expression ( COMMA expression )* -> ( expression )+ ;
	[GrammarRule("expressions")]
	private AstParserRuleReturnScope<object, IToken> expressions()
	{
		EnterRule_expressions();
		EnterRule("expressions", 61);
		TraceIn("expressions", 61);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA171 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression170 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression172 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA171_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "expressions");
		DebugLocation(282, 62);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:282:13: ( expression ( COMMA expression )* -> ( expression )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:282:15: expression ( COMMA expression )*
			{
			DebugLocation(282, 15);
			PushFollow(Follow._expression_in_expressions2088);
			expression170=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression170.Tree);
			DebugLocation(282, 26);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:282:26: ( COMMA expression )*
			try { DebugEnterSubRule(56);
			while (true)
			{
				int alt56=2;
				try { DebugEnterDecision(56, false);
				int LA56_1 = input.LA(1);

				if ((LA56_1==COMMA))
				{
					alt56 = 1;
				}


				} finally { DebugExitDecision(56); }
				switch ( alt56 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:282:27: COMMA expression
					{
					DebugLocation(282, 27);
					COMMA171=(IToken)Match(input,COMMA,Follow._COMMA_in_expressions2091); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA171);

					DebugLocation(282, 33);
					PushFollow(Follow._expression_in_expressions2093);
					expression172=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(expression172.Tree);

					}
					break;

				default:
					goto loop56;
				}
			}

			loop56:
				;

			} finally { DebugExitSubRule(56); }



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 282:46: -> ( expression )+
			{
				DebugLocation(282, 49);
				if (!(stream_expression.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_expression.HasNext )
				{
					DebugLocation(282, 50);
					adaptor.AddChild(root_0, stream_expression.NextTree());

				}
				stream_expression.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressions", 61);
			LeaveRule("expressions", 61);
			LeaveRule_expressions();
		}
		DebugLocation(282, 62);
		} finally { DebugExitRule(GrammarFileName, "expressions"); }
		return retval;

	}
	// $ANTLR end "expressions"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:286:1: statement : ( ( assignment )=> assignment -> assignment | ( action )=> action -> action | ( simpleCommand )=> simpleCommand -> simpleCommand | ( abortCommand )=> abortCommand -> abortCommand | standardCommand -> standardCommand | bang -> bang | break -> break | continue -> continue | for -> for | global -> global | if -> if | parfor -> parfor | persistent -> persistent | return -> return | spmd -> spmd | switch -> switch | try -> try | while -> while );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<object, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 62);
		TraceIn("statement", 62);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> assignment173 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> action174 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> simpleCommand175 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> abortCommand176 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> standardCommand177 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> bang178 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> break179 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> continue180 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> for181 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> global182 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> if183 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parfor184 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> persistent185 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> return186 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> spmd187 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> switch188 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> try189 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> while190 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_assignment=new RewriteRuleSubtreeStream(adaptor,"rule assignment");
		RewriteRuleSubtreeStream stream_action=new RewriteRuleSubtreeStream(adaptor,"rule action");
		RewriteRuleSubtreeStream stream_simpleCommand=new RewriteRuleSubtreeStream(adaptor,"rule simpleCommand");
		RewriteRuleSubtreeStream stream_abortCommand=new RewriteRuleSubtreeStream(adaptor,"rule abortCommand");
		RewriteRuleSubtreeStream stream_standardCommand=new RewriteRuleSubtreeStream(adaptor,"rule standardCommand");
		RewriteRuleSubtreeStream stream_bang=new RewriteRuleSubtreeStream(adaptor,"rule bang");
		RewriteRuleSubtreeStream stream_break=new RewriteRuleSubtreeStream(adaptor,"rule break");
		RewriteRuleSubtreeStream stream_continue=new RewriteRuleSubtreeStream(adaptor,"rule continue");
		RewriteRuleSubtreeStream stream_for=new RewriteRuleSubtreeStream(adaptor,"rule for");
		RewriteRuleSubtreeStream stream_global=new RewriteRuleSubtreeStream(adaptor,"rule global");
		RewriteRuleSubtreeStream stream_if=new RewriteRuleSubtreeStream(adaptor,"rule if");
		RewriteRuleSubtreeStream stream_parfor=new RewriteRuleSubtreeStream(adaptor,"rule parfor");
		RewriteRuleSubtreeStream stream_persistent=new RewriteRuleSubtreeStream(adaptor,"rule persistent");
		RewriteRuleSubtreeStream stream_return=new RewriteRuleSubtreeStream(adaptor,"rule return");
		RewriteRuleSubtreeStream stream_spmd=new RewriteRuleSubtreeStream(adaptor,"rule spmd");
		RewriteRuleSubtreeStream stream_switch=new RewriteRuleSubtreeStream(adaptor,"rule switch");
		RewriteRuleSubtreeStream stream_try=new RewriteRuleSubtreeStream(adaptor,"rule try");
		RewriteRuleSubtreeStream stream_while=new RewriteRuleSubtreeStream(adaptor,"rule while");
		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(286, 10);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:286:11: ( ( assignment )=> assignment -> assignment | ( action )=> action -> action | ( simpleCommand )=> simpleCommand -> simpleCommand | ( abortCommand )=> abortCommand -> abortCommand | standardCommand -> standardCommand | bang -> bang | break -> break | continue -> continue | for -> for | global -> global | if -> if | parfor -> parfor | persistent -> persistent | return -> return | spmd -> spmd | switch -> switch | try -> try | while -> while )
			int alt57=18;
			try { DebugEnterDecision(57, false);
			int LA57_1 = input.LA(1);

			if ((LA57_1==ID))
			{
				int LA57_2 = input.LA(2);

				if (((EvaluatePredicate(synpred2_MatlabParser_fragment)&&(True()))))
				{
					alt57 = 1;
				}
				else if (((EvaluatePredicate(synpred3_MatlabParser_fragment)&&(True()))))
				{
					alt57 = 2;
				}
				else if (((EvaluatePredicate(synpred4_MatlabParser_fragment)&&(Command_IsEnabled()))))
				{
					alt57 = 3;
				}
				else if (((EvaluatePredicate(synpred5_MatlabParser_fragment)&&(Command_IsEnabled()))))
				{
					alt57 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 57, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA57_1==LSQUARE))
			{
				int LA57_2 = input.LA(2);

				if (((EvaluatePredicate(synpred2_MatlabParser_fragment)&&(True()))))
				{
					alt57 = 1;
				}
				else if (((EvaluatePredicate(synpred3_MatlabParser_fragment)&&(True()))))
				{
					alt57 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 57, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA57_1==PLUS) && ((EvaluatePredicate(synpred3_MatlabParser_fragment)&&(True()))))
			{
				alt57 = 2;
			}
			else if ((LA57_1==MINUS) && ((EvaluatePredicate(synpred3_MatlabParser_fragment)&&(True()))))
			{
				alt57 = 2;
			}
			else if ((LA57_1==NOT) && ((EvaluatePredicate(synpred3_MatlabParser_fragment)&&(True()))))
			{
				alt57 = 2;
			}
			else if ((LA57_1==REAL) && ((EvaluatePredicate(synpred3_MatlabParser_fragment)&&(True()))))
			{
				alt57 = 2;
			}
			else if ((LA57_1==IMAGINARY) && ((EvaluatePredicate(synpred3_MatlabParser_fragment)&&(True()))))
			{
				alt57 = 2;
			}
			else if ((LA57_1==STRING) && ((EvaluatePredicate(synpred3_MatlabParser_fragment)&&(True()))))
			{
				alt57 = 2;
			}
			else if ((LA57_1==LCURLY) && ((EvaluatePredicate(synpred3_MatlabParser_fragment)&&(True()))))
			{
				alt57 = 2;
			}
			else if ((LA57_1==LPAREN) && ((EvaluatePredicate(synpred3_MatlabParser_fragment)&&(True()))))
			{
				alt57 = 2;
			}
			else if ((LA57_1==END) && (((EvaluatePredicate(synpred3_MatlabParser_fragment)&&(True()))&&(Index_IsActive()))))
			{
				alt57 = 2;
			}
			else if ((LA57_1==AT) && ((EvaluatePredicate(synpred3_MatlabParser_fragment)&&(True()))))
			{
				alt57 = 2;
			}
			else if ((LA57_1==QUESTION) && ((EvaluatePredicate(synpred3_MatlabParser_fragment)&&(True()))))
			{
				alt57 = 2;
			}
			else if ((LA57_1==COMMAND))
			{
				alt57 = 5;
			}
			else if ((LA57_1==EXCLAMATION))
			{
				alt57 = 6;
			}
			else if ((LA57_1==BREAK))
			{
				alt57 = 7;
			}
			else if ((LA57_1==CONTINUE))
			{
				alt57 = 8;
			}
			else if ((LA57_1==FOR))
			{
				alt57 = 9;
			}
			else if ((LA57_1==GLOBAL))
			{
				alt57 = 10;
			}
			else if ((LA57_1==IF))
			{
				alt57 = 11;
			}
			else if ((LA57_1==PARFOR))
			{
				alt57 = 12;
			}
			else if ((LA57_1==PERSISTENT))
			{
				alt57 = 13;
			}
			else if ((LA57_1==RETURN))
			{
				alt57 = 14;
			}
			else if ((LA57_1==SPMD))
			{
				alt57 = 15;
			}
			else if ((LA57_1==SWITCH))
			{
				alt57 = 16;
			}
			else if ((LA57_1==TRY))
			{
				alt57 = 17;
			}
			else if ((LA57_1==WHILE))
			{
				alt57 = 18;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 57, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(57); }
			switch (alt57)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:286:13: ( assignment )=> assignment
				{
				DebugLocation(286, 28);
				PushFollow(Follow._assignment_in_statement2118);
				assignment173=assignment();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignment.Add(assignment173.Tree);


				{
				// AST REWRITE
				// elements: assignment
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 286:39: -> assignment
				{
					DebugLocation(286, 42);
					adaptor.AddChild(root_0, stream_assignment.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:287:13: ( action )=> action
				{
				DebugLocation(287, 24);
				PushFollow(Follow._action_in_statement2143);
				action174=action();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_action.Add(action174.Tree);


				{
				// AST REWRITE
				// elements: action
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 287:31: -> action
				{
					DebugLocation(287, 34);
					adaptor.AddChild(root_0, stream_action.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:288:7: ( simpleCommand )=> simpleCommand
				{
				DebugLocation(288, 25);
				PushFollow(Follow._simpleCommand_in_statement2162);
				simpleCommand175=simpleCommand();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_simpleCommand.Add(simpleCommand175.Tree);


				{
				// AST REWRITE
				// elements: simpleCommand
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 288:39: -> simpleCommand
				{
					DebugLocation(288, 42);
					adaptor.AddChild(root_0, stream_simpleCommand.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:289:7: ( abortCommand )=> abortCommand
				{
				DebugLocation(289, 24);
				PushFollow(Follow._abortCommand_in_statement2181);
				abortCommand176=abortCommand();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_abortCommand.Add(abortCommand176.Tree);


				{
				// AST REWRITE
				// elements: abortCommand
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 289:37: -> abortCommand
				{
					DebugLocation(289, 40);
					adaptor.AddChild(root_0, stream_abortCommand.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:290:7: standardCommand
				{
				DebugLocation(290, 7);
				PushFollow(Follow._standardCommand_in_statement2195);
				standardCommand177=standardCommand();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_standardCommand.Add(standardCommand177.Tree);


				{
				// AST REWRITE
				// elements: standardCommand
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 290:23: -> standardCommand
				{
					DebugLocation(290, 26);
					adaptor.AddChild(root_0, stream_standardCommand.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:291:7: bang
				{
				DebugLocation(291, 7);
				PushFollow(Follow._bang_in_statement2209);
				bang178=bang();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bang.Add(bang178.Tree);


				{
				// AST REWRITE
				// elements: bang
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 291:12: -> bang
				{
					DebugLocation(291, 15);
					adaptor.AddChild(root_0, stream_bang.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:292:13: break
				{
				DebugLocation(292, 13);
				PushFollow(Follow._break_in_statement2228);
				break179=@break();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_break.Add(break179.Tree);


				{
				// AST REWRITE
				// elements: break
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 292:19: -> break
				{
					DebugLocation(292, 22);
					adaptor.AddChild(root_0, stream_break.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:293:13: continue
				{
				DebugLocation(293, 13);
				PushFollow(Follow._continue_in_statement2248);
				continue180=@continue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_continue.Add(continue180.Tree);


				{
				// AST REWRITE
				// elements: continue
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 293:22: -> continue
				{
					DebugLocation(293, 25);
					adaptor.AddChild(root_0, stream_continue.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:294:13: for
				{
				DebugLocation(294, 13);
				PushFollow(Follow._for_in_statement2268);
				for181=@for();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_for.Add(for181.Tree);


				{
				// AST REWRITE
				// elements: for
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 294:17: -> for
				{
					DebugLocation(294, 20);
					adaptor.AddChild(root_0, stream_for.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:295:13: global
				{
				DebugLocation(295, 13);
				PushFollow(Follow._global_in_statement2287);
				global182=global();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_global.Add(global182.Tree);


				{
				// AST REWRITE
				// elements: global
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 295:20: -> global
				{
					DebugLocation(295, 23);
					adaptor.AddChild(root_0, stream_global.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:296:13: if
				{
				DebugLocation(296, 13);
				PushFollow(Follow._if_in_statement2306);
				if183=@if();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_if.Add(if183.Tree);


				{
				// AST REWRITE
				// elements: if
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 296:16: -> if
				{
					DebugLocation(296, 19);
					adaptor.AddChild(root_0, stream_if.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:297:13: parfor
				{
				DebugLocation(297, 13);
				PushFollow(Follow._parfor_in_statement2325);
				parfor184=parfor();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parfor.Add(parfor184.Tree);


				{
				// AST REWRITE
				// elements: parfor
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 297:20: -> parfor
				{
					DebugLocation(297, 23);
					adaptor.AddChild(root_0, stream_parfor.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:298:13: persistent
				{
				DebugLocation(298, 13);
				PushFollow(Follow._persistent_in_statement2344);
				persistent185=persistent();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_persistent.Add(persistent185.Tree);


				{
				// AST REWRITE
				// elements: persistent
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 298:24: -> persistent
				{
					DebugLocation(298, 27);
					adaptor.AddChild(root_0, stream_persistent.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:299:13: return
				{
				DebugLocation(299, 13);
				PushFollow(Follow._return_in_statement2363);
				return186=@return();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_return.Add(return186.Tree);


				{
				// AST REWRITE
				// elements: return
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 299:20: -> return
				{
					DebugLocation(299, 23);
					adaptor.AddChild(root_0, stream_return.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:300:7: spmd
				{
				DebugLocation(300, 7);
				PushFollow(Follow._spmd_in_statement2376);
				spmd187=spmd();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_spmd.Add(spmd187.Tree);


				{
				// AST REWRITE
				// elements: spmd
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 300:12: -> spmd
				{
					DebugLocation(300, 15);
					adaptor.AddChild(root_0, stream_spmd.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:301:13: switch
				{
				DebugLocation(301, 13);
				PushFollow(Follow._switch_in_statement2395);
				switch188=@switch();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_switch.Add(switch188.Tree);


				{
				// AST REWRITE
				// elements: switch
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 301:20: -> switch
				{
					DebugLocation(301, 23);
					adaptor.AddChild(root_0, stream_switch.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 17:
				DebugEnterAlt(17);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:302:13: try
				{
				DebugLocation(302, 13);
				PushFollow(Follow._try_in_statement2414);
				try189=@try();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_try.Add(try189.Tree);


				{
				// AST REWRITE
				// elements: try
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 302:17: -> try
				{
					DebugLocation(302, 20);
					adaptor.AddChild(root_0, stream_try.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 18:
				DebugEnterAlt(18);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:303:13: while
				{
				DebugLocation(303, 13);
				PushFollow(Follow._while_in_statement2433);
				while190=@while();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_while.Add(while190.Tree);


				{
				// AST REWRITE
				// elements: while
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 303:19: -> while
				{
					DebugLocation(303, 22);
					adaptor.AddChild(root_0, stream_while.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 62);
			LeaveRule("statement", 62);
			LeaveRule_statement();
		}
		DebugLocation(304, 10);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();
	// $ANTLR start "assignment"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:308:1: assignment :{...}? => assignmentCore -> assignmentCore ;
	[GrammarRule("assignment")]
	private AstParserRuleReturnScope<object, IToken> assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 63);
		TraceIn("assignment", 63);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> assignmentCore191 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_assignmentCore=new RewriteRuleSubtreeStream(adaptor,"rule assignmentCore");
		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(308, 58);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:308:12: ({...}? => assignmentCore -> assignmentCore )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:308:14: {...}? => assignmentCore
			{
			DebugLocation(308, 14);
			if (!((True())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "assignment", "True()");
			}
			DebugLocation(308, 26);
			PushFollow(Follow._assignmentCore_in_assignment2471);
			assignmentCore191=assignmentCore();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentCore.Add(assignmentCore191.Tree);


			{
			// AST REWRITE
			// elements: assignmentCore
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 308:41: -> assignmentCore
			{
				DebugLocation(308, 44);
				adaptor.AddChild(root_0, stream_assignmentCore.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignment", 63);
			LeaveRule("assignment", 63);
			LeaveRule_assignment();
		}
		DebugLocation(308, 58);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return retval;

	}
	// $ANTLR end "assignment"

	partial void EnterRule_assignmentCore();
	partial void LeaveRule_assignmentCore();
	// $ANTLR start "assignmentCore"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:310:1: assignmentCore : ( chain ASSIGN expression xEOS -> ^( ASSIGN chain expression xEOS ) | storage ASSIGN expression xEOS -> ^( ASSIGN storage expression xEOS ) );
	[GrammarRule("assignmentCore")]
	private AstParserRuleReturnScope<object, IToken> assignmentCore()
	{
		EnterRule_assignmentCore();
		EnterRule("assignmentCore", 64);
		TraceIn("assignmentCore", 64);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ASSIGN193 = default(IToken);
		IToken ASSIGN197 = default(IToken);
		AstParserRuleReturnScope<object, IToken> chain192 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression194 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS195 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> storage196 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression198 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS199 = default(AstParserRuleReturnScope<object, IToken>);

		object ASSIGN193_tree = default(object);
		object ASSIGN197_tree = default(object);
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_chain=new RewriteRuleSubtreeStream(adaptor,"rule chain");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_storage=new RewriteRuleSubtreeStream(adaptor,"rule storage");
		try { DebugEnterRule(GrammarFileName, "assignmentCore");
		DebugLocation(310, 6);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:310:16: ( chain ASSIGN expression xEOS -> ^( ASSIGN chain expression xEOS ) | storage ASSIGN expression xEOS -> ^( ASSIGN storage expression xEOS ) )
			int alt58=2;
			try { DebugEnterDecision(58, false);
			int LA58_1 = input.LA(1);

			if ((LA58_1==ID))
			{
				alt58 = 1;
			}
			else if ((LA58_1==LSQUARE))
			{
				alt58 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 58, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(58); }
			switch (alt58)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:310:18: chain ASSIGN expression xEOS
				{
				DebugLocation(310, 18);
				PushFollow(Follow._chain_in_assignmentCore2484);
				chain192=chain();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_chain.Add(chain192.Tree);
				DebugLocation(310, 24);
				ASSIGN193=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_assignmentCore2486); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN193);

				DebugLocation(310, 31);
				PushFollow(Follow._expression_in_assignmentCore2488);
				expression194=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression194.Tree);
				DebugLocation(310, 42);
				PushFollow(Follow._xEOS_in_assignmentCore2490);
				xEOS195=xEOS();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_xEOS.Add(xEOS195.Tree);


				{
				// AST REWRITE
				// elements: ASSIGN, chain, expression, xEOS
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 310:47: -> ^( ASSIGN chain expression xEOS )
				{
					DebugLocation(310, 50);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:310:50: ^( ASSIGN chain expression xEOS )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(310, 52);
					root_1 = (object)adaptor.BecomeRoot(stream_ASSIGN.NextNode(), root_1);

					DebugLocation(310, 59);
					adaptor.AddChild(root_1, stream_chain.NextTree());
					DebugLocation(310, 65);
					adaptor.AddChild(root_1, stream_expression.NextTree());
					DebugLocation(310, 76);
					adaptor.AddChild(root_1, stream_xEOS.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:311:9: storage ASSIGN expression xEOS
				{
				DebugLocation(311, 9);
				PushFollow(Follow._storage_in_assignmentCore2513);
				storage196=storage();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_storage.Add(storage196.Tree);
				DebugLocation(311, 17);
				ASSIGN197=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_assignmentCore2515); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN197);

				DebugLocation(311, 24);
				PushFollow(Follow._expression_in_assignmentCore2517);
				expression198=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression198.Tree);
				DebugLocation(311, 35);
				PushFollow(Follow._xEOS_in_assignmentCore2519);
				xEOS199=xEOS();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_xEOS.Add(xEOS199.Tree);


				{
				// AST REWRITE
				// elements: ASSIGN, storage, expression, xEOS
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 311:40: -> ^( ASSIGN storage expression xEOS )
				{
					DebugLocation(311, 43);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:311:43: ^( ASSIGN storage expression xEOS )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(311, 45);
					root_1 = (object)adaptor.BecomeRoot(stream_ASSIGN.NextNode(), root_1);

					DebugLocation(311, 52);
					adaptor.AddChild(root_1, stream_storage.NextTree());
					DebugLocation(311, 60);
					adaptor.AddChild(root_1, stream_expression.NextTree());
					DebugLocation(311, 71);
					adaptor.AddChild(root_1, stream_xEOS.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentCore", 64);
			LeaveRule("assignmentCore", 64);
			LeaveRule_assignmentCore();
		}
		DebugLocation(312, 6);
		} finally { DebugExitRule(GrammarFileName, "assignmentCore"); }
		return retval;

	}
	// $ANTLR end "assignmentCore"

	partial void EnterRule_storage();
	partial void LeaveRule_storage();
	// $ANTLR start "storage"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:314:1: storage : LSQUARE ( COMMA )? slots ( COMMA )? RSQUARE -> ^( STORAGE[\"\"] slots ) ;
	[GrammarRule("storage")]
	private AstParserRuleReturnScope<object, IToken> storage()
	{
		EnterRule_storage();
		EnterRule("storage", 65);
		TraceIn("storage", 65);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LSQUARE200 = default(IToken);
		IToken COMMA201 = default(IToken);
		IToken COMMA203 = default(IToken);
		IToken RSQUARE204 = default(IToken);
		AstParserRuleReturnScope<object, IToken> slots202 = default(AstParserRuleReturnScope<object, IToken>);

		object LSQUARE200_tree = default(object);
		object COMMA201_tree = default(object);
		object COMMA203_tree = default(object);
		object RSQUARE204_tree = default(object);
		RewriteRuleITokenStream stream_LSQUARE=new RewriteRuleITokenStream(adaptor,"token LSQUARE");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_RSQUARE=new RewriteRuleITokenStream(adaptor,"token RSQUARE");
		RewriteRuleSubtreeStream stream_slots=new RewriteRuleSubtreeStream(adaptor,"rule slots");
		Balance_EnterStorageSquareBrace();
		try { DebugEnterRule(GrammarFileName, "storage");
		DebugLocation(314, 64);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:315:44: ( LSQUARE ( COMMA )? slots ( COMMA )? RSQUARE -> ^( STORAGE[\"\"] slots ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:316:1: LSQUARE ( COMMA )? slots ( COMMA )? RSQUARE
			{
			DebugLocation(316, 1);
			LSQUARE200=(IToken)Match(input,LSQUARE,Follow._LSQUARE_in_storage2554); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LSQUARE.Add(LSQUARE200);

			DebugLocation(316, 9);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:316:9: ( COMMA )?
			int alt59=2;
			try { DebugEnterSubRule(59);
			try { DebugEnterDecision(59, false);
			int LA59_1 = input.LA(1);

			if ((LA59_1==COMMA))
			{
				alt59 = 1;
			}
			} finally { DebugExitDecision(59); }
			switch (alt59)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:316:10: COMMA
				{
				DebugLocation(316, 10);
				COMMA201=(IToken)Match(input,COMMA,Follow._COMMA_in_storage2557); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COMMA.Add(COMMA201);


				}
				break;

			}
			} finally { DebugExitSubRule(59); }

			DebugLocation(316, 18);
			PushFollow(Follow._slots_in_storage2561);
			slots202=slots();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_slots.Add(slots202.Tree);
			DebugLocation(316, 24);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:316:24: ( COMMA )?
			int alt60=2;
			try { DebugEnterSubRule(60);
			try { DebugEnterDecision(60, false);
			int LA60_1 = input.LA(1);

			if ((LA60_1==COMMA))
			{
				alt60 = 1;
			}
			} finally { DebugExitDecision(60); }
			switch (alt60)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:316:25: COMMA
				{
				DebugLocation(316, 25);
				COMMA203=(IToken)Match(input,COMMA,Follow._COMMA_in_storage2564); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COMMA.Add(COMMA203);


				}
				break;

			}
			} finally { DebugExitSubRule(60); }

			DebugLocation(316, 33);
			RSQUARE204=(IToken)Match(input,RSQUARE,Follow._RSQUARE_in_storage2568); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RSQUARE.Add(RSQUARE204);



			{
			// AST REWRITE
			// elements: slots
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 316:41: -> ^( STORAGE[\"\"] slots )
			{
				DebugLocation(316, 44);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:316:44: ^( STORAGE[\"\"] slots )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(316, 46);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(STORAGE, ""), root_1);

				DebugLocation(316, 58);
				adaptor.AddChild(root_1, stream_slots.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("storage", 65);
			LeaveRule("storage", 65);
			LeaveRule_storage();
			Balance_ExitStorageSquareBrace();
		}
		DebugLocation(316, 64);
		} finally { DebugExitRule(GrammarFileName, "storage"); }
		return retval;

	}
	// $ANTLR end "storage"

	partial void EnterRule_slots();
	partial void LeaveRule_slots();
	// $ANTLR start "slots"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:319:1: slots : slot ({...}? => ( COMMA )? slot )* -> ( slot )+ ;
	[GrammarRule("slots")]
	private AstParserRuleReturnScope<object, IToken> slots()
	{
		EnterRule_slots();
		EnterRule("slots", 66);
		TraceIn("slots", 66);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA206 = default(IToken);
		AstParserRuleReturnScope<object, IToken> slot205 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> slot207 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA206_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_slot=new RewriteRuleSubtreeStream(adaptor,"rule slot");
		try { DebugEnterRule(GrammarFileName, "slots");
		DebugLocation(319, 86);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:319:7: ( slot ({...}? => ( COMMA )? slot )* -> ( slot )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:319:9: slot ({...}? => ( COMMA )? slot )*
			{
			DebugLocation(319, 9);
			PushFollow(Follow._slot_in_slots2590);
			slot205=slot();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_slot.Add(slot205.Tree);
			DebugLocation(319, 14);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:319:14: ({...}? => ( COMMA )? slot )*
			try { DebugEnterSubRule(62);
			while (true)
			{
				int alt62=2;
				try { DebugEnterDecision(62, false);
				int LA62_1 = input.LA(1);

				if ((LA62_1==COMMA))
				{
					int LA62_2 = input.LA(2);

					if ((LA62_2==ID||LA62_2==NOT||LA62_2==QUESTION) && ((Separator_CommaFollowsOrSpacesPrecede())))
					{
						alt62 = 1;
					}


				}
				else if ((LA62_1==ID||LA62_1==NOT||LA62_1==QUESTION) && ((Separator_CommaFollowsOrSpacesPrecede())))
				{
					alt62 = 1;
				}


				} finally { DebugExitDecision(62); }
				switch ( alt62 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:319:15: {...}? => ( COMMA )? slot
					{
					DebugLocation(319, 15);
					if (!((Separator_CommaFollowsOrSpacesPrecede())))
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "slots", "Separator_CommaFollowsOrSpacesPrecede()");
					}
					DebugLocation(319, 60);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:319:60: ( COMMA )?
					int alt61=2;
					try { DebugEnterSubRule(61);
					try { DebugEnterDecision(61, false);
					int LA61_1 = input.LA(1);

					if ((LA61_1==COMMA))
					{
						alt61 = 1;
					}
					} finally { DebugExitDecision(61); }
					switch (alt61)
					{
					case 1:
						DebugEnterAlt(1);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:319:61: COMMA
						{
						DebugLocation(319, 61);
						COMMA206=(IToken)Match(input,COMMA,Follow._COMMA_in_slots2597); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA206);


						}
						break;

					}
					} finally { DebugExitSubRule(61); }

					DebugLocation(319, 69);
					PushFollow(Follow._slot_in_slots2601);
					slot207=slot();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_slot.Add(slot207.Tree);

					}
					break;

				default:
					goto loop62;
				}
			}

			loop62:
				;

			} finally { DebugExitSubRule(62); }



			{
			// AST REWRITE
			// elements: slot
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 319:76: -> ( slot )+
			{
				DebugLocation(319, 79);
				if (!(stream_slot.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_slot.HasNext )
				{
					DebugLocation(319, 80);
					adaptor.AddChild(root_0, stream_slot.NextTree());

				}
				stream_slot.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("slots", 66);
			LeaveRule("slots", 66);
			LeaveRule_slots();
		}
		DebugLocation(319, 86);
		} finally { DebugExitRule(GrammarFileName, "slots"); }
		return retval;

	}
	// $ANTLR end "slots"

	partial void EnterRule_slot();
	partial void LeaveRule_slot();
	// $ANTLR start "slot"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:321:1: slot : ( chain -> chain | metaclass -> metaclass | NOT -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) ) );
	[GrammarRule("slot")]
	private AstParserRuleReturnScope<object, IToken> slot()
	{
		EnterRule_slot();
		EnterRule("slot", 67);
		TraceIn("slot", 67);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NOT210 = default(IToken);
		AstParserRuleReturnScope<object, IToken> chain208 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> metaclass209 = default(AstParserRuleReturnScope<object, IToken>);

		object NOT210_tree = default(object);
		RewriteRuleITokenStream stream_NOT=new RewriteRuleITokenStream(adaptor,"token NOT");
		RewriteRuleSubtreeStream stream_chain=new RewriteRuleSubtreeStream(adaptor,"rule chain");
		RewriteRuleSubtreeStream stream_metaclass=new RewriteRuleSubtreeStream(adaptor,"rule metaclass");
		try { DebugEnterRule(GrammarFileName, "slot");
		DebugLocation(321, 2);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:321:6: ( chain -> chain | metaclass -> metaclass | NOT -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) ) )
			int alt63=3;
			try { DebugEnterDecision(63, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt63 = 1;
				}
				break;
			case QUESTION:
				{
				alt63 = 2;
				}
				break;
			case NOT:
				{
				alt63 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 63, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:321:8: chain
				{
				DebugLocation(321, 8);
				PushFollow(Follow._chain_in_slot2619);
				chain208=chain();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_chain.Add(chain208.Tree);


				{
				// AST REWRITE
				// elements: chain
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 321:14: -> chain
				{
					DebugLocation(321, 17);
					adaptor.AddChild(root_0, stream_chain.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:322:5: metaclass
				{
				DebugLocation(322, 5);
				PushFollow(Follow._metaclass_in_slot2630);
				metaclass209=metaclass();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_metaclass.Add(metaclass209.Tree);


				{
				// AST REWRITE
				// elements: metaclass
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 322:15: -> metaclass
				{
					DebugLocation(322, 18);
					adaptor.AddChild(root_0, stream_metaclass.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:323:5: NOT
				{
				DebugLocation(323, 5);
				NOT210=(IToken)Match(input,NOT,Follow._NOT_in_slot2641); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NOT.Add(NOT210);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 323:9: -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) )
				{
					DebugLocation(323, 12);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:323:12: ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(323, 14);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, ""), root_1);

					DebugLocation(323, 22);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:323:22: ^( NAME[\"\"] ID[$NOT] )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(323, 24);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAME, ""), root_2);

					DebugLocation(323, 33);
					adaptor.AddChild(root_2, (object)adaptor.Create(ID, NOT210));

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("slot", 67);
			LeaveRule("slot", 67);
			LeaveRule_slot();
		}
		DebugLocation(324, 2);
		} finally { DebugExitRule(GrammarFileName, "slot"); }
		return retval;

	}
	// $ANTLR end "slot"

	partial void EnterRule_action();
	partial void LeaveRule_action();
	// $ANTLR start "action"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:328:1: action :{...}? => expression xEOS -> ^( ACTION[\"\"] expression xEOS ) ;
	[GrammarRule("action")]
	private AstParserRuleReturnScope<object, IToken> action()
	{
		EnterRule_action();
		EnterRule("action", 68);
		TraceIn("action", 68);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> expression211 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS212 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "action");
		DebugLocation(328, 70);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:328:8: ({...}? => expression xEOS -> ^( ACTION[\"\"] expression xEOS ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:328:10: {...}? => expression xEOS
			{
			DebugLocation(328, 10);
			if (!((True())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "action", "True()");
			}
			DebugLocation(328, 22);
			PushFollow(Follow._expression_in_action2672);
			expression211=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression211.Tree);
			DebugLocation(328, 33);
			PushFollow(Follow._xEOS_in_action2674);
			xEOS212=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS212.Tree);


			{
			// AST REWRITE
			// elements: expression, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 328:38: -> ^( ACTION[\"\"] expression xEOS )
			{
				DebugLocation(328, 41);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:328:41: ^( ACTION[\"\"] expression xEOS )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(328, 43);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ACTION, ""), root_1);

				DebugLocation(328, 54);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(328, 65);
				adaptor.AddChild(root_1, stream_xEOS.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("action", 68);
			LeaveRule("action", 68);
			LeaveRule_action();
		}
		DebugLocation(328, 70);
		} finally { DebugExitRule(GrammarFileName, "action"); }
		return retval;

	}
	// $ANTLR end "action"

	partial void EnterRule_simpleCommand();
	partial void LeaveRule_simpleCommand();
	// $ANTLR start "simpleCommand"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:332:1: simpleCommand :{...}? => var simpleTexts xEOS -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] var simpleTexts ) xEOS ) ;
	[GrammarRule("simpleCommand")]
	private AstParserRuleReturnScope<object, IToken> simpleCommand()
	{
		EnterRule_simpleCommand();
		EnterRule("simpleCommand", 69);
		TraceIn("simpleCommand", 69);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> var213 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> simpleTexts214 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS215 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_simpleTexts=new RewriteRuleSubtreeStream(adaptor,"rule simpleTexts");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "simpleCommand");
		DebugLocation(332, 119);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:332:15: ({...}? => var simpleTexts xEOS -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] var simpleTexts ) xEOS ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:332:17: {...}? => var simpleTexts xEOS
			{
			DebugLocation(332, 17);
			if (!((Command_IsEnabled())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "simpleCommand", "Command_IsEnabled()");
			}
			DebugLocation(332, 42);
			PushFollow(Follow._var_in_simpleCommand2699);
			var213=var();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_var.Add(var213.Tree);
			DebugLocation(332, 46);
			PushFollow(Follow._simpleTexts_in_simpleCommand2701);
			simpleTexts214=simpleTexts();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_simpleTexts.Add(simpleTexts214.Tree);
			DebugLocation(332, 58);
			PushFollow(Follow._xEOS_in_simpleCommand2703);
			xEOS215=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS215.Tree);


			{
			// AST REWRITE
			// elements: var, simpleTexts, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 332:63: -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] var simpleTexts ) xEOS )
			{
				DebugLocation(332, 66);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:332:66: ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] var simpleTexts ) xEOS )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(332, 68);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ACTION, ""), root_1);

				DebugLocation(332, 79);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:332:79: ^( PARENTHESIS[\"\"] var simpleTexts )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(332, 81);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARENTHESIS, ""), root_2);

				DebugLocation(332, 97);
				adaptor.AddChild(root_2, stream_var.NextTree());
				DebugLocation(332, 101);
				adaptor.AddChild(root_2, stream_simpleTexts.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(332, 114);
				adaptor.AddChild(root_1, stream_xEOS.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("simpleCommand", 69);
			LeaveRule("simpleCommand", 69);
			LeaveRule_simpleCommand();
		}
		DebugLocation(332, 119);
		} finally { DebugExitRule(GrammarFileName, "simpleCommand"); }
		return retval;

	}
	// $ANTLR end "simpleCommand"

	partial void EnterRule_simpleTexts();
	partial void LeaveRule_simpleTexts();
	// $ANTLR start "simpleTexts"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:334:1: simpleTexts : simpleText ({...}? => simpleText )* -> ( simpleText )+ ;
	[GrammarRule("simpleTexts")]
	private AstParserRuleReturnScope<object, IToken> simpleTexts()
	{
		EnterRule_simpleTexts();
		EnterRule("simpleTexts", 70);
		TraceIn("simpleTexts", 70);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> simpleText216 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> simpleText217 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_simpleText=new RewriteRuleSubtreeStream(adaptor,"rule simpleText");
		try { DebugEnterRule(GrammarFileName, "simpleTexts");
		DebugLocation(334, 87);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:334:13: ( simpleText ({...}? => simpleText )* -> ( simpleText )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:334:15: simpleText ({...}? => simpleText )*
			{
			DebugLocation(334, 15);
			PushFollow(Follow._simpleText_in_simpleTexts2730);
			simpleText216=simpleText();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_simpleText.Add(simpleText216.Tree);
			DebugLocation(334, 26);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:334:26: ({...}? => simpleText )*
			try { DebugEnterSubRule(64);
			while (true)
			{
				int alt64=2;
				try { DebugEnterDecision(64, false);
				int LA64_1 = input.LA(1);

				if (((LA64_1>=AND && LA64_1<=COLON)||(LA64_1>=COMMAND && LA64_1<=CONTINUE)||(LA64_1>=DEFAULTBLOCK && LA64_1<=END)||(LA64_1>=EQ && LA64_1<=IMG)||(LA64_1>=LDIV && LA64_1<=LINECOMMENT3)||(LA64_1>=LT && LA64_1<=QUESTION)||(LA64_1>=RDIV && LA64_1<=RETURN)||(LA64_1>=SHORTAND && LA64_1<=TIMES)||(LA64_1>=TRY && LA64_1<=VCAT)) && ((Separator_SpacesPrecede())))
				{
					alt64 = 1;
				}


				} finally { DebugExitDecision(64); }
				switch ( alt64 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:334:27: {...}? => simpleText
					{
					DebugLocation(334, 27);
					if (!((Separator_SpacesPrecede())))
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "simpleTexts", "Separator_SpacesPrecede()");
					}
					DebugLocation(334, 58);
					PushFollow(Follow._simpleText_in_simpleTexts2736);
					simpleText217=simpleText();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_simpleText.Add(simpleText217.Tree);

					}
					break;

				default:
					goto loop64;
				}
			}

			loop64:
				;

			} finally { DebugExitSubRule(64); }



			{
			// AST REWRITE
			// elements: simpleText
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 334:71: -> ( simpleText )+
			{
				DebugLocation(334, 74);
				if (!(stream_simpleText.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_simpleText.HasNext )
				{
					DebugLocation(334, 75);
					adaptor.AddChild(root_0, stream_simpleText.NextTree());

				}
				stream_simpleText.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("simpleTexts", 70);
			LeaveRule("simpleTexts", 70);
			LeaveRule_simpleTexts();
		}
		DebugLocation(334, 87);
		} finally { DebugExitRule(GrammarFileName, "simpleTexts"); }
		return retval;

	}
	// $ANTLR end "simpleTexts"

	partial void EnterRule_simpleText();
	partial void LeaveRule_simpleText();
	// $ANTLR start "simpleText"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:336:1: simpleText : (x1= simpleBlock ) ( options {greedy=true; } :{...}? =>x2= simpleBlock )* -> STRING[$x1.start, text] ;
	[GrammarRule("simpleText")]
	private AstParserRuleReturnScope<object, IToken> simpleText()
	{
		EnterRule_simpleText();
		EnterRule("simpleText", 71);
		TraceIn("simpleText", 71);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> x1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x2 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_simpleBlock=new RewriteRuleSubtreeStream(adaptor,"rule simpleBlock");
		string text = null;
		try { DebugEnterRule(GrammarFileName, "simpleText");
		DebugLocation(336, 200);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:337:29: ( (x1= simpleBlock ) ( options {greedy=true; } :{...}? =>x2= simpleBlock )* -> STRING[$x1.start, text] )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:338:2: (x1= simpleBlock ) ( options {greedy=true; } :{...}? =>x2= simpleBlock )*
			{
			DebugLocation(338, 2);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:338:2: (x1= simpleBlock )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:338:2: x1= simpleBlock
			{
			DebugLocation(338, 4);
			PushFollow(Follow._simpleBlock_in_simpleText2764);
			x1=simpleBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_simpleBlock.Add(x1.Tree);
			DebugLocation(338, 17);
			if (state.backtracking == 0)
			{
				text = (x1!=null?((MatlabParser.simpleBlock_return)x1).blockText:default(string));
			}

			}

			DebugLocation(338, 42);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:338:42: ( options {greedy=true; } :{...}? =>x2= simpleBlock )*
			try { DebugEnterSubRule(65);
			while (true)
			{
				int alt65=2;
				try { DebugEnterDecision(65, false);
				int LA65_1 = input.LA(1);

				if ((LA65_1==STRING))
				{
					int LA65_2 = input.LA(2);

					if (((!Separator_SpacesPrecede())))
					{
						alt65 = 1;
					}


				}
				else if (((LA65_1>=AND && LA65_1<=COLON)||(LA65_1>=COMMAND && LA65_1<=CONTINUE)||(LA65_1>=DEFAULTBLOCK && LA65_1<=END)||(LA65_1>=EQ && LA65_1<=IMG)||(LA65_1>=LDIV && LA65_1<=LINECOMMENT3)||(LA65_1>=LT && LA65_1<=QUESTION)||(LA65_1>=RDIV && LA65_1<=RETURN)||(LA65_1>=SHORTAND && LA65_1<=START)||(LA65_1>=STRINGBLOCK && LA65_1<=TIMES)||(LA65_1>=TRY && LA65_1<=VCAT)))
				{
					int LA65_2 = input.LA(2);

					if (((!Separator_SpacesPrecede())))
					{
						alt65 = 1;
					}


				}


				} finally { DebugExitDecision(65); }
				switch ( alt65 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:338:67: {...}? =>x2= simpleBlock
					{
					DebugLocation(338, 67);
					if (!((!Separator_SpacesPrecede())))
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "simpleText", "!Separator_SpacesPrecede()");
					}
					DebugLocation(338, 101);
					PushFollow(Follow._simpleBlock_in_simpleText2783);
					x2=simpleBlock();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_simpleBlock.Add(x2.Tree);
					DebugLocation(338, 114);
					if (state.backtracking == 0)
					{
						text += (x2!=null?((MatlabParser.simpleBlock_return)x2).blockText:default(string));
					}

					}
					break;

				default:
					goto loop65;
				}
			}

			loop65:
				;

			} finally { DebugExitSubRule(65); }

			DebugLocation(338, 141);
			if (state.backtracking == 0)
			{
				text = Text_QuoteString(text);
			}


			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 338:174: -> STRING[$x1.start, text]
			{
				DebugLocation(338, 177);
				adaptor.AddChild(root_0, (object)adaptor.Create(STRING, (x1!=null?((IToken)x1.Start):default(IToken)), text));

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("simpleText", 71);
			LeaveRule("simpleText", 71);
			LeaveRule_simpleText();
		}
		DebugLocation(338, 200);
		} finally { DebugExitRule(GrammarFileName, "simpleText"); }
		return retval;

	}
	// $ANTLR end "simpleText"

	private sealed partial class simpleBlock_return : AstParserRuleReturnScope<object, IToken>
	{
		public string blockText = null;
		public simpleBlock_return(MatlabParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MatlabParser grammar);
	}

	partial void EnterRule_simpleBlock();
	partial void LeaveRule_simpleBlock();
	// $ANTLR start "simpleBlock"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:340:1: simpleBlock returns [string blockText = null] : (x1= STRING |x2=~ ( COMMA | SEMICOLON | EOL | STRING | CTRANS | TRANS | QUOTATION | LPAREN | RPAREN | LSQUARE | RSQUARE | LCURLY | RCURLY ) );
	[GrammarRule("simpleBlock")]
	private MatlabParser.simpleBlock_return simpleBlock()
	{
		EnterRule_simpleBlock();
		EnterRule("simpleBlock", 72);
		TraceIn("simpleBlock", 72);
		MatlabParser.simpleBlock_return retval = new MatlabParser.simpleBlock_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken x1 = default(IToken);
		IToken x2 = default(IToken);

		object x1_tree = default(object);
		object x2_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "simpleBlock");
		DebugLocation(340, 0);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:340:47: (x1= STRING |x2=~ ( COMMA | SEMICOLON | EOL | STRING | CTRANS | TRANS | QUOTATION | LPAREN | RPAREN | LSQUARE | RSQUARE | LCURLY | RCURLY ) )
			int alt66=2;
			try { DebugEnterDecision(66, false);
			int LA66_1 = input.LA(1);

			if ((LA66_1==STRING))
			{
				alt66 = 1;
			}
			else if (((LA66_1>=AND && LA66_1<=COLON)||(LA66_1>=COMMAND && LA66_1<=CONTINUE)||(LA66_1>=DEFAULTBLOCK && LA66_1<=END)||(LA66_1>=EQ && LA66_1<=IMG)||(LA66_1>=LDIV && LA66_1<=LINECOMMENT3)||(LA66_1>=LT && LA66_1<=QUESTION)||(LA66_1>=RDIV && LA66_1<=RETURN)||(LA66_1>=SHORTAND && LA66_1<=START)||(LA66_1>=STRINGBLOCK && LA66_1<=TIMES)||(LA66_1>=TRY && LA66_1<=VCAT)))
			{
				alt66 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 66, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(66); }
			switch (alt66)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:341:3: x1= STRING
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(341, 5);
				x1=(IToken)Match(input,STRING,Follow._STRING_in_simpleBlock2812); if (state.failed) return retval;
				if (state.backtracking == 0) {
				x1_tree = (object)adaptor.Create(x1);
				adaptor.AddChild(root_0, x1_tree);
				}
				DebugLocation(341, 13);
				if (state.backtracking == 0)
				{
					retval.blockText = Text_UnquoteString((x1!=null?x1.Text:default(string)));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:342:3: x2=~ ( COMMA | SEMICOLON | EOL | STRING | CTRANS | TRANS | QUOTATION | LPAREN | RPAREN | LSQUARE | RSQUARE | LCURLY | RCURLY )
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(342, 5);

				x2=(IToken)input.LT(1);
				if ((input.LA(1)>=AND && input.LA(1)<=COLON)||(input.LA(1)>=COMMAND && input.LA(1)<=CONTINUE)||(input.LA(1)>=DEFAULTBLOCK && input.LA(1)<=END)||(input.LA(1)>=EQ && input.LA(1)<=IMG)||(input.LA(1)>=LDIV && input.LA(1)<=LINECOMMENT3)||(input.LA(1)>=LT && input.LA(1)<=QUESTION)||(input.LA(1)>=RDIV && input.LA(1)<=RETURN)||(input.LA(1)>=SHORTAND && input.LA(1)<=START)||(input.LA(1)>=STRINGBLOCK && input.LA(1)<=TIMES)||(input.LA(1)>=TRY && input.LA(1)<=VCAT))
				{
					input.Consume();
					if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(x2));
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(342, 128);
				if (state.backtracking == 0)
				{
					retval.blockText = (x2!=null?x2.Text:default(string));
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("simpleBlock", 72);
			LeaveRule("simpleBlock", 72);
			LeaveRule_simpleBlock();
		}
		DebugLocation(343, 0);
		} finally { DebugExitRule(GrammarFileName, "simpleBlock"); }
		return retval;

	}
	// $ANTLR end "simpleBlock"

	partial void EnterRule_abortCommand();
	partial void LeaveRule_abortCommand();
	// $ANTLR start "abortCommand"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:347:1: abortCommand :{...}? => var -> ABORT ;
	[GrammarRule("abortCommand")]
	private AstParserRuleReturnScope<object, IToken> abortCommand()
	{
		EnterRule_abortCommand();
		EnterRule("abortCommand", 73);
		TraceIn("abortCommand", 73);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> var218 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		try { DebugEnterRule(GrammarFileName, "abortCommand");
		DebugLocation(347, 90);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:347:14: ({...}? => var -> ABORT )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:347:16: {...}? => var
			{
			DebugLocation(347, 16);
			if (!((Command_IsEnabled())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "abortCommand", "Command_IsEnabled()");
			}
			DebugLocation(347, 41);
			if (state.backtracking == 0)
			{
				Command_Mark();
			}
			DebugLocation(347, 59);
			PushFollow(Follow._var_in_abortCommand2892);
			var218=var();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_var.Add(var218.Tree);
			DebugLocation(347, 63);
			if (state.backtracking == 0)
			{
				Command_Abort();
			}


			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 347:82: -> ABORT
			{
				DebugLocation(347, 85);
				adaptor.AddChild(root_0, (object)adaptor.Create(ABORT, "ABORT"));

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("abortCommand", 73);
			LeaveRule("abortCommand", 73);
			LeaveRule_abortCommand();
		}
		DebugLocation(347, 90);
		} finally { DebugExitRule(GrammarFileName, "abortCommand"); }
		return retval;

	}
	// $ANTLR end "abortCommand"

	partial void EnterRule_standardCommand();
	partial void LeaveRule_standardCommand();
	// $ANTLR start "standardCommand"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:351:1: standardCommand : COMMAND standardTexts xEOS -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) ) standardTexts ) xEOS ) ;
	[GrammarRule("standardCommand")]
	private AstParserRuleReturnScope<object, IToken> standardCommand()
	{
		EnterRule_standardCommand();
		EnterRule("standardCommand", 74);
		TraceIn("standardCommand", 74);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMAND219 = default(IToken);
		AstParserRuleReturnScope<object, IToken> standardTexts220 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS221 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMAND219_tree = default(object);
		RewriteRuleITokenStream stream_COMMAND=new RewriteRuleITokenStream(adaptor,"token COMMAND");
		RewriteRuleSubtreeStream stream_standardTexts=new RewriteRuleSubtreeStream(adaptor,"rule standardTexts");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "standardCommand");
		DebugLocation(351, 136);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:351:17: ( COMMAND standardTexts xEOS -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) ) standardTexts ) xEOS ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:351:19: COMMAND standardTexts xEOS
			{
			DebugLocation(351, 19);
			COMMAND219=(IToken)Match(input,COMMAND,Follow._COMMAND_in_standardCommand2909); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COMMAND.Add(COMMAND219);

			DebugLocation(351, 27);
			PushFollow(Follow._standardTexts_in_standardCommand2911);
			standardTexts220=standardTexts();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_standardTexts.Add(standardTexts220.Tree);
			DebugLocation(351, 41);
			PushFollow(Follow._xEOS_in_standardCommand2913);
			xEOS221=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS221.Tree);


			{
			// AST REWRITE
			// elements: standardTexts, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 351:46: -> ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) ) standardTexts ) xEOS )
			{
				DebugLocation(351, 49);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:351:49: ^( ACTION[\"\"] ^( PARENTHESIS[\"\"] ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) ) standardTexts ) xEOS )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(351, 51);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ACTION, ""), root_1);

				DebugLocation(351, 62);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:351:62: ^( PARENTHESIS[\"\"] ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) ) standardTexts )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(351, 64);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARENTHESIS, ""), root_2);

				DebugLocation(351, 80);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:351:80: ^( VAR[\"\"] ^( NAME[\"\"] ID[$COMMAND] ) )
				{
				object root_3 = (object)adaptor.Nil();
				DebugLocation(351, 82);
				root_3 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, ""), root_3);

				DebugLocation(351, 90);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:351:90: ^( NAME[\"\"] ID[$COMMAND] )
				{
				object root_4 = (object)adaptor.Nil();
				DebugLocation(351, 92);
				root_4 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAME, ""), root_4);

				DebugLocation(351, 101);
				adaptor.AddChild(root_4, (object)adaptor.Create(ID, COMMAND219));

				adaptor.AddChild(root_3, root_4);
				}

				adaptor.AddChild(root_2, root_3);
				}
				DebugLocation(351, 116);
				adaptor.AddChild(root_2, stream_standardTexts.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(351, 131);
				adaptor.AddChild(root_1, stream_xEOS.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("standardCommand", 74);
			LeaveRule("standardCommand", 74);
			LeaveRule_standardCommand();
		}
		DebugLocation(351, 136);
		} finally { DebugExitRule(GrammarFileName, "standardCommand"); }
		return retval;

	}
	// $ANTLR end "standardCommand"

	partial void EnterRule_standardTexts();
	partial void LeaveRule_standardTexts();
	// $ANTLR start "standardTexts"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:353:1: standardTexts : standardText ({...}? => standardText )* -> ( standardText )+ ;
	[GrammarRule("standardTexts")]
	private AstParserRuleReturnScope<object, IToken> standardTexts()
	{
		EnterRule_standardTexts();
		EnterRule("standardTexts", 75);
		TraceIn("standardTexts", 75);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> standardText222 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> standardText223 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_standardText=new RewriteRuleSubtreeStream(adaptor,"rule standardText");
		try { DebugEnterRule(GrammarFileName, "standardTexts");
		DebugLocation(353, 95);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:353:15: ( standardText ({...}? => standardText )* -> ( standardText )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:353:17: standardText ({...}? => standardText )*
			{
			DebugLocation(353, 17);
			PushFollow(Follow._standardText_in_standardTexts2951);
			standardText222=standardText();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_standardText.Add(standardText222.Tree);
			DebugLocation(353, 30);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:353:30: ({...}? => standardText )*
			try { DebugEnterSubRule(67);
			while (true)
			{
				int alt67=2;
				try { DebugEnterDecision(67, false);
				int LA67_1 = input.LA(1);

				if ((LA67_1==DEFAULTBLOCK||LA67_1==STRINGBLOCK) && ((Separator_SpacesPrecede())))
				{
					alt67 = 1;
				}


				} finally { DebugExitDecision(67); }
				switch ( alt67 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:353:31: {...}? => standardText
					{
					DebugLocation(353, 31);
					if (!((Separator_SpacesPrecede())))
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "standardTexts", "Separator_SpacesPrecede()");
					}
					DebugLocation(353, 62);
					PushFollow(Follow._standardText_in_standardTexts2957);
					standardText223=standardText();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_standardText.Add(standardText223.Tree);

					}
					break;

				default:
					goto loop67;
				}
			}

			loop67:
				;

			} finally { DebugExitSubRule(67); }



			{
			// AST REWRITE
			// elements: standardText
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 353:77: -> ( standardText )+
			{
				DebugLocation(353, 80);
				if (!(stream_standardText.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_standardText.HasNext )
				{
					DebugLocation(353, 81);
					adaptor.AddChild(root_0, stream_standardText.NextTree());

				}
				stream_standardText.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("standardTexts", 75);
			LeaveRule("standardTexts", 75);
			LeaveRule_standardTexts();
		}
		DebugLocation(353, 95);
		} finally { DebugExitRule(GrammarFileName, "standardTexts"); }
		return retval;

	}
	// $ANTLR end "standardTexts"

	partial void EnterRule_standardText();
	partial void LeaveRule_standardText();
	// $ANTLR start "standardText"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:355:1: standardText : (x1= standardBlock ) ( options {greedy=true; } :{...}? =>x2= standardBlock )* -> STRING[$x1.start, text] ;
	[GrammarRule("standardText")]
	private AstParserRuleReturnScope<object, IToken> standardText()
	{
		EnterRule_standardText();
		EnterRule("standardText", 76);
		TraceIn("standardText", 76);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> x1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x2 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_standardBlock=new RewriteRuleSubtreeStream(adaptor,"rule standardBlock");
		string text = null;
		try { DebugEnterRule(GrammarFileName, "standardText");
		DebugLocation(355, 204);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:356:29: ( (x1= standardBlock ) ( options {greedy=true; } :{...}? =>x2= standardBlock )* -> STRING[$x1.start, text] )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:357:2: (x1= standardBlock ) ( options {greedy=true; } :{...}? =>x2= standardBlock )*
			{
			DebugLocation(357, 2);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:357:2: (x1= standardBlock )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:357:2: x1= standardBlock
			{
			DebugLocation(357, 4);
			PushFollow(Follow._standardBlock_in_standardText2985);
			x1=standardBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_standardBlock.Add(x1.Tree);
			DebugLocation(357, 19);
			if (state.backtracking == 0)
			{
				text = (x1!=null?((MatlabParser.standardBlock_return)x1).blockText:default(string));
			}

			}

			DebugLocation(357, 44);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:357:44: ( options {greedy=true; } :{...}? =>x2= standardBlock )*
			try { DebugEnterSubRule(68);
			while (true)
			{
				int alt68=2;
				try { DebugEnterDecision(68, false);
				int LA68_1 = input.LA(1);

				if ((LA68_1==STRINGBLOCK))
				{
					int LA68_2 = input.LA(2);

					if (((!Separator_SpacesPrecede())))
					{
						alt68 = 1;
					}


				}
				else if ((LA68_1==DEFAULTBLOCK))
				{
					int LA68_2 = input.LA(2);

					if (((!Separator_SpacesPrecede())))
					{
						alt68 = 1;
					}


				}


				} finally { DebugExitDecision(68); }
				switch ( alt68 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:357:69: {...}? =>x2= standardBlock
					{
					DebugLocation(357, 69);
					if (!((!Separator_SpacesPrecede())))
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "standardText", "!Separator_SpacesPrecede()");
					}
					DebugLocation(357, 103);
					PushFollow(Follow._standardBlock_in_standardText3004);
					x2=standardBlock();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_standardBlock.Add(x2.Tree);
					DebugLocation(357, 118);
					if (state.backtracking == 0)
					{
						text += (x2!=null?((MatlabParser.standardBlock_return)x2).blockText:default(string));
					}

					}
					break;

				default:
					goto loop68;
				}
			}

			loop68:
				;

			} finally { DebugExitSubRule(68); }

			DebugLocation(357, 145);
			if (state.backtracking == 0)
			{
				text = Text_QuoteString(text);
			}


			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 357:178: -> STRING[$x1.start, text]
			{
				DebugLocation(357, 181);
				adaptor.AddChild(root_0, (object)adaptor.Create(STRING, (x1!=null?((IToken)x1.Start):default(IToken)), text));

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("standardText", 76);
			LeaveRule("standardText", 76);
			LeaveRule_standardText();
		}
		DebugLocation(357, 204);
		} finally { DebugExitRule(GrammarFileName, "standardText"); }
		return retval;

	}
	// $ANTLR end "standardText"

	private sealed partial class standardBlock_return : AstParserRuleReturnScope<object, IToken>
	{
		public string blockText = null;
		public standardBlock_return(MatlabParser grammar) {OnCreated(grammar);}
		partial void OnCreated(MatlabParser grammar);
	}

	partial void EnterRule_standardBlock();
	partial void LeaveRule_standardBlock();
	// $ANTLR start "standardBlock"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:359:1: standardBlock returns [string blockText = null] : (x1= STRINGBLOCK |x2= DEFAULTBLOCK );
	[GrammarRule("standardBlock")]
	private MatlabParser.standardBlock_return standardBlock()
	{
		EnterRule_standardBlock();
		EnterRule("standardBlock", 77);
		TraceIn("standardBlock", 77);
		MatlabParser.standardBlock_return retval = new MatlabParser.standardBlock_return(this);
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken x1 = default(IToken);
		IToken x2 = default(IToken);

		object x1_tree = default(object);
		object x2_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "standardBlock");
		DebugLocation(359, 1);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:359:49: (x1= STRINGBLOCK |x2= DEFAULTBLOCK )
			int alt69=2;
			try { DebugEnterDecision(69, false);
			int LA69_1 = input.LA(1);

			if ((LA69_1==STRINGBLOCK))
			{
				alt69 = 1;
			}
			else if ((LA69_1==DEFAULTBLOCK))
			{
				alt69 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 69, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(69); }
			switch (alt69)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:360:4: x1= STRINGBLOCK
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(360, 6);
				x1=(IToken)Match(input,STRINGBLOCK,Follow._STRINGBLOCK_in_standardBlock3034); if (state.failed) return retval;
				if (state.backtracking == 0) {
				x1_tree = (object)adaptor.Create(x1);
				adaptor.AddChild(root_0, x1_tree);
				}
				DebugLocation(360, 19);
				if (state.backtracking == 0)
				{
					retval.blockText = Text_UnquoteString((x1!=null?x1.Text:default(string)));
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:361:4: x2= DEFAULTBLOCK
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(361, 6);
				x2=(IToken)Match(input,DEFAULTBLOCK,Follow._DEFAULTBLOCK_in_standardBlock3043); if (state.failed) return retval;
				if (state.backtracking == 0) {
				x2_tree = (object)adaptor.Create(x2);
				adaptor.AddChild(root_0, x2_tree);
				}
				DebugLocation(361, 20);
				if (state.backtracking == 0)
				{
					retval.blockText = (x2!=null?x2.Text:default(string));
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("standardBlock", 77);
			LeaveRule("standardBlock", 77);
			LeaveRule_standardBlock();
		}
		DebugLocation(362, 1);
		} finally { DebugExitRule(GrammarFileName, "standardBlock"); }
		return retval;

	}
	// $ANTLR end "standardBlock"

	partial void EnterRule_bang();
	partial void LeaveRule_bang();
	// $ANTLR start "bang"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:366:1: bang : EXCLAMATION LINE xEOL -> ^( EXCLAMATION STRING[$LINE, line] xEOL ) ;
	[GrammarRule("bang")]
	private AstParserRuleReturnScope<object, IToken> bang()
	{
		EnterRule_bang();
		EnterRule("bang", 78);
		TraceIn("bang", 78);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EXCLAMATION224 = default(IToken);
		IToken LINE225 = default(IToken);
		AstParserRuleReturnScope<object, IToken> xEOL226 = default(AstParserRuleReturnScope<object, IToken>);

		object EXCLAMATION224_tree = default(object);
		object LINE225_tree = default(object);
		RewriteRuleITokenStream stream_EXCLAMATION=new RewriteRuleITokenStream(adaptor,"token EXCLAMATION");
		RewriteRuleITokenStream stream_LINE=new RewriteRuleITokenStream(adaptor,"token LINE");
		RewriteRuleSubtreeStream stream_xEOL=new RewriteRuleSubtreeStream(adaptor,"rule xEOL");
		string line = null;
		try { DebugEnterRule(GrammarFileName, "bang");
		DebugLocation(366, 104);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:367:29: ( EXCLAMATION LINE xEOL -> ^( EXCLAMATION STRING[$LINE, line] xEOL ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:368:1: EXCLAMATION LINE xEOL
			{
			DebugLocation(368, 1);
			EXCLAMATION224=(IToken)Match(input,EXCLAMATION,Follow._EXCLAMATION_in_bang3064); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EXCLAMATION.Add(EXCLAMATION224);

			DebugLocation(368, 13);
			LINE225=(IToken)Match(input,LINE,Follow._LINE_in_bang3066); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LINE.Add(LINE225);

			DebugLocation(368, 18);
			if (state.backtracking == 0)
			{
				line = Text_QuoteString((LINE225!=null?LINE225.Text:default(string)));
			}
			DebugLocation(368, 57);
			PushFollow(Follow._xEOL_in_bang3070);
			xEOL226=xEOL();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOL.Add(xEOL226.Tree);


			{
			// AST REWRITE
			// elements: EXCLAMATION, xEOL
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 368:62: -> ^( EXCLAMATION STRING[$LINE, line] xEOL )
			{
				DebugLocation(368, 65);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:368:65: ^( EXCLAMATION STRING[$LINE, line] xEOL )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(368, 67);
				root_1 = (object)adaptor.BecomeRoot(stream_EXCLAMATION.NextNode(), root_1);

				DebugLocation(368, 79);
				adaptor.AddChild(root_1, (object)adaptor.Create(STRING, LINE225, line));
				DebugLocation(368, 99);
				adaptor.AddChild(root_1, stream_xEOL.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bang", 78);
			LeaveRule("bang", 78);
			LeaveRule_bang();
		}
		DebugLocation(368, 104);
		} finally { DebugExitRule(GrammarFileName, "bang"); }
		return retval;

	}
	// $ANTLR end "bang"

	partial void EnterRule_break();
	partial void LeaveRule_break();
	// $ANTLR start "break"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:372:1: break : BREAK xEOS -> ^( BREAK xEOS ) ;
	[GrammarRule("break")]
	private AstParserRuleReturnScope<object, IToken> @break()
	{
		EnterRule_break();
		EnterRule("break", 79);
		TraceIn("break", 79);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken BREAK227 = default(IToken);
		AstParserRuleReturnScope<object, IToken> xEOS228 = default(AstParserRuleReturnScope<object, IToken>);

		object BREAK227_tree = default(object);
		RewriteRuleITokenStream stream_BREAK=new RewriteRuleITokenStream(adaptor,"token BREAK");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "break");
		DebugLocation(372, 36);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:372:7: ( BREAK xEOS -> ^( BREAK xEOS ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:372:9: BREAK xEOS
			{
			DebugLocation(372, 9);
			BREAK227=(IToken)Match(input,BREAK,Follow._BREAK_in_break3092); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_BREAK.Add(BREAK227);

			DebugLocation(372, 15);
			PushFollow(Follow._xEOS_in_break3094);
			xEOS228=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS228.Tree);


			{
			// AST REWRITE
			// elements: BREAK, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 372:20: -> ^( BREAK xEOS )
			{
				DebugLocation(372, 23);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:372:23: ^( BREAK xEOS )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(372, 25);
				root_1 = (object)adaptor.BecomeRoot(stream_BREAK.NextNode(), root_1);

				DebugLocation(372, 31);
				adaptor.AddChild(root_1, stream_xEOS.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("break", 79);
			LeaveRule("break", 79);
			LeaveRule_break();
		}
		DebugLocation(372, 36);
		} finally { DebugExitRule(GrammarFileName, "break"); }
		return retval;

	}
	// $ANTLR end "break"

	partial void EnterRule_continue();
	partial void LeaveRule_continue();
	// $ANTLR start "continue"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:376:1: continue : CONTINUE xEOS -> ^( CONTINUE xEOS ) ;
	[GrammarRule("continue")]
	private AstParserRuleReturnScope<object, IToken> @continue()
	{
		EnterRule_continue();
		EnterRule("continue", 80);
		TraceIn("continue", 80);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CONTINUE229 = default(IToken);
		AstParserRuleReturnScope<object, IToken> xEOS230 = default(AstParserRuleReturnScope<object, IToken>);

		object CONTINUE229_tree = default(object);
		RewriteRuleITokenStream stream_CONTINUE=new RewriteRuleITokenStream(adaptor,"token CONTINUE");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "continue");
		DebugLocation(376, 45);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:376:10: ( CONTINUE xEOS -> ^( CONTINUE xEOS ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:376:12: CONTINUE xEOS
			{
			DebugLocation(376, 12);
			CONTINUE229=(IToken)Match(input,CONTINUE,Follow._CONTINUE_in_continue3113); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CONTINUE.Add(CONTINUE229);

			DebugLocation(376, 21);
			PushFollow(Follow._xEOS_in_continue3115);
			xEOS230=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS230.Tree);


			{
			// AST REWRITE
			// elements: CONTINUE, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 376:26: -> ^( CONTINUE xEOS )
			{
				DebugLocation(376, 29);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:376:29: ^( CONTINUE xEOS )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(376, 31);
				root_1 = (object)adaptor.BecomeRoot(stream_CONTINUE.NextNode(), root_1);

				DebugLocation(376, 40);
				adaptor.AddChild(root_1, stream_xEOS.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("continue", 80);
			LeaveRule("continue", 80);
			LeaveRule_continue();
		}
		DebugLocation(376, 45);
		} finally { DebugExitRule(GrammarFileName, "continue"); }
		return retval;

	}
	// $ANTLR end "continue"

	partial void EnterRule_for();
	partial void LeaveRule_for();
	// $ANTLR start "for"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:380:1: for : FOR forHead statements END xEOS -> ^( FOR forHead ( statements )? xEOS ) ;
	[GrammarRule("for")]
	private AstParserRuleReturnScope<object, IToken> @for()
	{
		EnterRule_for();
		EnterRule("for", 81);
		TraceIn("for", 81);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FOR231 = default(IToken);
		IToken END234 = default(IToken);
		AstParserRuleReturnScope<object, IToken> forHead232 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statements233 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS235 = default(AstParserRuleReturnScope<object, IToken>);

		object FOR231_tree = default(object);
		object END234_tree = default(object);
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_forHead=new RewriteRuleSubtreeStream(adaptor,"rule forHead");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "for");
		DebugLocation(380, 75);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:380:5: ( FOR forHead statements END xEOS -> ^( FOR forHead ( statements )? xEOS ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:380:7: FOR forHead statements END xEOS
			{
			DebugLocation(380, 7);
			FOR231=(IToken)Match(input,FOR,Follow._FOR_in_for3134); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FOR.Add(FOR231);

			DebugLocation(380, 11);
			PushFollow(Follow._forHead_in_for3136);
			forHead232=forHead();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_forHead.Add(forHead232.Tree);
			DebugLocation(380, 19);
			PushFollow(Follow._statements_in_for3138);
			statements233=statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statements.Add(statements233.Tree);
			DebugLocation(380, 30);
			END234=(IToken)Match(input,END,Follow._END_in_for3140); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END234);

			DebugLocation(380, 34);
			PushFollow(Follow._xEOS_in_for3142);
			xEOS235=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS235.Tree);


			{
			// AST REWRITE
			// elements: FOR, forHead, statements, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 380:39: -> ^( FOR forHead ( statements )? xEOS )
			{
				DebugLocation(380, 42);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:380:42: ^( FOR forHead ( statements )? xEOS )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(380, 44);
				root_1 = (object)adaptor.BecomeRoot(stream_FOR.NextNode(), root_1);

				DebugLocation(380, 48);
				adaptor.AddChild(root_1, stream_forHead.NextTree());
				DebugLocation(380, 56);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:380:56: ( statements )?
				if (stream_statements.HasNext)
				{
					DebugLocation(380, 57);
					adaptor.AddChild(root_1, stream_statements.NextTree());

				}
				stream_statements.Reset();
				DebugLocation(380, 70);
				adaptor.AddChild(root_1, stream_xEOS.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("for", 81);
			LeaveRule("for", 81);
			LeaveRule_for();
		}
		DebugLocation(380, 75);
		} finally { DebugExitRule(GrammarFileName, "for"); }
		return retval;

	}
	// $ANTLR end "for"

	partial void EnterRule_forHead();
	partial void LeaveRule_forHead();
	// $ANTLR start "forHead"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:382:1: forHead : ( var ASSIGN expression -> var expression | LPAREN var ASSIGN expression RPAREN -> var expression );
	[GrammarRule("forHead")]
	private AstParserRuleReturnScope<object, IToken> forHead()
	{
		EnterRule_forHead();
		EnterRule("forHead", 82);
		TraceIn("forHead", 82);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ASSIGN237 = default(IToken);
		IToken LPAREN239 = default(IToken);
		IToken ASSIGN241 = default(IToken);
		IToken RPAREN243 = default(IToken);
		AstParserRuleReturnScope<object, IToken> var236 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression238 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> var240 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression242 = default(AstParserRuleReturnScope<object, IToken>);

		object ASSIGN237_tree = default(object);
		object LPAREN239_tree = default(object);
		object ASSIGN241_tree = default(object);
		object RPAREN243_tree = default(object);
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "forHead");
		DebugLocation(382, 2);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:382:9: ( var ASSIGN expression -> var expression | LPAREN var ASSIGN expression RPAREN -> var expression )
			int alt70=2;
			try { DebugEnterDecision(70, false);
			int LA70_1 = input.LA(1);

			if ((LA70_1==ID))
			{
				alt70 = 1;
			}
			else if ((LA70_1==LPAREN))
			{
				alt70 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 70, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(70); }
			switch (alt70)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:382:11: var ASSIGN expression
				{
				DebugLocation(382, 11);
				PushFollow(Follow._var_in_forHead3166);
				var236=var();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_var.Add(var236.Tree);
				DebugLocation(382, 15);
				ASSIGN237=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_forHead3168); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN237);

				DebugLocation(382, 22);
				PushFollow(Follow._expression_in_forHead3170);
				expression238=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression238.Tree);


				{
				// AST REWRITE
				// elements: var, expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 382:33: -> var expression
				{
					DebugLocation(382, 36);
					adaptor.AddChild(root_0, stream_var.NextTree());
					DebugLocation(382, 40);
					adaptor.AddChild(root_0, stream_expression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:383:5: LPAREN var ASSIGN expression RPAREN
				{
				DebugLocation(383, 5);
				LPAREN239=(IToken)Match(input,LPAREN,Follow._LPAREN_in_forHead3182); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN239);

				DebugLocation(383, 12);
				PushFollow(Follow._var_in_forHead3184);
				var240=var();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_var.Add(var240.Tree);
				DebugLocation(383, 16);
				ASSIGN241=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_forHead3186); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN241);

				DebugLocation(383, 23);
				PushFollow(Follow._expression_in_forHead3188);
				expression242=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression242.Tree);
				DebugLocation(383, 34);
				RPAREN243=(IToken)Match(input,RPAREN,Follow._RPAREN_in_forHead3190); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN243);



				{
				// AST REWRITE
				// elements: var, expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 383:41: -> var expression
				{
					DebugLocation(383, 44);
					adaptor.AddChild(root_0, stream_var.NextTree());
					DebugLocation(383, 48);
					adaptor.AddChild(root_0, stream_expression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forHead", 82);
			LeaveRule("forHead", 82);
			LeaveRule_forHead();
		}
		DebugLocation(384, 2);
		} finally { DebugExitRule(GrammarFileName, "forHead"); }
		return retval;

	}
	// $ANTLR end "forHead"

	partial void EnterRule_global();
	partial void LeaveRule_global();
	// $ANTLR start "global"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:388:1: global : GLOBAL ( var )+ xEOS -> ^( GLOBAL ( var )+ xEOS ) ;
	[GrammarRule("global")]
	private AstParserRuleReturnScope<object, IToken> global()
	{
		EnterRule_global();
		EnterRule("global", 83);
		TraceIn("global", 83);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken GLOBAL244 = default(IToken);
		AstParserRuleReturnScope<object, IToken> var245 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS246 = default(AstParserRuleReturnScope<object, IToken>);

		object GLOBAL244_tree = default(object);
		RewriteRuleITokenStream stream_GLOBAL=new RewriteRuleITokenStream(adaptor,"token GLOBAL");
		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "global");
		DebugLocation(388, 53);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:388:8: ( GLOBAL ( var )+ xEOS -> ^( GLOBAL ( var )+ xEOS ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:388:10: GLOBAL ( var )+ xEOS
			{
			DebugLocation(388, 10);
			GLOBAL244=(IToken)Match(input,GLOBAL,Follow._GLOBAL_in_global3209); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_GLOBAL.Add(GLOBAL244);

			DebugLocation(388, 17);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:388:17: ( var )+
			int cnt71=0;
			try { DebugEnterSubRule(71);
			while (true)
			{
				int alt71=2;
				try { DebugEnterDecision(71, false);
				int LA71_1 = input.LA(1);

				if ((LA71_1==ID))
				{
					alt71 = 1;
				}


				} finally { DebugExitDecision(71); }
				switch (alt71)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:388:18: var
					{
					DebugLocation(388, 18);
					PushFollow(Follow._var_in_global3212);
					var245=var();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_var.Add(var245.Tree);

					}
					break;

				default:
					if (cnt71 >= 1)
						goto loop71;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee71 = new EarlyExitException( 71, input );
					DebugRecognitionException(eee71);
					throw eee71;
				}
				cnt71++;
			}
			loop71:
				;

			} finally { DebugExitSubRule(71); }

			DebugLocation(388, 24);
			PushFollow(Follow._xEOS_in_global3216);
			xEOS246=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS246.Tree);


			{
			// AST REWRITE
			// elements: GLOBAL, var, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 388:29: -> ^( GLOBAL ( var )+ xEOS )
			{
				DebugLocation(388, 32);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:388:32: ^( GLOBAL ( var )+ xEOS )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(388, 34);
				root_1 = (object)adaptor.BecomeRoot(stream_GLOBAL.NextNode(), root_1);

				DebugLocation(388, 41);
				if (!(stream_var.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_var.HasNext )
				{
					DebugLocation(388, 42);
					adaptor.AddChild(root_1, stream_var.NextTree());

				}
				stream_var.Reset();
				DebugLocation(388, 48);
				adaptor.AddChild(root_1, stream_xEOS.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("global", 83);
			LeaveRule("global", 83);
			LeaveRule_global();
		}
		DebugLocation(388, 53);
		} finally { DebugExitRule(GrammarFileName, "global"); }
		return retval;

	}
	// $ANTLR end "global"

	partial void EnterRule_if();
	partial void LeaveRule_if();
	// $ANTLR start "if"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:392:1: if : ifPart ( elseIfPart )* ( elsePart )? END xEOS -> ^( IFELSE[$ifPart.start] ifPart ( elseIfPart )* ( elsePart )? xEOS ) ;
	[GrammarRule("if")]
	private AstParserRuleReturnScope<object, IToken> @if()
	{
		EnterRule_if();
		EnterRule("if", 84);
		TraceIn("if", 84);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken END250 = default(IToken);
		AstParserRuleReturnScope<object, IToken> ifPart247 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> elseIfPart248 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> elsePart249 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS251 = default(AstParserRuleReturnScope<object, IToken>);

		object END250_tree = default(object);
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_ifPart=new RewriteRuleSubtreeStream(adaptor,"rule ifPart");
		RewriteRuleSubtreeStream stream_elseIfPart=new RewriteRuleSubtreeStream(adaptor,"rule elseIfPart");
		RewriteRuleSubtreeStream stream_elsePart=new RewriteRuleSubtreeStream(adaptor,"rule elsePart");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "if");
		DebugLocation(392, 113);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:392:4: ( ifPart ( elseIfPart )* ( elsePart )? END xEOS -> ^( IFELSE[$ifPart.start] ifPart ( elseIfPart )* ( elsePart )? xEOS ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:392:6: ifPart ( elseIfPart )* ( elsePart )? END xEOS
			{
			DebugLocation(392, 6);
			PushFollow(Follow._ifPart_in_if3240);
			ifPart247=ifPart();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ifPart.Add(ifPart247.Tree);
			DebugLocation(392, 13);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:392:13: ( elseIfPart )*
			try { DebugEnterSubRule(72);
			while (true)
			{
				int alt72=2;
				try { DebugEnterDecision(72, false);
				int LA72_1 = input.LA(1);

				if ((LA72_1==ELSEIF))
				{
					alt72 = 1;
				}


				} finally { DebugExitDecision(72); }
				switch ( alt72 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:392:14: elseIfPart
					{
					DebugLocation(392, 14);
					PushFollow(Follow._elseIfPart_in_if3243);
					elseIfPart248=elseIfPart();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_elseIfPart.Add(elseIfPart248.Tree);

					}
					break;

				default:
					goto loop72;
				}
			}

			loop72:
				;

			} finally { DebugExitSubRule(72); }

			DebugLocation(392, 27);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:392:27: ( elsePart )?
			int alt73=2;
			try { DebugEnterSubRule(73);
			try { DebugEnterDecision(73, false);
			int LA73_1 = input.LA(1);

			if ((LA73_1==ELSE))
			{
				alt73 = 1;
			}
			} finally { DebugExitDecision(73); }
			switch (alt73)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:392:28: elsePart
				{
				DebugLocation(392, 28);
				PushFollow(Follow._elsePart_in_if3248);
				elsePart249=elsePart();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_elsePart.Add(elsePart249.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(73); }

			DebugLocation(392, 39);
			END250=(IToken)Match(input,END,Follow._END_in_if3252); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END250);

			DebugLocation(392, 43);
			PushFollow(Follow._xEOS_in_if3254);
			xEOS251=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS251.Tree);


			{
			// AST REWRITE
			// elements: ifPart, elseIfPart, elsePart, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 392:48: -> ^( IFELSE[$ifPart.start] ifPart ( elseIfPart )* ( elsePart )? xEOS )
			{
				DebugLocation(392, 51);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:392:51: ^( IFELSE[$ifPart.start] ifPart ( elseIfPart )* ( elsePart )? xEOS )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(392, 53);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IFELSE, (ifPart247!=null?((IToken)ifPart247.Start):default(IToken))), root_1);

				DebugLocation(392, 75);
				adaptor.AddChild(root_1, stream_ifPart.NextTree());
				DebugLocation(392, 82);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:392:82: ( elseIfPart )*
				while ( stream_elseIfPart.HasNext )
				{
					DebugLocation(392, 83);
					adaptor.AddChild(root_1, stream_elseIfPart.NextTree());

				}
				stream_elseIfPart.Reset();
				DebugLocation(392, 96);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:392:96: ( elsePart )?
				if (stream_elsePart.HasNext)
				{
					DebugLocation(392, 97);
					adaptor.AddChild(root_1, stream_elsePart.NextTree());

				}
				stream_elsePart.Reset();
				DebugLocation(392, 108);
				adaptor.AddChild(root_1, stream_xEOS.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("if", 84);
			LeaveRule("if", 84);
			LeaveRule_if();
		}
		DebugLocation(392, 113);
		} finally { DebugExitRule(GrammarFileName, "if"); }
		return retval;

	}
	// $ANTLR end "if"

	partial void EnterRule_ifPart();
	partial void LeaveRule_ifPart();
	// $ANTLR start "ifPart"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:394:1: ifPart : IF expression statements -> ^( IF expression ( statements )? ) ;
	[GrammarRule("ifPart")]
	private AstParserRuleReturnScope<object, IToken> ifPart()
	{
		EnterRule_ifPart();
		EnterRule("ifPart", 85);
		TraceIn("ifPart", 85);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IF252 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression253 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statements254 = default(AstParserRuleReturnScope<object, IToken>);

		object IF252_tree = default(object);
		RewriteRuleITokenStream stream_IF=new RewriteRuleITokenStream(adaptor,"token IF");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		try { DebugEnterRule(GrammarFileName, "ifPart");
		DebugLocation(394, 68);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:394:8: ( IF expression statements -> ^( IF expression ( statements )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:394:10: IF expression statements
			{
			DebugLocation(394, 10);
			IF252=(IToken)Match(input,IF,Follow._IF_in_ifPart3284); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IF.Add(IF252);

			DebugLocation(394, 13);
			PushFollow(Follow._expression_in_ifPart3286);
			expression253=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression253.Tree);
			DebugLocation(394, 24);
			PushFollow(Follow._statements_in_ifPart3288);
			statements254=statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statements.Add(statements254.Tree);


			{
			// AST REWRITE
			// elements: IF, expression, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 394:35: -> ^( IF expression ( statements )? )
			{
				DebugLocation(394, 38);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:394:38: ^( IF expression ( statements )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(394, 40);
				root_1 = (object)adaptor.BecomeRoot(stream_IF.NextNode(), root_1);

				DebugLocation(394, 43);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(394, 54);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:394:54: ( statements )?
				if (stream_statements.HasNext)
				{
					DebugLocation(394, 55);
					adaptor.AddChild(root_1, stream_statements.NextTree());

				}
				stream_statements.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifPart", 85);
			LeaveRule("ifPart", 85);
			LeaveRule_ifPart();
		}
		DebugLocation(394, 68);
		} finally { DebugExitRule(GrammarFileName, "ifPart"); }
		return retval;

	}
	// $ANTLR end "ifPart"

	partial void EnterRule_elseIfPart();
	partial void LeaveRule_elseIfPart();
	// $ANTLR start "elseIfPart"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:396:1: elseIfPart : ELSEIF expression statements -> ^( ELSEIF expression ( statements )? ) ;
	[GrammarRule("elseIfPart")]
	private AstParserRuleReturnScope<object, IToken> elseIfPart()
	{
		EnterRule_elseIfPart();
		EnterRule("elseIfPart", 86);
		TraceIn("elseIfPart", 86);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ELSEIF255 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression256 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statements257 = default(AstParserRuleReturnScope<object, IToken>);

		object ELSEIF255_tree = default(object);
		RewriteRuleITokenStream stream_ELSEIF=new RewriteRuleITokenStream(adaptor,"token ELSEIF");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		try { DebugEnterRule(GrammarFileName, "elseIfPart");
		DebugLocation(396, 80);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:396:12: ( ELSEIF expression statements -> ^( ELSEIF expression ( statements )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:396:14: ELSEIF expression statements
			{
			DebugLocation(396, 14);
			ELSEIF255=(IToken)Match(input,ELSEIF,Follow._ELSEIF_in_elseIfPart3310); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ELSEIF.Add(ELSEIF255);

			DebugLocation(396, 21);
			PushFollow(Follow._expression_in_elseIfPart3312);
			expression256=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression256.Tree);
			DebugLocation(396, 32);
			PushFollow(Follow._statements_in_elseIfPart3314);
			statements257=statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statements.Add(statements257.Tree);


			{
			// AST REWRITE
			// elements: ELSEIF, expression, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 396:43: -> ^( ELSEIF expression ( statements )? )
			{
				DebugLocation(396, 46);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:396:46: ^( ELSEIF expression ( statements )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(396, 48);
				root_1 = (object)adaptor.BecomeRoot(stream_ELSEIF.NextNode(), root_1);

				DebugLocation(396, 55);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(396, 66);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:396:66: ( statements )?
				if (stream_statements.HasNext)
				{
					DebugLocation(396, 67);
					adaptor.AddChild(root_1, stream_statements.NextTree());

				}
				stream_statements.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elseIfPart", 86);
			LeaveRule("elseIfPart", 86);
			LeaveRule_elseIfPart();
		}
		DebugLocation(396, 80);
		} finally { DebugExitRule(GrammarFileName, "elseIfPart"); }
		return retval;

	}
	// $ANTLR end "elseIfPart"

	partial void EnterRule_elsePart();
	partial void LeaveRule_elsePart();
	// $ANTLR start "elsePart"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:398:1: elsePart : ELSE statements -> ^( ELSE ( statements )? ) ;
	[GrammarRule("elsePart")]
	private AstParserRuleReturnScope<object, IToken> elsePart()
	{
		EnterRule_elsePart();
		EnterRule("elsePart", 87);
		TraceIn("elsePart", 87);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ELSE258 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statements259 = default(AstParserRuleReturnScope<object, IToken>);

		object ELSE258_tree = default(object);
		RewriteRuleITokenStream stream_ELSE=new RewriteRuleITokenStream(adaptor,"token ELSE");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		try { DebugEnterRule(GrammarFileName, "elsePart");
		DebugLocation(398, 52);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:398:10: ( ELSE statements -> ^( ELSE ( statements )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:398:12: ELSE statements
			{
			DebugLocation(398, 12);
			ELSE258=(IToken)Match(input,ELSE,Follow._ELSE_in_elsePart3336); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ELSE.Add(ELSE258);

			DebugLocation(398, 17);
			PushFollow(Follow._statements_in_elsePart3338);
			statements259=statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statements.Add(statements259.Tree);


			{
			// AST REWRITE
			// elements: ELSE, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 398:28: -> ^( ELSE ( statements )? )
			{
				DebugLocation(398, 31);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:398:31: ^( ELSE ( statements )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(398, 33);
				root_1 = (object)adaptor.BecomeRoot(stream_ELSE.NextNode(), root_1);

				DebugLocation(398, 38);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:398:38: ( statements )?
				if (stream_statements.HasNext)
				{
					DebugLocation(398, 39);
					adaptor.AddChild(root_1, stream_statements.NextTree());

				}
				stream_statements.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elsePart", 87);
			LeaveRule("elsePart", 87);
			LeaveRule_elsePart();
		}
		DebugLocation(398, 52);
		} finally { DebugExitRule(GrammarFileName, "elsePart"); }
		return retval;

	}
	// $ANTLR end "elsePart"

	partial void EnterRule_parfor();
	partial void LeaveRule_parfor();
	// $ANTLR start "parfor"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:402:1: parfor : PARFOR parforHead statements END xEOS -> ^( PARFOR parforHead ( statements )? xEOS ) ;
	[GrammarRule("parfor")]
	private AstParserRuleReturnScope<object, IToken> parfor()
	{
		EnterRule_parfor();
		EnterRule("parfor", 88);
		TraceIn("parfor", 88);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken PARFOR260 = default(IToken);
		IToken END263 = default(IToken);
		AstParserRuleReturnScope<object, IToken> parforHead261 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statements262 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS264 = default(AstParserRuleReturnScope<object, IToken>);

		object PARFOR260_tree = default(object);
		object END263_tree = default(object);
		RewriteRuleITokenStream stream_PARFOR=new RewriteRuleITokenStream(adaptor,"token PARFOR");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_parforHead=new RewriteRuleSubtreeStream(adaptor,"rule parforHead");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "parfor");
		DebugLocation(402, 90);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:402:8: ( PARFOR parforHead statements END xEOS -> ^( PARFOR parforHead ( statements )? xEOS ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:402:10: PARFOR parforHead statements END xEOS
			{
			DebugLocation(402, 10);
			PARFOR260=(IToken)Match(input,PARFOR,Follow._PARFOR_in_parfor3360); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PARFOR.Add(PARFOR260);

			DebugLocation(402, 17);
			PushFollow(Follow._parforHead_in_parfor3362);
			parforHead261=parforHead();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_parforHead.Add(parforHead261.Tree);
			DebugLocation(402, 28);
			PushFollow(Follow._statements_in_parfor3364);
			statements262=statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statements.Add(statements262.Tree);
			DebugLocation(402, 39);
			END263=(IToken)Match(input,END,Follow._END_in_parfor3366); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END263);

			DebugLocation(402, 43);
			PushFollow(Follow._xEOS_in_parfor3368);
			xEOS264=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS264.Tree);


			{
			// AST REWRITE
			// elements: PARFOR, parforHead, statements, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 402:48: -> ^( PARFOR parforHead ( statements )? xEOS )
			{
				DebugLocation(402, 51);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:402:51: ^( PARFOR parforHead ( statements )? xEOS )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(402, 53);
				root_1 = (object)adaptor.BecomeRoot(stream_PARFOR.NextNode(), root_1);

				DebugLocation(402, 60);
				adaptor.AddChild(root_1, stream_parforHead.NextTree());
				DebugLocation(402, 71);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:402:71: ( statements )?
				if (stream_statements.HasNext)
				{
					DebugLocation(402, 72);
					adaptor.AddChild(root_1, stream_statements.NextTree());

				}
				stream_statements.Reset();
				DebugLocation(402, 85);
				adaptor.AddChild(root_1, stream_xEOS.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parfor", 88);
			LeaveRule("parfor", 88);
			LeaveRule_parfor();
		}
		DebugLocation(402, 90);
		} finally { DebugExitRule(GrammarFileName, "parfor"); }
		return retval;

	}
	// $ANTLR end "parfor"

	partial void EnterRule_parforHead();
	partial void LeaveRule_parforHead();
	// $ANTLR start "parforHead"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:404:1: parforHead : ( ( LPAREN var ASSIGN expression COMMA )=> LPAREN var ASSIGN expression COMMA expression RPAREN -> var ( expression )+ | LPAREN var ASSIGN expression RPAREN -> var expression | var ASSIGN expression -> var expression );
	[GrammarRule("parforHead")]
	private AstParserRuleReturnScope<object, IToken> parforHead()
	{
		EnterRule_parforHead();
		EnterRule("parforHead", 89);
		TraceIn("parforHead", 89);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN265 = default(IToken);
		IToken ASSIGN267 = default(IToken);
		IToken COMMA269 = default(IToken);
		IToken RPAREN271 = default(IToken);
		IToken LPAREN272 = default(IToken);
		IToken ASSIGN274 = default(IToken);
		IToken RPAREN276 = default(IToken);
		IToken ASSIGN278 = default(IToken);
		AstParserRuleReturnScope<object, IToken> var266 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression268 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression270 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> var273 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression275 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> var277 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression279 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN265_tree = default(object);
		object ASSIGN267_tree = default(object);
		object COMMA269_tree = default(object);
		object RPAREN271_tree = default(object);
		object LPAREN272_tree = default(object);
		object ASSIGN274_tree = default(object);
		object RPAREN276_tree = default(object);
		object ASSIGN278_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "parforHead");
		DebugLocation(404, 5);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:404:12: ( ( LPAREN var ASSIGN expression COMMA )=> LPAREN var ASSIGN expression COMMA expression RPAREN -> var ( expression )+ | LPAREN var ASSIGN expression RPAREN -> var expression | var ASSIGN expression -> var expression )
			int alt74=3;
			try { DebugEnterDecision(74, false);
			int LA74_1 = input.LA(1);

			if ((LA74_1==LPAREN))
			{
				int LA74_2 = input.LA(2);

				if ((EvaluatePredicate(synpred6_MatlabParser_fragment)))
				{
					alt74 = 1;
				}
				else if ((true))
				{
					alt74 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 74, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA74_1==ID))
			{
				alt74 = 3;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 74, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(74); }
			switch (alt74)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:404:14: ( LPAREN var ASSIGN expression COMMA )=> LPAREN var ASSIGN expression COMMA expression RPAREN
				{
				DebugLocation(404, 53);
				LPAREN265=(IToken)Match(input,LPAREN,Follow._LPAREN_in_parforHead3405); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN265);

				DebugLocation(404, 60);
				PushFollow(Follow._var_in_parforHead3407);
				var266=var();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_var.Add(var266.Tree);
				DebugLocation(404, 64);
				ASSIGN267=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_parforHead3409); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN267);

				DebugLocation(404, 71);
				PushFollow(Follow._expression_in_parforHead3411);
				expression268=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression268.Tree);
				DebugLocation(404, 82);
				COMMA269=(IToken)Match(input,COMMA,Follow._COMMA_in_parforHead3413); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COMMA.Add(COMMA269);

				DebugLocation(404, 88);
				PushFollow(Follow._expression_in_parforHead3415);
				expression270=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression270.Tree);
				DebugLocation(404, 99);
				RPAREN271=(IToken)Match(input,RPAREN,Follow._RPAREN_in_parforHead3417); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN271);



				{
				// AST REWRITE
				// elements: var, expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 404:106: -> var ( expression )+
				{
					DebugLocation(404, 109);
					adaptor.AddChild(root_0, stream_var.NextTree());
					DebugLocation(404, 113);
					if (!(stream_expression.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_expression.HasNext )
					{
						DebugLocation(404, 114);
						adaptor.AddChild(root_0, stream_expression.NextTree());

					}
					stream_expression.Reset();

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:405:8: LPAREN var ASSIGN expression RPAREN
				{
				DebugLocation(405, 8);
				LPAREN272=(IToken)Match(input,LPAREN,Follow._LPAREN_in_parforHead3436); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN272);

				DebugLocation(405, 15);
				PushFollow(Follow._var_in_parforHead3438);
				var273=var();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_var.Add(var273.Tree);
				DebugLocation(405, 19);
				ASSIGN274=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_parforHead3440); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN274);

				DebugLocation(405, 26);
				PushFollow(Follow._expression_in_parforHead3442);
				expression275=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression275.Tree);
				DebugLocation(405, 37);
				RPAREN276=(IToken)Match(input,RPAREN,Follow._RPAREN_in_parforHead3444); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN276);



				{
				// AST REWRITE
				// elements: var, expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 405:44: -> var expression
				{
					DebugLocation(405, 47);
					adaptor.AddChild(root_0, stream_var.NextTree());
					DebugLocation(405, 51);
					adaptor.AddChild(root_0, stream_expression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:406:8: var ASSIGN expression
				{
				DebugLocation(406, 8);
				PushFollow(Follow._var_in_parforHead3459);
				var277=var();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_var.Add(var277.Tree);
				DebugLocation(406, 12);
				ASSIGN278=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_parforHead3461); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN278);

				DebugLocation(406, 19);
				PushFollow(Follow._expression_in_parforHead3463);
				expression279=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression279.Tree);


				{
				// AST REWRITE
				// elements: var, expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 406:30: -> var expression
				{
					DebugLocation(406, 33);
					adaptor.AddChild(root_0, stream_var.NextTree());
					DebugLocation(406, 37);
					adaptor.AddChild(root_0, stream_expression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parforHead", 89);
			LeaveRule("parforHead", 89);
			LeaveRule_parforHead();
		}
		DebugLocation(407, 5);
		} finally { DebugExitRule(GrammarFileName, "parforHead"); }
		return retval;

	}
	// $ANTLR end "parforHead"

	partial void EnterRule_persistent();
	partial void LeaveRule_persistent();
	// $ANTLR start "persistent"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:411:1: persistent : PERSISTENT ( var )+ xEOS -> ^( PERSISTENT ( var )+ xEOS ) ;
	[GrammarRule("persistent")]
	private AstParserRuleReturnScope<object, IToken> persistent()
	{
		EnterRule_persistent();
		EnterRule("persistent", 90);
		TraceIn("persistent", 90);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken PERSISTENT280 = default(IToken);
		AstParserRuleReturnScope<object, IToken> var281 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS282 = default(AstParserRuleReturnScope<object, IToken>);

		object PERSISTENT280_tree = default(object);
		RewriteRuleITokenStream stream_PERSISTENT=new RewriteRuleITokenStream(adaptor,"token PERSISTENT");
		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "persistent");
		DebugLocation(411, 65);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:411:12: ( PERSISTENT ( var )+ xEOS -> ^( PERSISTENT ( var )+ xEOS ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:411:14: PERSISTENT ( var )+ xEOS
			{
			DebugLocation(411, 14);
			PERSISTENT280=(IToken)Match(input,PERSISTENT,Follow._PERSISTENT_in_persistent3485); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PERSISTENT.Add(PERSISTENT280);

			DebugLocation(411, 25);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:411:25: ( var )+
			int cnt75=0;
			try { DebugEnterSubRule(75);
			while (true)
			{
				int alt75=2;
				try { DebugEnterDecision(75, false);
				int LA75_1 = input.LA(1);

				if ((LA75_1==ID))
				{
					alt75 = 1;
				}


				} finally { DebugExitDecision(75); }
				switch (alt75)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:411:26: var
					{
					DebugLocation(411, 26);
					PushFollow(Follow._var_in_persistent3488);
					var281=var();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_var.Add(var281.Tree);

					}
					break;

				default:
					if (cnt75 >= 1)
						goto loop75;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee75 = new EarlyExitException( 75, input );
					DebugRecognitionException(eee75);
					throw eee75;
				}
				cnt75++;
			}
			loop75:
				;

			} finally { DebugExitSubRule(75); }

			DebugLocation(411, 32);
			PushFollow(Follow._xEOS_in_persistent3492);
			xEOS282=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS282.Tree);


			{
			// AST REWRITE
			// elements: PERSISTENT, var, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 411:37: -> ^( PERSISTENT ( var )+ xEOS )
			{
				DebugLocation(411, 40);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:411:40: ^( PERSISTENT ( var )+ xEOS )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(411, 42);
				root_1 = (object)adaptor.BecomeRoot(stream_PERSISTENT.NextNode(), root_1);

				DebugLocation(411, 53);
				if (!(stream_var.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_var.HasNext )
				{
					DebugLocation(411, 54);
					adaptor.AddChild(root_1, stream_var.NextTree());

				}
				stream_var.Reset();
				DebugLocation(411, 60);
				adaptor.AddChild(root_1, stream_xEOS.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("persistent", 90);
			LeaveRule("persistent", 90);
			LeaveRule_persistent();
		}
		DebugLocation(411, 65);
		} finally { DebugExitRule(GrammarFileName, "persistent"); }
		return retval;

	}
	// $ANTLR end "persistent"

	partial void EnterRule_return();
	partial void LeaveRule_return();
	// $ANTLR start "return"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:415:1: return : RETURN xEOS -> ^( RETURN xEOS ) ;
	[GrammarRule("return")]
	private AstParserRuleReturnScope<object, IToken> @return()
	{
		EnterRule_return();
		EnterRule("return", 91);
		TraceIn("return", 91);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken RETURN283 = default(IToken);
		AstParserRuleReturnScope<object, IToken> xEOS284 = default(AstParserRuleReturnScope<object, IToken>);

		object RETURN283_tree = default(object);
		RewriteRuleITokenStream stream_RETURN=new RewriteRuleITokenStream(adaptor,"token RETURN");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "return");
		DebugLocation(415, 39);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:415:8: ( RETURN xEOS -> ^( RETURN xEOS ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:415:10: RETURN xEOS
			{
			DebugLocation(415, 10);
			RETURN283=(IToken)Match(input,RETURN,Follow._RETURN_in_return3516); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RETURN.Add(RETURN283);

			DebugLocation(415, 17);
			PushFollow(Follow._xEOS_in_return3518);
			xEOS284=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS284.Tree);


			{
			// AST REWRITE
			// elements: RETURN, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 415:22: -> ^( RETURN xEOS )
			{
				DebugLocation(415, 25);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:415:25: ^( RETURN xEOS )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(415, 27);
				root_1 = (object)adaptor.BecomeRoot(stream_RETURN.NextNode(), root_1);

				DebugLocation(415, 34);
				adaptor.AddChild(root_1, stream_xEOS.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("return", 91);
			LeaveRule("return", 91);
			LeaveRule_return();
		}
		DebugLocation(415, 39);
		} finally { DebugExitRule(GrammarFileName, "return"); }
		return retval;

	}
	// $ANTLR end "return"

	partial void EnterRule_spmd();
	partial void LeaveRule_spmd();
	// $ANTLR start "spmd"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:419:1: spmd : SPMD ( options {greedy=true; } : spmdHead )? statements END xEOS -> ^( SPMD ( spmdHead )? ( statements )? xEOS ) ;
	[GrammarRule("spmd")]
	private AstParserRuleReturnScope<object, IToken> spmd()
	{
		EnterRule_spmd();
		EnterRule("spmd", 92);
		TraceIn("spmd", 92);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SPMD285 = default(IToken);
		IToken END288 = default(IToken);
		AstParserRuleReturnScope<object, IToken> spmdHead286 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statements287 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS289 = default(AstParserRuleReturnScope<object, IToken>);

		object SPMD285_tree = default(object);
		object END288_tree = default(object);
		RewriteRuleITokenStream stream_SPMD=new RewriteRuleITokenStream(adaptor,"token SPMD");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_spmdHead=new RewriteRuleSubtreeStream(adaptor,"rule spmdHead");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "spmd");
		DebugLocation(419, 110);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:419:6: ( SPMD ( options {greedy=true; } : spmdHead )? statements END xEOS -> ^( SPMD ( spmdHead )? ( statements )? xEOS ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:419:8: SPMD ( options {greedy=true; } : spmdHead )? statements END xEOS
			{
			DebugLocation(419, 8);
			SPMD285=(IToken)Match(input,SPMD,Follow._SPMD_in_spmd3538); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SPMD.Add(SPMD285);

			DebugLocation(419, 13);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:419:13: ( options {greedy=true; } : spmdHead )?
			int alt76=2;
			try { DebugEnterSubRule(76);
			try { DebugEnterDecision(76, false);
			int LA76_1 = input.LA(1);

			if ((LA76_1==LPAREN))
			{
				int LA76_2 = input.LA(2);

				if ((!(((True())))))
				{
					alt76 = 1;
				}
			}
			} finally { DebugExitDecision(76); }
			switch (alt76)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:419:38: spmdHead
				{
				DebugLocation(419, 38);
				PushFollow(Follow._spmdHead_in_spmd3549);
				spmdHead286=spmdHead();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_spmdHead.Add(spmdHead286.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(76); }

			DebugLocation(419, 49);
			PushFollow(Follow._statements_in_spmd3553);
			statements287=statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statements.Add(statements287.Tree);
			DebugLocation(419, 60);
			END288=(IToken)Match(input,END,Follow._END_in_spmd3555); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END288);

			DebugLocation(419, 64);
			PushFollow(Follow._xEOS_in_spmd3557);
			xEOS289=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS289.Tree);


			{
			// AST REWRITE
			// elements: SPMD, spmdHead, statements, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 419:69: -> ^( SPMD ( spmdHead )? ( statements )? xEOS )
			{
				DebugLocation(419, 72);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:419:72: ^( SPMD ( spmdHead )? ( statements )? xEOS )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(419, 74);
				root_1 = (object)adaptor.BecomeRoot(stream_SPMD.NextNode(), root_1);

				DebugLocation(419, 79);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:419:79: ( spmdHead )?
				if (stream_spmdHead.HasNext)
				{
					DebugLocation(419, 80);
					adaptor.AddChild(root_1, stream_spmdHead.NextTree());

				}
				stream_spmdHead.Reset();
				DebugLocation(419, 91);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:419:91: ( statements )?
				if (stream_statements.HasNext)
				{
					DebugLocation(419, 92);
					adaptor.AddChild(root_1, stream_statements.NextTree());

				}
				stream_statements.Reset();
				DebugLocation(419, 105);
				adaptor.AddChild(root_1, stream_xEOS.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("spmd", 92);
			LeaveRule("spmd", 92);
			LeaveRule_spmd();
		}
		DebugLocation(419, 110);
		} finally { DebugExitRule(GrammarFileName, "spmd"); }
		return retval;

	}
	// $ANTLR end "spmd"

	partial void EnterRule_spmdHead();
	partial void LeaveRule_spmdHead();
	// $ANTLR start "spmdHead"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:421:1: spmdHead : LPAREN expression ( COMMA expression )? RPAREN -> ( expression )+ ;
	[GrammarRule("spmdHead")]
	private AstParserRuleReturnScope<object, IToken> spmdHead()
	{
		EnterRule_spmdHead();
		EnterRule("spmdHead", 93);
		TraceIn("spmdHead", 93);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN290 = default(IToken);
		IToken COMMA292 = default(IToken);
		IToken RPAREN294 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression291 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression293 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN290_tree = default(object);
		object COMMA292_tree = default(object);
		object RPAREN294_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "spmdHead");
		DebugLocation(421, 73);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:421:10: ( LPAREN expression ( COMMA expression )? RPAREN -> ( expression )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:421:12: LPAREN expression ( COMMA expression )? RPAREN
			{
			DebugLocation(421, 12);
			LPAREN290=(IToken)Match(input,LPAREN,Follow._LPAREN_in_spmdHead3584); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN290);

			DebugLocation(421, 19);
			PushFollow(Follow._expression_in_spmdHead3586);
			expression291=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression291.Tree);
			DebugLocation(421, 30);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:421:30: ( COMMA expression )?
			int alt77=2;
			try { DebugEnterSubRule(77);
			try { DebugEnterDecision(77, false);
			int LA77_1 = input.LA(1);

			if ((LA77_1==COMMA))
			{
				alt77 = 1;
			}
			} finally { DebugExitDecision(77); }
			switch (alt77)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:421:31: COMMA expression
				{
				DebugLocation(421, 31);
				COMMA292=(IToken)Match(input,COMMA,Follow._COMMA_in_spmdHead3589); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COMMA.Add(COMMA292);

				DebugLocation(421, 37);
				PushFollow(Follow._expression_in_spmdHead3591);
				expression293=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression293.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(77); }

			DebugLocation(421, 50);
			RPAREN294=(IToken)Match(input,RPAREN,Follow._RPAREN_in_spmdHead3595); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN294);



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 421:57: -> ( expression )+
			{
				DebugLocation(421, 60);
				if (!(stream_expression.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_expression.HasNext )
				{
					DebugLocation(421, 61);
					adaptor.AddChild(root_0, stream_expression.NextTree());

				}
				stream_expression.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("spmdHead", 93);
			LeaveRule("spmdHead", 93);
			LeaveRule_spmdHead();
		}
		DebugLocation(421, 73);
		} finally { DebugExitRule(GrammarFileName, "spmdHead"); }
		return retval;

	}
	// $ANTLR end "spmdHead"

	partial void EnterRule_switch();
	partial void LeaveRule_switch();
	// $ANTLR start "switch"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:425:1: switch : switchPart ( casePart )* ( otherwisePart )? END xEOS -> ^( SWITCHCASE[$switchPart.start] switchPart ( casePart )* ( otherwisePart )? xEOS ) ;
	[GrammarRule("switch")]
	private AstParserRuleReturnScope<object, IToken> @switch()
	{
		EnterRule_switch();
		EnterRule("switch", 94);
		TraceIn("switch", 94);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken END298 = default(IToken);
		AstParserRuleReturnScope<object, IToken> switchPart295 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> casePart296 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> otherwisePart297 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS299 = default(AstParserRuleReturnScope<object, IToken>);

		object END298_tree = default(object);
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_switchPart=new RewriteRuleSubtreeStream(adaptor,"rule switchPart");
		RewriteRuleSubtreeStream stream_casePart=new RewriteRuleSubtreeStream(adaptor,"rule casePart");
		RewriteRuleSubtreeStream stream_otherwisePart=new RewriteRuleSubtreeStream(adaptor,"rule otherwisePart");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "switch");
		DebugLocation(425, 139);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:425:8: ( switchPart ( casePart )* ( otherwisePart )? END xEOS -> ^( SWITCHCASE[$switchPart.start] switchPart ( casePart )* ( otherwisePart )? xEOS ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:425:10: switchPart ( casePart )* ( otherwisePart )? END xEOS
			{
			DebugLocation(425, 10);
			PushFollow(Follow._switchPart_in_switch3613);
			switchPart295=switchPart();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_switchPart.Add(switchPart295.Tree);
			DebugLocation(425, 21);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:425:21: ( casePart )*
			try { DebugEnterSubRule(78);
			while (true)
			{
				int alt78=2;
				try { DebugEnterDecision(78, false);
				int LA78_1 = input.LA(1);

				if ((LA78_1==CASE))
				{
					alt78 = 1;
				}


				} finally { DebugExitDecision(78); }
				switch ( alt78 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:425:22: casePart
					{
					DebugLocation(425, 22);
					PushFollow(Follow._casePart_in_switch3616);
					casePart296=casePart();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_casePart.Add(casePart296.Tree);

					}
					break;

				default:
					goto loop78;
				}
			}

			loop78:
				;

			} finally { DebugExitSubRule(78); }

			DebugLocation(425, 33);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:425:33: ( otherwisePart )?
			int alt79=2;
			try { DebugEnterSubRule(79);
			try { DebugEnterDecision(79, false);
			int LA79_1 = input.LA(1);

			if ((LA79_1==OTHERWISE))
			{
				alt79 = 1;
			}
			} finally { DebugExitDecision(79); }
			switch (alt79)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:425:34: otherwisePart
				{
				DebugLocation(425, 34);
				PushFollow(Follow._otherwisePart_in_switch3621);
				otherwisePart297=otherwisePart();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_otherwisePart.Add(otherwisePart297.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(79); }

			DebugLocation(425, 50);
			END298=(IToken)Match(input,END,Follow._END_in_switch3625); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END298);

			DebugLocation(425, 54);
			PushFollow(Follow._xEOS_in_switch3627);
			xEOS299=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS299.Tree);


			{
			// AST REWRITE
			// elements: switchPart, casePart, otherwisePart, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 425:59: -> ^( SWITCHCASE[$switchPart.start] switchPart ( casePart )* ( otherwisePart )? xEOS )
			{
				DebugLocation(425, 62);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:425:62: ^( SWITCHCASE[$switchPart.start] switchPart ( casePart )* ( otherwisePart )? xEOS )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(425, 64);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(SWITCHCASE, (switchPart295!=null?((IToken)switchPart295.Start):default(IToken))), root_1);

				DebugLocation(425, 94);
				adaptor.AddChild(root_1, stream_switchPart.NextTree());
				DebugLocation(425, 105);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:425:105: ( casePart )*
				while ( stream_casePart.HasNext )
				{
					DebugLocation(425, 106);
					adaptor.AddChild(root_1, stream_casePart.NextTree());

				}
				stream_casePart.Reset();
				DebugLocation(425, 117);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:425:117: ( otherwisePart )?
				if (stream_otherwisePart.HasNext)
				{
					DebugLocation(425, 118);
					adaptor.AddChild(root_1, stream_otherwisePart.NextTree());

				}
				stream_otherwisePart.Reset();
				DebugLocation(425, 134);
				adaptor.AddChild(root_1, stream_xEOS.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("switch", 94);
			LeaveRule("switch", 94);
			LeaveRule_switch();
		}
		DebugLocation(425, 139);
		} finally { DebugExitRule(GrammarFileName, "switch"); }
		return retval;

	}
	// $ANTLR end "switch"

	partial void EnterRule_switchPart();
	partial void LeaveRule_switchPart();
	// $ANTLR start "switchPart"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:427:1: switchPart : SWITCH expression ( xEOS )* -> ^( SWITCH expression ) ;
	[GrammarRule("switchPart")]
	private AstParserRuleReturnScope<object, IToken> switchPart()
	{
		EnterRule_switchPart();
		EnterRule("switchPart", 95);
		TraceIn("switchPart", 95);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SWITCH300 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression301 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS302 = default(AstParserRuleReturnScope<object, IToken>);

		object SWITCH300_tree = default(object);
		RewriteRuleITokenStream stream_SWITCH=new RewriteRuleITokenStream(adaptor,"token SWITCH");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "switchPart");
		DebugLocation(427, 63);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:427:12: ( SWITCH expression ( xEOS )* -> ^( SWITCH expression ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:427:14: SWITCH expression ( xEOS )*
			{
			DebugLocation(427, 14);
			SWITCH300=(IToken)Match(input,SWITCH,Follow._SWITCH_in_switchPart3657); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SWITCH.Add(SWITCH300);

			DebugLocation(427, 21);
			PushFollow(Follow._expression_in_switchPart3659);
			expression301=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression301.Tree);
			DebugLocation(427, 32);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:427:32: ( xEOS )*
			try { DebugEnterSubRule(80);
			while (true)
			{
				int alt80=2;
				try { DebugEnterDecision(80, false);
				int LA80_1 = input.LA(1);

				if ((LA80_1==COMMA||LA80_1==EOL||LA80_1==SEMICOLON))
				{
					alt80 = 1;
				}


				} finally { DebugExitDecision(80); }
				switch ( alt80 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:427:33: xEOS
					{
					DebugLocation(427, 33);
					PushFollow(Follow._xEOS_in_switchPart3662);
					xEOS302=xEOS();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_xEOS.Add(xEOS302.Tree);

					}
					break;

				default:
					goto loop80;
				}
			}

			loop80:
				;

			} finally { DebugExitSubRule(80); }



			{
			// AST REWRITE
			// elements: SWITCH, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 427:40: -> ^( SWITCH expression )
			{
				DebugLocation(427, 43);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:427:43: ^( SWITCH expression )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(427, 45);
				root_1 = (object)adaptor.BecomeRoot(stream_SWITCH.NextNode(), root_1);

				DebugLocation(427, 52);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("switchPart", 95);
			LeaveRule("switchPart", 95);
			LeaveRule_switchPart();
		}
		DebugLocation(427, 63);
		} finally { DebugExitRule(GrammarFileName, "switchPart"); }
		return retval;

	}
	// $ANTLR end "switchPart"

	partial void EnterRule_casePart();
	partial void LeaveRule_casePart();
	// $ANTLR start "casePart"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:429:1: casePart : CASE expression xEOS statements -> ^( CASE expression ( statements )? ) ;
	[GrammarRule("casePart")]
	private AstParserRuleReturnScope<object, IToken> casePart()
	{
		EnterRule_casePart();
		EnterRule("casePart", 96);
		TraceIn("casePart", 96);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CASE303 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression304 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS305 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statements306 = default(AstParserRuleReturnScope<object, IToken>);

		object CASE303_tree = default(object);
		RewriteRuleITokenStream stream_CASE=new RewriteRuleITokenStream(adaptor,"token CASE");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		try { DebugEnterRule(GrammarFileName, "casePart");
		DebugLocation(429, 79);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:429:10: ( CASE expression xEOS statements -> ^( CASE expression ( statements )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:429:12: CASE expression xEOS statements
			{
			DebugLocation(429, 12);
			CASE303=(IToken)Match(input,CASE,Follow._CASE_in_casePart3681); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CASE.Add(CASE303);

			DebugLocation(429, 17);
			PushFollow(Follow._expression_in_casePart3683);
			expression304=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression304.Tree);
			DebugLocation(429, 28);
			PushFollow(Follow._xEOS_in_casePart3685);
			xEOS305=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS305.Tree);
			DebugLocation(429, 33);
			PushFollow(Follow._statements_in_casePart3687);
			statements306=statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statements.Add(statements306.Tree);


			{
			// AST REWRITE
			// elements: CASE, expression, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 429:44: -> ^( CASE expression ( statements )? )
			{
				DebugLocation(429, 47);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:429:47: ^( CASE expression ( statements )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(429, 49);
				root_1 = (object)adaptor.BecomeRoot(stream_CASE.NextNode(), root_1);

				DebugLocation(429, 54);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(429, 65);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:429:65: ( statements )?
				if (stream_statements.HasNext)
				{
					DebugLocation(429, 66);
					adaptor.AddChild(root_1, stream_statements.NextTree());

				}
				stream_statements.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("casePart", 96);
			LeaveRule("casePart", 96);
			LeaveRule_casePart();
		}
		DebugLocation(429, 79);
		} finally { DebugExitRule(GrammarFileName, "casePart"); }
		return retval;

	}
	// $ANTLR end "casePart"

	partial void EnterRule_otherwisePart();
	partial void LeaveRule_otherwisePart();
	// $ANTLR start "otherwisePart"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:431:1: otherwisePart : OTHERWISE statements -> ^( OTHERWISE ( statements )? ) ;
	[GrammarRule("otherwisePart")]
	private AstParserRuleReturnScope<object, IToken> otherwisePart()
	{
		EnterRule_otherwisePart();
		EnterRule("otherwisePart", 97);
		TraceIn("otherwisePart", 97);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OTHERWISE307 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statements308 = default(AstParserRuleReturnScope<object, IToken>);

		object OTHERWISE307_tree = default(object);
		RewriteRuleITokenStream stream_OTHERWISE=new RewriteRuleITokenStream(adaptor,"token OTHERWISE");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		try { DebugEnterRule(GrammarFileName, "otherwisePart");
		DebugLocation(431, 67);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:431:15: ( OTHERWISE statements -> ^( OTHERWISE ( statements )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:431:17: OTHERWISE statements
			{
			DebugLocation(431, 17);
			OTHERWISE307=(IToken)Match(input,OTHERWISE,Follow._OTHERWISE_in_otherwisePart3709); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_OTHERWISE.Add(OTHERWISE307);

			DebugLocation(431, 27);
			PushFollow(Follow._statements_in_otherwisePart3711);
			statements308=statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statements.Add(statements308.Tree);


			{
			// AST REWRITE
			// elements: OTHERWISE, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 431:38: -> ^( OTHERWISE ( statements )? )
			{
				DebugLocation(431, 41);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:431:41: ^( OTHERWISE ( statements )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(431, 43);
				root_1 = (object)adaptor.BecomeRoot(stream_OTHERWISE.NextNode(), root_1);

				DebugLocation(431, 53);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:431:53: ( statements )?
				if (stream_statements.HasNext)
				{
					DebugLocation(431, 54);
					adaptor.AddChild(root_1, stream_statements.NextTree());

				}
				stream_statements.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("otherwisePart", 97);
			LeaveRule("otherwisePart", 97);
			LeaveRule_otherwisePart();
		}
		DebugLocation(431, 67);
		} finally { DebugExitRule(GrammarFileName, "otherwisePart"); }
		return retval;

	}
	// $ANTLR end "otherwisePart"

	partial void EnterRule_try();
	partial void LeaveRule_try();
	// $ANTLR start "try"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:435:1: try : tryPart ( catchPart )? END xEOS -> ^( TRYCATCH[$tryPart.start] tryPart ( catchPart )? xEOS ) ;
	[GrammarRule("try")]
	private AstParserRuleReturnScope<object, IToken> @try()
	{
		EnterRule_try();
		EnterRule("try", 98);
		TraceIn("try", 98);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken END311 = default(IToken);
		AstParserRuleReturnScope<object, IToken> tryPart309 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> catchPart310 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS312 = default(AstParserRuleReturnScope<object, IToken>);

		object END311_tree = default(object);
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_tryPart=new RewriteRuleSubtreeStream(adaptor,"rule tryPart");
		RewriteRuleSubtreeStream stream_catchPart=new RewriteRuleSubtreeStream(adaptor,"rule catchPart");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "try");
		DebugLocation(435, 93);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:435:5: ( tryPart ( catchPart )? END xEOS -> ^( TRYCATCH[$tryPart.start] tryPart ( catchPart )? xEOS ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:435:7: tryPart ( catchPart )? END xEOS
			{
			DebugLocation(435, 7);
			PushFollow(Follow._tryPart_in_try3733);
			tryPart309=tryPart();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_tryPart.Add(tryPart309.Tree);
			DebugLocation(435, 15);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:435:15: ( catchPart )?
			int alt81=2;
			try { DebugEnterSubRule(81);
			try { DebugEnterDecision(81, false);
			int LA81_1 = input.LA(1);

			if ((LA81_1==CATCH))
			{
				alt81 = 1;
			}
			} finally { DebugExitDecision(81); }
			switch (alt81)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:435:16: catchPart
				{
				DebugLocation(435, 16);
				PushFollow(Follow._catchPart_in_try3736);
				catchPart310=catchPart();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_catchPart.Add(catchPart310.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(81); }

			DebugLocation(435, 28);
			END311=(IToken)Match(input,END,Follow._END_in_try3740); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END311);

			DebugLocation(435, 32);
			PushFollow(Follow._xEOS_in_try3742);
			xEOS312=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS312.Tree);


			{
			// AST REWRITE
			// elements: tryPart, catchPart, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 435:37: -> ^( TRYCATCH[$tryPart.start] tryPart ( catchPart )? xEOS )
			{
				DebugLocation(435, 40);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:435:40: ^( TRYCATCH[$tryPart.start] tryPart ( catchPart )? xEOS )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(435, 42);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TRYCATCH, (tryPart309!=null?((IToken)tryPart309.Start):default(IToken))), root_1);

				DebugLocation(435, 67);
				adaptor.AddChild(root_1, stream_tryPart.NextTree());
				DebugLocation(435, 75);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:435:75: ( catchPart )?
				if (stream_catchPart.HasNext)
				{
					DebugLocation(435, 76);
					adaptor.AddChild(root_1, stream_catchPart.NextTree());

				}
				stream_catchPart.Reset();
				DebugLocation(435, 88);
				adaptor.AddChild(root_1, stream_xEOS.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("try", 98);
			LeaveRule("try", 98);
			LeaveRule_try();
		}
		DebugLocation(435, 93);
		} finally { DebugExitRule(GrammarFileName, "try"); }
		return retval;

	}
	// $ANTLR end "try"

	partial void EnterRule_tryPart();
	partial void LeaveRule_tryPart();
	// $ANTLR start "tryPart"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:437:1: tryPart : TRY statements -> ^( TRY ( statements )? ) ;
	[GrammarRule("tryPart")]
	private AstParserRuleReturnScope<object, IToken> tryPart()
	{
		EnterRule_tryPart();
		EnterRule("tryPart", 99);
		TraceIn("tryPart", 99);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TRY313 = default(IToken);
		AstParserRuleReturnScope<object, IToken> statements314 = default(AstParserRuleReturnScope<object, IToken>);

		object TRY313_tree = default(object);
		RewriteRuleITokenStream stream_TRY=new RewriteRuleITokenStream(adaptor,"token TRY");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		try { DebugEnterRule(GrammarFileName, "tryPart");
		DebugLocation(437, 49);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:437:9: ( TRY statements -> ^( TRY ( statements )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:437:11: TRY statements
			{
			DebugLocation(437, 11);
			TRY313=(IToken)Match(input,TRY,Follow._TRY_in_tryPart3767); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_TRY.Add(TRY313);

			DebugLocation(437, 15);
			PushFollow(Follow._statements_in_tryPart3769);
			statements314=statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statements.Add(statements314.Tree);


			{
			// AST REWRITE
			// elements: TRY, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 437:26: -> ^( TRY ( statements )? )
			{
				DebugLocation(437, 29);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:437:29: ^( TRY ( statements )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(437, 31);
				root_1 = (object)adaptor.BecomeRoot(stream_TRY.NextNode(), root_1);

				DebugLocation(437, 35);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:437:35: ( statements )?
				if (stream_statements.HasNext)
				{
					DebugLocation(437, 36);
					adaptor.AddChild(root_1, stream_statements.NextTree());

				}
				stream_statements.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tryPart", 99);
			LeaveRule("tryPart", 99);
			LeaveRule_tryPart();
		}
		DebugLocation(437, 49);
		} finally { DebugExitRule(GrammarFileName, "tryPart"); }
		return retval;

	}
	// $ANTLR end "tryPart"

	partial void EnterRule_catchPart();
	partial void LeaveRule_catchPart();
	// $ANTLR start "catchPart"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:439:1: catchPart : CATCH ( options {greedy=true; } :{...}? => capturePortion )? statements -> ^( CATCH ( capturePortion )? ( statements )? ) ;
	[GrammarRule("catchPart")]
	private AstParserRuleReturnScope<object, IToken> catchPart()
	{
		EnterRule_catchPart();
		EnterRule("catchPart", 100);
		TraceIn("catchPart", 100);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken CATCH315 = default(IToken);
		AstParserRuleReturnScope<object, IToken> capturePortion316 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statements317 = default(AstParserRuleReturnScope<object, IToken>);

		object CATCH315_tree = default(object);
		RewriteRuleITokenStream stream_CATCH=new RewriteRuleITokenStream(adaptor,"token CATCH");
		RewriteRuleSubtreeStream stream_capturePortion=new RewriteRuleSubtreeStream(adaptor,"rule capturePortion");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		try { DebugEnterRule(GrammarFileName, "catchPart");
		DebugLocation(439, 127);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:439:11: ( CATCH ( options {greedy=true; } :{...}? => capturePortion )? statements -> ^( CATCH ( capturePortion )? ( statements )? ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:439:13: CATCH ( options {greedy=true; } :{...}? => capturePortion )? statements
			{
			DebugLocation(439, 13);
			CATCH315=(IToken)Match(input,CATCH,Follow._CATCH_in_catchPart3789); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CATCH.Add(CATCH315);

			DebugLocation(439, 19);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:439:19: ( options {greedy=true; } :{...}? => capturePortion )?
			int alt82=2;
			try { DebugEnterSubRule(82);
			try { DebugEnterDecision(82, false);
			int LA82_1 = input.LA(1);

			if ((LA82_1==ID) && (((True())||(Command_IsEnabled()))))
			{
				int LA82_2 = input.LA(2);

				if ((LA82_2==SEMICOLON) && (((True())||(Command_IsEnabled()))))
				{
					int LA82_3 = input.LA(3);

					if (((True())))
					{
						alt82 = 1;
					}
				}
				else if ((LA82_2==COMMA) && (((True())||(Command_IsEnabled()))))
				{
					int LA82_3 = input.LA(3);

					if (((True())))
					{
						alt82 = 1;
					}
				}
				else if ((LA82_2==EOL) && (((True())||(Command_IsEnabled()))))
				{
					int LA82_3 = input.LA(3);

					if (((True())))
					{
						alt82 = 1;
					}
				}
			}
			} finally { DebugExitDecision(82); }
			switch (alt82)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:439:44: {...}? => capturePortion
				{
				DebugLocation(439, 44);
				if (!((True())))
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					throw new FailedPredicateException(input, "catchPart", "True()");
				}
				DebugLocation(439, 56);
				PushFollow(Follow._capturePortion_in_catchPart3803);
				capturePortion316=capturePortion();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_capturePortion.Add(capturePortion316.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(82); }

			DebugLocation(439, 73);
			PushFollow(Follow._statements_in_catchPart3807);
			statements317=statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statements.Add(statements317.Tree);


			{
			// AST REWRITE
			// elements: CATCH, capturePortion, statements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 439:84: -> ^( CATCH ( capturePortion )? ( statements )? )
			{
				DebugLocation(439, 87);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:439:87: ^( CATCH ( capturePortion )? ( statements )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(439, 89);
				root_1 = (object)adaptor.BecomeRoot(stream_CATCH.NextNode(), root_1);

				DebugLocation(439, 95);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:439:95: ( capturePortion )?
				if (stream_capturePortion.HasNext)
				{
					DebugLocation(439, 96);
					adaptor.AddChild(root_1, stream_capturePortion.NextTree());

				}
				stream_capturePortion.Reset();
				DebugLocation(439, 113);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:439:113: ( statements )?
				if (stream_statements.HasNext)
				{
					DebugLocation(439, 114);
					adaptor.AddChild(root_1, stream_statements.NextTree());

				}
				stream_statements.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("catchPart", 100);
			LeaveRule("catchPart", 100);
			LeaveRule_catchPart();
		}
		DebugLocation(439, 127);
		} finally { DebugExitRule(GrammarFileName, "catchPart"); }
		return retval;

	}
	// $ANTLR end "catchPart"

	partial void EnterRule_capturePortion();
	partial void LeaveRule_capturePortion();
	// $ANTLR start "capturePortion"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:441:1: capturePortion : var xEOS -> var ;
	[GrammarRule("capturePortion")]
	private AstParserRuleReturnScope<object, IToken> capturePortion()
	{
		EnterRule_capturePortion();
		EnterRule("capturePortion", 101);
		TraceIn("capturePortion", 101);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> var318 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS319 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "capturePortion");
		DebugLocation(441, 33);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:441:16: ( var xEOS -> var )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:441:18: var xEOS
			{
			DebugLocation(441, 18);
			PushFollow(Follow._var_in_capturePortion3832);
			var318=var();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_var.Add(var318.Tree);
			DebugLocation(441, 22);
			PushFollow(Follow._xEOS_in_capturePortion3834);
			xEOS319=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS319.Tree);


			{
			// AST REWRITE
			// elements: var
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 441:27: -> var
			{
				DebugLocation(441, 30);
				adaptor.AddChild(root_0, stream_var.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("capturePortion", 101);
			LeaveRule("capturePortion", 101);
			LeaveRule_capturePortion();
		}
		DebugLocation(441, 33);
		} finally { DebugExitRule(GrammarFileName, "capturePortion"); }
		return retval;

	}
	// $ANTLR end "capturePortion"

	partial void EnterRule_while();
	partial void LeaveRule_while();
	// $ANTLR start "while"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:445:1: while : WHILE expression statements END xEOS -> ^( WHILE expression ( statements )? xEOS ) ;
	[GrammarRule("while")]
	private AstParserRuleReturnScope<object, IToken> @while()
	{
		EnterRule_while();
		EnterRule("while", 102);
		TraceIn("while", 102);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken WHILE320 = default(IToken);
		IToken END323 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression321 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> statements322 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xEOS324 = default(AstParserRuleReturnScope<object, IToken>);

		object WHILE320_tree = default(object);
		object END323_tree = default(object);
		RewriteRuleITokenStream stream_WHILE=new RewriteRuleITokenStream(adaptor,"token WHILE");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statements=new RewriteRuleSubtreeStream(adaptor,"rule statements");
		RewriteRuleSubtreeStream stream_xEOS=new RewriteRuleSubtreeStream(adaptor,"rule xEOS");
		try { DebugEnterRule(GrammarFileName, "while");
		DebugLocation(445, 87);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:445:7: ( WHILE expression statements END xEOS -> ^( WHILE expression ( statements )? xEOS ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:445:9: WHILE expression statements END xEOS
			{
			DebugLocation(445, 9);
			WHILE320=(IToken)Match(input,WHILE,Follow._WHILE_in_while3849); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WHILE.Add(WHILE320);

			DebugLocation(445, 15);
			PushFollow(Follow._expression_in_while3851);
			expression321=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression321.Tree);
			DebugLocation(445, 26);
			PushFollow(Follow._statements_in_while3853);
			statements322=statements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statements.Add(statements322.Tree);
			DebugLocation(445, 37);
			END323=(IToken)Match(input,END,Follow._END_in_while3855); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END323);

			DebugLocation(445, 41);
			PushFollow(Follow._xEOS_in_while3857);
			xEOS324=xEOS();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xEOS.Add(xEOS324.Tree);


			{
			// AST REWRITE
			// elements: WHILE, expression, statements, xEOS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 445:46: -> ^( WHILE expression ( statements )? xEOS )
			{
				DebugLocation(445, 49);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:445:49: ^( WHILE expression ( statements )? xEOS )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(445, 51);
				root_1 = (object)adaptor.BecomeRoot(stream_WHILE.NextNode(), root_1);

				DebugLocation(445, 57);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(445, 68);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:445:68: ( statements )?
				if (stream_statements.HasNext)
				{
					DebugLocation(445, 69);
					adaptor.AddChild(root_1, stream_statements.NextTree());

				}
				stream_statements.Reset();
				DebugLocation(445, 82);
				adaptor.AddChild(root_1, stream_xEOS.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("while", 102);
			LeaveRule("while", 102);
			LeaveRule_while();
		}
		DebugLocation(445, 87);
		} finally { DebugExitRule(GrammarFileName, "while"); }
		return retval;

	}
	// $ANTLR end "while"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:449:1: expression : expression11 -> expression11 ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<object, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 103);
		TraceIn("expression", 103);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> expression11325 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_expression11=new RewriteRuleSubtreeStream(adaptor,"rule expression11");
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(449, 42);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:449:12: ( expression11 -> expression11 )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:449:14: expression11
			{
			DebugLocation(449, 14);
			PushFollow(Follow._expression11_in_expression3883);
			expression11325=expression11();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression11.Add(expression11325.Tree);


			{
			// AST REWRITE
			// elements: expression11
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 449:27: -> expression11
			{
				DebugLocation(449, 30);
				adaptor.AddChild(root_0, stream_expression11.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 103);
			LeaveRule("expression", 103);
			LeaveRule_expression();
		}
		DebugLocation(449, 42);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_expression11();
	partial void LeaveRule_expression11();
	// $ANTLR start "expression11"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:451:1: expression11 : (x1= expression10 -> $x1) ( options {greedy=true; } : SHORTOR x2= expression10 -> ^( SHORTOR $expression11 $x2) )* ;
	[GrammarRule("expression11")]
	private AstParserRuleReturnScope<object, IToken> expression11()
	{
		EnterRule_expression11();
		EnterRule("expression11", 104);
		TraceIn("expression11", 104);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SHORTOR326 = default(IToken);
		AstParserRuleReturnScope<object, IToken> x1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x2 = default(AstParserRuleReturnScope<object, IToken>);

		object SHORTOR326_tree = default(object);
		RewriteRuleITokenStream stream_SHORTOR=new RewriteRuleITokenStream(adaptor,"token SHORTOR");
		RewriteRuleSubtreeStream stream_expression10=new RewriteRuleSubtreeStream(adaptor,"rule expression10");
		try { DebugEnterRule(GrammarFileName, "expression11");
		DebugLocation(451, 123);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:451:14: ( (x1= expression10 -> $x1) ( options {greedy=true; } : SHORTOR x2= expression10 -> ^( SHORTOR $expression11 $x2) )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:451:16: (x1= expression10 -> $x1) ( options {greedy=true; } : SHORTOR x2= expression10 -> ^( SHORTOR $expression11 $x2) )*
			{
			DebugLocation(451, 16);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:451:16: (x1= expression10 -> $x1)
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:451:17: x1= expression10
			{
			DebugLocation(451, 19);
			PushFollow(Follow._expression10_in_expression113899);
			x1=expression10();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression10.Add(x1.Tree);


			{
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 451:33: -> $x1
			{
				DebugLocation(451, 37);
				adaptor.AddChild(root_0, stream_x1.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(451, 41);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:451:41: ( options {greedy=true; } : SHORTOR x2= expression10 -> ^( SHORTOR $expression11 $x2) )*
			try { DebugEnterSubRule(83);
			while (true)
			{
				int alt83=2;
				try { DebugEnterDecision(83, false);
				int LA83_1 = input.LA(1);

				if ((LA83_1==SHORTOR))
				{
					alt83 = 1;
				}


				} finally { DebugExitDecision(83); }
				switch ( alt83 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:451:66: SHORTOR x2= expression10
					{
					DebugLocation(451, 66);
					SHORTOR326=(IToken)Match(input,SHORTOR,Follow._SHORTOR_in_expression113916); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SHORTOR.Add(SHORTOR326);

					DebugLocation(451, 76);
					PushFollow(Follow._expression10_in_expression113920);
					x2=expression10();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression10.Add(x2.Tree);


					{
					// AST REWRITE
					// elements: SHORTOR, expression11, x2
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 451:90: -> ^( SHORTOR $expression11 $x2)
					{
						DebugLocation(451, 93);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:451:93: ^( SHORTOR $expression11 $x2)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(451, 95);
						root_1 = (object)adaptor.BecomeRoot(stream_SHORTOR.NextNode(), root_1);

						DebugLocation(451, 104);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(451, 118);
						adaptor.AddChild(root_1, stream_x2.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop83;
				}
			}

			loop83:
				;

			} finally { DebugExitSubRule(83); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression11", 104);
			LeaveRule("expression11", 104);
			LeaveRule_expression11();
		}
		DebugLocation(451, 123);
		} finally { DebugExitRule(GrammarFileName, "expression11"); }
		return retval;

	}
	// $ANTLR end "expression11"

	partial void EnterRule_expression10();
	partial void LeaveRule_expression10();
	// $ANTLR start "expression10"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:453:1: expression10 : (x1= expression09 -> $x1) ( options {greedy=true; } : SHORTAND x2= expression09 -> ^( SHORTAND $expression10 $x2) )* ;
	[GrammarRule("expression10")]
	private AstParserRuleReturnScope<object, IToken> expression10()
	{
		EnterRule_expression10();
		EnterRule("expression10", 105);
		TraceIn("expression10", 105);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SHORTAND327 = default(IToken);
		AstParserRuleReturnScope<object, IToken> x1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x2 = default(AstParserRuleReturnScope<object, IToken>);

		object SHORTAND327_tree = default(object);
		RewriteRuleITokenStream stream_SHORTAND=new RewriteRuleITokenStream(adaptor,"token SHORTAND");
		RewriteRuleSubtreeStream stream_expression09=new RewriteRuleSubtreeStream(adaptor,"rule expression09");
		try { DebugEnterRule(GrammarFileName, "expression10");
		DebugLocation(453, 125);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:453:14: ( (x1= expression09 -> $x1) ( options {greedy=true; } : SHORTAND x2= expression09 -> ^( SHORTAND $expression10 $x2) )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:453:16: (x1= expression09 -> $x1) ( options {greedy=true; } : SHORTAND x2= expression09 -> ^( SHORTAND $expression10 $x2) )*
			{
			DebugLocation(453, 16);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:453:16: (x1= expression09 -> $x1)
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:453:17: x1= expression09
			{
			DebugLocation(453, 19);
			PushFollow(Follow._expression09_in_expression103946);
			x1=expression09();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression09.Add(x1.Tree);


			{
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 453:33: -> $x1
			{
				DebugLocation(453, 37);
				adaptor.AddChild(root_0, stream_x1.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(453, 41);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:453:41: ( options {greedy=true; } : SHORTAND x2= expression09 -> ^( SHORTAND $expression10 $x2) )*
			try { DebugEnterSubRule(84);
			while (true)
			{
				int alt84=2;
				try { DebugEnterDecision(84, false);
				int LA84_1 = input.LA(1);

				if ((LA84_1==SHORTAND))
				{
					alt84 = 1;
				}


				} finally { DebugExitDecision(84); }
				switch ( alt84 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:453:66: SHORTAND x2= expression09
					{
					DebugLocation(453, 66);
					SHORTAND327=(IToken)Match(input,SHORTAND,Follow._SHORTAND_in_expression103963); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_SHORTAND.Add(SHORTAND327);

					DebugLocation(453, 77);
					PushFollow(Follow._expression09_in_expression103967);
					x2=expression09();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression09.Add(x2.Tree);


					{
					// AST REWRITE
					// elements: SHORTAND, expression10, x2
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 453:91: -> ^( SHORTAND $expression10 $x2)
					{
						DebugLocation(453, 94);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:453:94: ^( SHORTAND $expression10 $x2)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(453, 96);
						root_1 = (object)adaptor.BecomeRoot(stream_SHORTAND.NextNode(), root_1);

						DebugLocation(453, 106);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(453, 120);
						adaptor.AddChild(root_1, stream_x2.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop84;
				}
			}

			loop84:
				;

			} finally { DebugExitSubRule(84); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression10", 105);
			LeaveRule("expression10", 105);
			LeaveRule_expression10();
		}
		DebugLocation(453, 125);
		} finally { DebugExitRule(GrammarFileName, "expression10"); }
		return retval;

	}
	// $ANTLR end "expression10"

	partial void EnterRule_expression09();
	partial void LeaveRule_expression09();
	// $ANTLR start "expression09"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:455:1: expression09 : (x1= expression08 -> $x1) ( options {greedy=true; } : OR x2= expression08 -> ^( OR $expression09 $x2) )* ;
	[GrammarRule("expression09")]
	private AstParserRuleReturnScope<object, IToken> expression09()
	{
		EnterRule_expression09();
		EnterRule("expression09", 106);
		TraceIn("expression09", 106);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OR328 = default(IToken);
		AstParserRuleReturnScope<object, IToken> x1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x2 = default(AstParserRuleReturnScope<object, IToken>);

		object OR328_tree = default(object);
		RewriteRuleITokenStream stream_OR=new RewriteRuleITokenStream(adaptor,"token OR");
		RewriteRuleSubtreeStream stream_expression08=new RewriteRuleSubtreeStream(adaptor,"rule expression08");
		try { DebugEnterRule(GrammarFileName, "expression09");
		DebugLocation(455, 113);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:455:14: ( (x1= expression08 -> $x1) ( options {greedy=true; } : OR x2= expression08 -> ^( OR $expression09 $x2) )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:455:16: (x1= expression08 -> $x1) ( options {greedy=true; } : OR x2= expression08 -> ^( OR $expression09 $x2) )*
			{
			DebugLocation(455, 16);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:455:16: (x1= expression08 -> $x1)
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:455:17: x1= expression08
			{
			DebugLocation(455, 19);
			PushFollow(Follow._expression08_in_expression093993);
			x1=expression08();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression08.Add(x1.Tree);


			{
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 455:33: -> $x1
			{
				DebugLocation(455, 37);
				adaptor.AddChild(root_0, stream_x1.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(455, 41);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:455:41: ( options {greedy=true; } : OR x2= expression08 -> ^( OR $expression09 $x2) )*
			try { DebugEnterSubRule(85);
			while (true)
			{
				int alt85=2;
				try { DebugEnterDecision(85, false);
				int LA85_1 = input.LA(1);

				if ((LA85_1==OR))
				{
					alt85 = 1;
				}


				} finally { DebugExitDecision(85); }
				switch ( alt85 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:455:66: OR x2= expression08
					{
					DebugLocation(455, 66);
					OR328=(IToken)Match(input,OR,Follow._OR_in_expression094010); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_OR.Add(OR328);

					DebugLocation(455, 71);
					PushFollow(Follow._expression08_in_expression094014);
					x2=expression08();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression08.Add(x2.Tree);


					{
					// AST REWRITE
					// elements: OR, expression09, x2
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 455:85: -> ^( OR $expression09 $x2)
					{
						DebugLocation(455, 88);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:455:88: ^( OR $expression09 $x2)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(455, 90);
						root_1 = (object)adaptor.BecomeRoot(stream_OR.NextNode(), root_1);

						DebugLocation(455, 94);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(455, 108);
						adaptor.AddChild(root_1, stream_x2.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop85;
				}
			}

			loop85:
				;

			} finally { DebugExitSubRule(85); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression09", 106);
			LeaveRule("expression09", 106);
			LeaveRule_expression09();
		}
		DebugLocation(455, 113);
		} finally { DebugExitRule(GrammarFileName, "expression09"); }
		return retval;

	}
	// $ANTLR end "expression09"

	partial void EnterRule_expression08();
	partial void LeaveRule_expression08();
	// $ANTLR start "expression08"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:457:1: expression08 : (x1= expression07 -> $x1) ( options {greedy=true; } : AND x2= expression07 -> ^( AND $expression08 $x2) )* ;
	[GrammarRule("expression08")]
	private AstParserRuleReturnScope<object, IToken> expression08()
	{
		EnterRule_expression08();
		EnterRule("expression08", 107);
		TraceIn("expression08", 107);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AND329 = default(IToken);
		AstParserRuleReturnScope<object, IToken> x1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x2 = default(AstParserRuleReturnScope<object, IToken>);

		object AND329_tree = default(object);
		RewriteRuleITokenStream stream_AND=new RewriteRuleITokenStream(adaptor,"token AND");
		RewriteRuleSubtreeStream stream_expression07=new RewriteRuleSubtreeStream(adaptor,"rule expression07");
		try { DebugEnterRule(GrammarFileName, "expression08");
		DebugLocation(457, 115);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:457:14: ( (x1= expression07 -> $x1) ( options {greedy=true; } : AND x2= expression07 -> ^( AND $expression08 $x2) )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:457:16: (x1= expression07 -> $x1) ( options {greedy=true; } : AND x2= expression07 -> ^( AND $expression08 $x2) )*
			{
			DebugLocation(457, 16);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:457:16: (x1= expression07 -> $x1)
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:457:17: x1= expression07
			{
			DebugLocation(457, 19);
			PushFollow(Follow._expression07_in_expression084040);
			x1=expression07();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression07.Add(x1.Tree);


			{
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 457:33: -> $x1
			{
				DebugLocation(457, 37);
				adaptor.AddChild(root_0, stream_x1.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(457, 41);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:457:41: ( options {greedy=true; } : AND x2= expression07 -> ^( AND $expression08 $x2) )*
			try { DebugEnterSubRule(86);
			while (true)
			{
				int alt86=2;
				try { DebugEnterDecision(86, false);
				int LA86_1 = input.LA(1);

				if ((LA86_1==AND))
				{
					alt86 = 1;
				}


				} finally { DebugExitDecision(86); }
				switch ( alt86 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:457:66: AND x2= expression07
					{
					DebugLocation(457, 66);
					AND329=(IToken)Match(input,AND,Follow._AND_in_expression084057); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_AND.Add(AND329);

					DebugLocation(457, 72);
					PushFollow(Follow._expression07_in_expression084061);
					x2=expression07();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression07.Add(x2.Tree);


					{
					// AST REWRITE
					// elements: AND, expression08, x2
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 457:86: -> ^( AND $expression08 $x2)
					{
						DebugLocation(457, 89);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:457:89: ^( AND $expression08 $x2)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(457, 91);
						root_1 = (object)adaptor.BecomeRoot(stream_AND.NextNode(), root_1);

						DebugLocation(457, 96);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(457, 110);
						adaptor.AddChild(root_1, stream_x2.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop86;
				}
			}

			loop86:
				;

			} finally { DebugExitSubRule(86); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression08", 107);
			LeaveRule("expression08", 107);
			LeaveRule_expression08();
		}
		DebugLocation(457, 115);
		} finally { DebugExitRule(GrammarFileName, "expression08"); }
		return retval;

	}
	// $ANTLR end "expression08"

	partial void EnterRule_expression07();
	partial void LeaveRule_expression07();
	// $ANTLR start "expression07"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:459:1: expression07 : (x1= expression06 -> $x1) ( options {greedy=true; } :op= operator06 x2= expression06 -> ^( $op $expression07 $x2) )* ;
	[GrammarRule("expression07")]
	private AstParserRuleReturnScope<object, IToken> expression07()
	{
		EnterRule_expression07();
		EnterRule("expression07", 108);
		TraceIn("expression07", 108);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> x1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> op = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x2 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_expression06=new RewriteRuleSubtreeStream(adaptor,"rule expression06");
		RewriteRuleSubtreeStream stream_operator06=new RewriteRuleSubtreeStream(adaptor,"rule operator06");
		try { DebugEnterRule(GrammarFileName, "expression07");
		DebugLocation(459, 125);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:459:14: ( (x1= expression06 -> $x1) ( options {greedy=true; } :op= operator06 x2= expression06 -> ^( $op $expression07 $x2) )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:459:16: (x1= expression06 -> $x1) ( options {greedy=true; } :op= operator06 x2= expression06 -> ^( $op $expression07 $x2) )*
			{
			DebugLocation(459, 16);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:459:16: (x1= expression06 -> $x1)
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:459:17: x1= expression06
			{
			DebugLocation(459, 19);
			PushFollow(Follow._expression06_in_expression074087);
			x1=expression06();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression06.Add(x1.Tree);


			{
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 459:33: -> $x1
			{
				DebugLocation(459, 37);
				adaptor.AddChild(root_0, stream_x1.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(459, 41);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:459:41: ( options {greedy=true; } :op= operator06 x2= expression06 -> ^( $op $expression07 $x2) )*
			try { DebugEnterSubRule(87);
			while (true)
			{
				int alt87=2;
				try { DebugEnterDecision(87, false);
				switch (input.LA(1))
				{
				case LT:
					{
					alt87 = 1;
					}
					break;
				case LTEQ:
					{
					alt87 = 1;
					}
					break;
				case GT:
					{
					alt87 = 1;
					}
					break;
				case GTEQ:
					{
					alt87 = 1;
					}
					break;
				case EQ:
					{
					alt87 = 1;
					}
					break;
				case NOTEQ:
					{
					alt87 = 1;
					}
					break;
				}

				} finally { DebugExitDecision(87); }
				switch ( alt87 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:459:66: op= operator06 x2= expression06
					{
					DebugLocation(459, 68);
					PushFollow(Follow._operator06_in_expression074106);
					op=operator06();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_operator06.Add(op.Tree);
					DebugLocation(459, 82);
					PushFollow(Follow._expression06_in_expression074110);
					x2=expression06();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression06.Add(x2.Tree);


					{
					// AST REWRITE
					// elements: op, expression07, x2
					// token labels: 
					// rule labels: op, x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.Tree:null);
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 459:96: -> ^( $op $expression07 $x2)
					{
						DebugLocation(459, 99);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:459:99: ^( $op $expression07 $x2)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(459, 102);
						root_1 = (object)adaptor.BecomeRoot(stream_op.NextNode(), root_1);

						DebugLocation(459, 106);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(459, 120);
						adaptor.AddChild(root_1, stream_x2.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop87;
				}
			}

			loop87:
				;

			} finally { DebugExitSubRule(87); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression07", 108);
			LeaveRule("expression07", 108);
			LeaveRule_expression07();
		}
		DebugLocation(459, 125);
		} finally { DebugExitRule(GrammarFileName, "expression07"); }
		return retval;

	}
	// $ANTLR end "expression07"

	partial void EnterRule_operator06();
	partial void LeaveRule_operator06();
	// $ANTLR start "operator06"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:461:1: operator06 : ( LT -> LT | LTEQ -> LTEQ | GT -> GT | GTEQ -> GTEQ | EQ -> EQ | NOTEQ -> NOTEQ );
	[GrammarRule("operator06")]
	private AstParserRuleReturnScope<object, IToken> operator06()
	{
		EnterRule_operator06();
		EnterRule("operator06", 109);
		TraceIn("operator06", 109);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LT330 = default(IToken);
		IToken LTEQ331 = default(IToken);
		IToken GT332 = default(IToken);
		IToken GTEQ333 = default(IToken);
		IToken EQ334 = default(IToken);
		IToken NOTEQ335 = default(IToken);

		object LT330_tree = default(object);
		object LTEQ331_tree = default(object);
		object GT332_tree = default(object);
		object GTEQ333_tree = default(object);
		object EQ334_tree = default(object);
		object NOTEQ335_tree = default(object);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_LTEQ=new RewriteRuleITokenStream(adaptor,"token LTEQ");
		RewriteRuleITokenStream stream_GT=new RewriteRuleITokenStream(adaptor,"token GT");
		RewriteRuleITokenStream stream_GTEQ=new RewriteRuleITokenStream(adaptor,"token GTEQ");
		RewriteRuleITokenStream stream_EQ=new RewriteRuleITokenStream(adaptor,"token EQ");
		RewriteRuleITokenStream stream_NOTEQ=new RewriteRuleITokenStream(adaptor,"token NOTEQ");
		try { DebugEnterRule(GrammarFileName, "operator06");
		DebugLocation(461, 5);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:461:12: ( LT -> LT | LTEQ -> LTEQ | GT -> GT | GTEQ -> GTEQ | EQ -> EQ | NOTEQ -> NOTEQ )
			int alt88=6;
			try { DebugEnterDecision(88, false);
			switch (input.LA(1))
			{
			case LT:
				{
				alt88 = 1;
				}
				break;
			case LTEQ:
				{
				alt88 = 2;
				}
				break;
			case GT:
				{
				alt88 = 3;
				}
				break;
			case GTEQ:
				{
				alt88 = 4;
				}
				break;
			case EQ:
				{
				alt88 = 5;
				}
				break;
			case NOTEQ:
				{
				alt88 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 88, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(88); }
			switch (alt88)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:461:14: LT
				{
				DebugLocation(461, 14);
				LT330=(IToken)Match(input,LT,Follow._LT_in_operator064134); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LT.Add(LT330);



				{
				// AST REWRITE
				// elements: LT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 461:17: -> LT
				{
					DebugLocation(461, 20);
					adaptor.AddChild(root_0, stream_LT.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:462:8: LTEQ
				{
				DebugLocation(462, 8);
				LTEQ331=(IToken)Match(input,LTEQ,Follow._LTEQ_in_operator064147); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LTEQ.Add(LTEQ331);



				{
				// AST REWRITE
				// elements: LTEQ
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 462:13: -> LTEQ
				{
					DebugLocation(462, 16);
					adaptor.AddChild(root_0, stream_LTEQ.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:463:8: GT
				{
				DebugLocation(463, 8);
				GT332=(IToken)Match(input,GT,Follow._GT_in_operator064160); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_GT.Add(GT332);



				{
				// AST REWRITE
				// elements: GT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 463:11: -> GT
				{
					DebugLocation(463, 14);
					adaptor.AddChild(root_0, stream_GT.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:464:8: GTEQ
				{
				DebugLocation(464, 8);
				GTEQ333=(IToken)Match(input,GTEQ,Follow._GTEQ_in_operator064173); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_GTEQ.Add(GTEQ333);



				{
				// AST REWRITE
				// elements: GTEQ
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 464:13: -> GTEQ
				{
					DebugLocation(464, 16);
					adaptor.AddChild(root_0, stream_GTEQ.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:465:8: EQ
				{
				DebugLocation(465, 8);
				EQ334=(IToken)Match(input,EQ,Follow._EQ_in_operator064186); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_EQ.Add(EQ334);



				{
				// AST REWRITE
				// elements: EQ
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 465:11: -> EQ
				{
					DebugLocation(465, 14);
					adaptor.AddChild(root_0, stream_EQ.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:466:8: NOTEQ
				{
				DebugLocation(466, 8);
				NOTEQ335=(IToken)Match(input,NOTEQ,Follow._NOTEQ_in_operator064199); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NOTEQ.Add(NOTEQ335);



				{
				// AST REWRITE
				// elements: NOTEQ
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 466:14: -> NOTEQ
				{
					DebugLocation(466, 17);
					adaptor.AddChild(root_0, stream_NOTEQ.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("operator06", 109);
			LeaveRule("operator06", 109);
			LeaveRule_operator06();
		}
		DebugLocation(467, 5);
		} finally { DebugExitRule(GrammarFileName, "operator06"); }
		return retval;

	}
	// $ANTLR end "operator06"

	partial void EnterRule_expression06();
	partial void LeaveRule_expression06();
	// $ANTLR start "expression06"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:469:1: expression06 : (x1= expression05 -> $x1) ( options {greedy=true; } : ( options {greedy=true; } : COLON x2= expression05 )+ -> ^( COLON ( expression05 )+ ) )? ;
	[GrammarRule("expression06")]
	private AstParserRuleReturnScope<object, IToken> expression06()
	{
		EnterRule_expression06();
		EnterRule("expression06", 110);
		TraceIn("expression06", 110);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COLON336 = default(IToken);
		AstParserRuleReturnScope<object, IToken> x1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x2 = default(AstParserRuleReturnScope<object, IToken>);

		object COLON336_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_expression05=new RewriteRuleSubtreeStream(adaptor,"rule expression05");
		try { DebugEnterRule(GrammarFileName, "expression06");
		DebugLocation(469, 144);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:469:14: ( (x1= expression05 -> $x1) ( options {greedy=true; } : ( options {greedy=true; } : COLON x2= expression05 )+ -> ^( COLON ( expression05 )+ ) )? )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:469:16: (x1= expression05 -> $x1) ( options {greedy=true; } : ( options {greedy=true; } : COLON x2= expression05 )+ -> ^( COLON ( expression05 )+ ) )?
			{
			DebugLocation(469, 16);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:469:16: (x1= expression05 -> $x1)
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:469:17: x1= expression05
			{
			DebugLocation(469, 19);
			PushFollow(Follow._expression05_in_expression064220);
			x1=expression05();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression05.Add(x1.Tree);


			{
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 469:33: -> $x1
			{
				DebugLocation(469, 37);
				adaptor.AddChild(root_0, stream_x1.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(469, 41);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:469:41: ( options {greedy=true; } : ( options {greedy=true; } : COLON x2= expression05 )+ -> ^( COLON ( expression05 )+ ) )?
			int alt90=2;
			try { DebugEnterSubRule(90);
			try { DebugEnterDecision(90, false);
			int LA90_1 = input.LA(1);

			if ((LA90_1==COLON))
			{
				alt90 = 1;
			}
			} finally { DebugExitDecision(90); }
			switch (alt90)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:469:66: ( options {greedy=true; } : COLON x2= expression05 )+
				{
				DebugLocation(469, 66);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:469:66: ( options {greedy=true; } : COLON x2= expression05 )+
				int cnt89=0;
				try { DebugEnterSubRule(89);
				while (true)
				{
					int alt89=2;
					try { DebugEnterDecision(89, false);
					int LA89_1 = input.LA(1);

					if ((LA89_1==COLON))
					{
						alt89 = 1;
					}


					} finally { DebugExitDecision(89); }
					switch (alt89)
					{
					case 1:
						DebugEnterAlt(1);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:469:91: COLON x2= expression05
						{
						DebugLocation(469, 91);
						COLON336=(IToken)Match(input,COLON,Follow._COLON_in_expression064246); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COLON.Add(COLON336);

						DebugLocation(469, 99);
						PushFollow(Follow._expression05_in_expression064250);
						x2=expression05();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expression05.Add(x2.Tree);

						}
						break;

					default:
						if (cnt89 >= 1)
							goto loop89;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee89 = new EarlyExitException( 89, input );
						DebugRecognitionException(eee89);
						throw eee89;
					}
					cnt89++;
				}
				loop89:
					;

				} finally { DebugExitSubRule(89); }



				{
				// AST REWRITE
				// elements: COLON, expression05
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 469:115: -> ^( COLON ( expression05 )+ )
				{
					DebugLocation(469, 118);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:469:118: ^( COLON ( expression05 )+ )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(469, 120);
					root_1 = (object)adaptor.BecomeRoot(stream_COLON.NextNode(), root_1);

					DebugLocation(469, 126);
					if (!(stream_expression05.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_expression05.HasNext )
					{
						DebugLocation(469, 127);
						adaptor.AddChild(root_1, stream_expression05.NextTree());

					}
					stream_expression05.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(90); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression06", 110);
			LeaveRule("expression06", 110);
			LeaveRule_expression06();
		}
		DebugLocation(469, 144);
		} finally { DebugExitRule(GrammarFileName, "expression06"); }
		return retval;

	}
	// $ANTLR end "expression06"

	partial void EnterRule_expression05();
	partial void LeaveRule_expression05();
	// $ANTLR start "expression05"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:471:1: expression05 : (x1= expression04 -> $x1) ( options {greedy=true; } :{...}? =>op= operator04 x2= expression04 -> ^( $op $expression05 $x2) )* ;
	[GrammarRule("expression05")]
	private AstParserRuleReturnScope<object, IToken> expression05()
	{
		EnterRule_expression05();
		EnterRule("expression05", 111);
		TraceIn("expression05", 111);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> x1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> op = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x2 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_expression04=new RewriteRuleSubtreeStream(adaptor,"rule expression04");
		RewriteRuleSubtreeStream stream_operator04=new RewriteRuleSubtreeStream(adaptor,"rule operator04");
		try { DebugEnterRule(GrammarFileName, "expression05");
		DebugLocation(471, 185);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:471:14: ( (x1= expression04 -> $x1) ( options {greedy=true; } :{...}? =>op= operator04 x2= expression04 -> ^( $op $expression05 $x2) )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:471:16: (x1= expression04 -> $x1) ( options {greedy=true; } :{...}? =>op= operator04 x2= expression04 -> ^( $op $expression05 $x2) )*
			{
			DebugLocation(471, 16);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:471:16: (x1= expression04 -> $x1)
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:471:17: x1= expression04
			{
			DebugLocation(471, 19);
			PushFollow(Follow._expression04_in_expression054277);
			x1=expression04();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression04.Add(x1.Tree);


			{
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 471:33: -> $x1
			{
				DebugLocation(471, 37);
				adaptor.AddChild(root_0, stream_x1.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(471, 41);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:471:41: ( options {greedy=true; } :{...}? =>op= operator04 x2= expression04 -> ^( $op $expression05 $x2) )*
			try { DebugEnterSubRule(91);
			while (true)
			{
				int alt91=2;
				try { DebugEnterDecision(91, false);
				int LA91_1 = input.LA(1);

				if ((LA91_1==PLUS) && (((True())||(Separator_CommaFollowsOrSpacesPrecede())||(!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight()))))
				{
					int LA91_2 = input.LA(2);

					if (((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())))
					{
						alt91 = 1;
					}


				}
				else if ((LA91_1==MINUS) && (((True())||(Separator_CommaFollowsOrSpacesPrecede())||(!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight()))))
				{
					int LA91_2 = input.LA(2);

					if (((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())))
					{
						alt91 = 1;
					}


				}


				} finally { DebugExitDecision(91); }
				switch ( alt91 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:471:66: {...}? =>op= operator04 x2= expression04
					{
					DebugLocation(471, 66);
					if (!((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())))
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "expression05", "!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight()");
					}
					DebugLocation(471, 128);
					PushFollow(Follow._operator04_in_expression054299);
					op=operator04();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_operator04.Add(op.Tree);
					DebugLocation(471, 142);
					PushFollow(Follow._expression04_in_expression054303);
					x2=expression04();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression04.Add(x2.Tree);


					{
					// AST REWRITE
					// elements: op, expression05, x2
					// token labels: 
					// rule labels: op, x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.Tree:null);
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 471:156: -> ^( $op $expression05 $x2)
					{
						DebugLocation(471, 159);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:471:159: ^( $op $expression05 $x2)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(471, 162);
						root_1 = (object)adaptor.BecomeRoot(stream_op.NextNode(), root_1);

						DebugLocation(471, 166);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(471, 180);
						adaptor.AddChild(root_1, stream_x2.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop91;
				}
			}

			loop91:
				;

			} finally { DebugExitSubRule(91); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression05", 111);
			LeaveRule("expression05", 111);
			LeaveRule_expression05();
		}
		DebugLocation(471, 185);
		} finally { DebugExitRule(GrammarFileName, "expression05"); }
		return retval;

	}
	// $ANTLR end "expression05"

	partial void EnterRule_operator04();
	partial void LeaveRule_operator04();
	// $ANTLR start "operator04"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:473:1: operator04 : ( PLUS -> PLUS | MINUS -> MINUS );
	[GrammarRule("operator04")]
	private AstParserRuleReturnScope<object, IToken> operator04()
	{
		EnterRule_operator04();
		EnterRule("operator04", 112);
		TraceIn("operator04", 112);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken PLUS337 = default(IToken);
		IToken MINUS338 = default(IToken);

		object PLUS337_tree = default(object);
		object MINUS338_tree = default(object);
		RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");
		RewriteRuleITokenStream stream_MINUS=new RewriteRuleITokenStream(adaptor,"token MINUS");
		try { DebugEnterRule(GrammarFileName, "operator04");
		DebugLocation(473, 5);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:473:12: ( PLUS -> PLUS | MINUS -> MINUS )
			int alt92=2;
			try { DebugEnterDecision(92, false);
			int LA92_1 = input.LA(1);

			if ((LA92_1==PLUS))
			{
				alt92 = 1;
			}
			else if ((LA92_1==MINUS))
			{
				alt92 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 92, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(92); }
			switch (alt92)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:473:14: PLUS
				{
				DebugLocation(473, 14);
				PLUS337=(IToken)Match(input,PLUS,Follow._PLUS_in_operator044327); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_PLUS.Add(PLUS337);



				{
				// AST REWRITE
				// elements: PLUS
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 473:19: -> PLUS
				{
					DebugLocation(473, 22);
					adaptor.AddChild(root_0, stream_PLUS.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:474:8: MINUS
				{
				DebugLocation(474, 8);
				MINUS338=(IToken)Match(input,MINUS,Follow._MINUS_in_operator044340); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MINUS.Add(MINUS338);



				{
				// AST REWRITE
				// elements: MINUS
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 474:14: -> MINUS
				{
					DebugLocation(474, 17);
					adaptor.AddChild(root_0, stream_MINUS.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("operator04", 112);
			LeaveRule("operator04", 112);
			LeaveRule_operator04();
		}
		DebugLocation(475, 5);
		} finally { DebugExitRule(GrammarFileName, "operator04"); }
		return retval;

	}
	// $ANTLR end "operator04"

	partial void EnterRule_expression04();
	partial void LeaveRule_expression04();
	// $ANTLR start "expression04"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:477:1: expression04 : (x1= expression03 -> $x1) ( options {greedy=true; } :op= operator03 x2= expression03 -> ^( $op $expression04 $x2) )* ;
	[GrammarRule("expression04")]
	private AstParserRuleReturnScope<object, IToken> expression04()
	{
		EnterRule_expression04();
		EnterRule("expression04", 113);
		TraceIn("expression04", 113);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> x1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> op = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x2 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_expression03=new RewriteRuleSubtreeStream(adaptor,"rule expression03");
		RewriteRuleSubtreeStream stream_operator03=new RewriteRuleSubtreeStream(adaptor,"rule operator03");
		try { DebugEnterRule(GrammarFileName, "expression04");
		DebugLocation(477, 125);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:477:14: ( (x1= expression03 -> $x1) ( options {greedy=true; } :op= operator03 x2= expression03 -> ^( $op $expression04 $x2) )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:477:16: (x1= expression03 -> $x1) ( options {greedy=true; } :op= operator03 x2= expression03 -> ^( $op $expression04 $x2) )*
			{
			DebugLocation(477, 16);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:477:16: (x1= expression03 -> $x1)
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:477:17: x1= expression03
			{
			DebugLocation(477, 19);
			PushFollow(Follow._expression03_in_expression044361);
			x1=expression03();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression03.Add(x1.Tree);


			{
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 477:33: -> $x1
			{
				DebugLocation(477, 37);
				adaptor.AddChild(root_0, stream_x1.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(477, 41);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:477:41: ( options {greedy=true; } :op= operator03 x2= expression03 -> ^( $op $expression04 $x2) )*
			try { DebugEnterSubRule(93);
			while (true)
			{
				int alt93=2;
				try { DebugEnterDecision(93, false);
				switch (input.LA(1))
				{
				case TIMES:
					{
					alt93 = 1;
					}
					break;
				case RDIV:
					{
					alt93 = 1;
					}
					break;
				case LDIV:
					{
					alt93 = 1;
					}
					break;
				case MTIMES:
					{
					alt93 = 1;
					}
					break;
				case MRDIV:
					{
					alt93 = 1;
					}
					break;
				case MLDIV:
					{
					alt93 = 1;
					}
					break;
				}

				} finally { DebugExitDecision(93); }
				switch ( alt93 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:477:66: op= operator03 x2= expression03
					{
					DebugLocation(477, 68);
					PushFollow(Follow._operator03_in_expression044380);
					op=operator03();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_operator03.Add(op.Tree);
					DebugLocation(477, 82);
					PushFollow(Follow._expression03_in_expression044384);
					x2=expression03();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression03.Add(x2.Tree);


					{
					// AST REWRITE
					// elements: op, expression04, x2
					// token labels: 
					// rule labels: op, x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.Tree:null);
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 477:96: -> ^( $op $expression04 $x2)
					{
						DebugLocation(477, 99);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:477:99: ^( $op $expression04 $x2)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(477, 102);
						root_1 = (object)adaptor.BecomeRoot(stream_op.NextNode(), root_1);

						DebugLocation(477, 106);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(477, 120);
						adaptor.AddChild(root_1, stream_x2.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop93;
				}
			}

			loop93:
				;

			} finally { DebugExitSubRule(93); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression04", 113);
			LeaveRule("expression04", 113);
			LeaveRule_expression04();
		}
		DebugLocation(477, 125);
		} finally { DebugExitRule(GrammarFileName, "expression04"); }
		return retval;

	}
	// $ANTLR end "expression04"

	partial void EnterRule_operator03();
	partial void LeaveRule_operator03();
	// $ANTLR start "operator03"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:479:1: operator03 : ( TIMES -> TIMES | RDIV -> RDIV | LDIV -> LDIV | MTIMES -> MTIMES | MRDIV -> MRDIV | MLDIV -> MLDIV );
	[GrammarRule("operator03")]
	private AstParserRuleReturnScope<object, IToken> operator03()
	{
		EnterRule_operator03();
		EnterRule("operator03", 114);
		TraceIn("operator03", 114);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TIMES339 = default(IToken);
		IToken RDIV340 = default(IToken);
		IToken LDIV341 = default(IToken);
		IToken MTIMES342 = default(IToken);
		IToken MRDIV343 = default(IToken);
		IToken MLDIV344 = default(IToken);

		object TIMES339_tree = default(object);
		object RDIV340_tree = default(object);
		object LDIV341_tree = default(object);
		object MTIMES342_tree = default(object);
		object MRDIV343_tree = default(object);
		object MLDIV344_tree = default(object);
		RewriteRuleITokenStream stream_TIMES=new RewriteRuleITokenStream(adaptor,"token TIMES");
		RewriteRuleITokenStream stream_RDIV=new RewriteRuleITokenStream(adaptor,"token RDIV");
		RewriteRuleITokenStream stream_LDIV=new RewriteRuleITokenStream(adaptor,"token LDIV");
		RewriteRuleITokenStream stream_MTIMES=new RewriteRuleITokenStream(adaptor,"token MTIMES");
		RewriteRuleITokenStream stream_MRDIV=new RewriteRuleITokenStream(adaptor,"token MRDIV");
		RewriteRuleITokenStream stream_MLDIV=new RewriteRuleITokenStream(adaptor,"token MLDIV");
		try { DebugEnterRule(GrammarFileName, "operator03");
		DebugLocation(479, 5);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:479:12: ( TIMES -> TIMES | RDIV -> RDIV | LDIV -> LDIV | MTIMES -> MTIMES | MRDIV -> MRDIV | MLDIV -> MLDIV )
			int alt94=6;
			try { DebugEnterDecision(94, false);
			switch (input.LA(1))
			{
			case TIMES:
				{
				alt94 = 1;
				}
				break;
			case RDIV:
				{
				alt94 = 2;
				}
				break;
			case LDIV:
				{
				alt94 = 3;
				}
				break;
			case MTIMES:
				{
				alt94 = 4;
				}
				break;
			case MRDIV:
				{
				alt94 = 5;
				}
				break;
			case MLDIV:
				{
				alt94 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 94, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(94); }
			switch (alt94)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:479:14: TIMES
				{
				DebugLocation(479, 14);
				TIMES339=(IToken)Match(input,TIMES,Follow._TIMES_in_operator034408); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_TIMES.Add(TIMES339);



				{
				// AST REWRITE
				// elements: TIMES
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 479:20: -> TIMES
				{
					DebugLocation(479, 23);
					adaptor.AddChild(root_0, stream_TIMES.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:480:8: RDIV
				{
				DebugLocation(480, 8);
				RDIV340=(IToken)Match(input,RDIV,Follow._RDIV_in_operator034421); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RDIV.Add(RDIV340);



				{
				// AST REWRITE
				// elements: RDIV
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 480:13: -> RDIV
				{
					DebugLocation(480, 16);
					adaptor.AddChild(root_0, stream_RDIV.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:481:8: LDIV
				{
				DebugLocation(481, 8);
				LDIV341=(IToken)Match(input,LDIV,Follow._LDIV_in_operator034434); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LDIV.Add(LDIV341);



				{
				// AST REWRITE
				// elements: LDIV
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 481:13: -> LDIV
				{
					DebugLocation(481, 16);
					adaptor.AddChild(root_0, stream_LDIV.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:482:8: MTIMES
				{
				DebugLocation(482, 8);
				MTIMES342=(IToken)Match(input,MTIMES,Follow._MTIMES_in_operator034447); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MTIMES.Add(MTIMES342);



				{
				// AST REWRITE
				// elements: MTIMES
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 482:15: -> MTIMES
				{
					DebugLocation(482, 18);
					adaptor.AddChild(root_0, stream_MTIMES.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:483:8: MRDIV
				{
				DebugLocation(483, 8);
				MRDIV343=(IToken)Match(input,MRDIV,Follow._MRDIV_in_operator034460); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MRDIV.Add(MRDIV343);



				{
				// AST REWRITE
				// elements: MRDIV
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 483:14: -> MRDIV
				{
					DebugLocation(483, 17);
					adaptor.AddChild(root_0, stream_MRDIV.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:484:8: MLDIV
				{
				DebugLocation(484, 8);
				MLDIV344=(IToken)Match(input,MLDIV,Follow._MLDIV_in_operator034473); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MLDIV.Add(MLDIV344);



				{
				// AST REWRITE
				// elements: MLDIV
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 484:14: -> MLDIV
				{
					DebugLocation(484, 17);
					adaptor.AddChild(root_0, stream_MLDIV.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("operator03", 114);
			LeaveRule("operator03", 114);
			LeaveRule_operator03();
		}
		DebugLocation(485, 5);
		} finally { DebugExitRule(GrammarFileName, "operator03"); }
		return retval;

	}
	// $ANTLR end "operator03"

	partial void EnterRule_expression03();
	partial void LeaveRule_expression03();
	// $ANTLR start "expression03"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:487:1: expression03 : (op= operator02 x1= expression03 -> ^( $op $x1) |x2= expression02 -> $x2);
	[GrammarRule("expression03")]
	private AstParserRuleReturnScope<object, IToken> expression03()
	{
		EnterRule_expression03();
		EnterRule("expression03", 115);
		TraceIn("expression03", 115);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> op = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x2 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_operator02=new RewriteRuleSubtreeStream(adaptor,"rule operator02");
		RewriteRuleSubtreeStream stream_expression03=new RewriteRuleSubtreeStream(adaptor,"rule expression03");
		RewriteRuleSubtreeStream stream_expression02=new RewriteRuleSubtreeStream(adaptor,"rule expression02");
		try { DebugEnterRule(GrammarFileName, "expression03");
		DebugLocation(487, 4);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:487:14: (op= operator02 x1= expression03 -> ^( $op $x1) |x2= expression02 -> $x2)
			int alt95=2;
			try { DebugEnterDecision(95, false);
			int LA95_1 = input.LA(1);

			if ((LA95_1==MINUS||LA95_1==NOT||LA95_1==PLUS))
			{
				alt95 = 1;
			}
			else if ((LA95_1==ID||LA95_1==IMAGINARY||LA95_1==LCURLY||(LA95_1>=LPAREN && LA95_1<=LSQUARE)||LA95_1==REAL||LA95_1==STRING))
			{
				alt95 = 2;
			}
			else if ((LA95_1==END) && ((Index_IsActive())))
			{
				alt95 = 2;
			}
			else if ((LA95_1==AT||LA95_1==QUESTION))
			{
				alt95 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 95, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(95); }
			switch (alt95)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:487:16: op= operator02 x1= expression03
				{
				DebugLocation(487, 18);
				PushFollow(Follow._operator02_in_expression034493);
				op=operator02();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_operator02.Add(op.Tree);
				DebugLocation(487, 32);
				PushFollow(Follow._expression03_in_expression034497);
				x1=expression03();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression03.Add(x1.Tree);


				{
				// AST REWRITE
				// elements: op, x1
				// token labels: 
				// rule labels: op, x1, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.Tree:null);
				RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 487:46: -> ^( $op $x1)
				{
					DebugLocation(487, 49);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:487:49: ^( $op $x1)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(487, 52);
					root_1 = (object)adaptor.BecomeRoot(stream_op.NextNode(), root_1);

					DebugLocation(487, 56);
					adaptor.AddChild(root_1, stream_x1.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:488:7: x2= expression02
				{
				DebugLocation(488, 9);
				PushFollow(Follow._expression02_in_expression034518);
				x2=expression02();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression02.Add(x2.Tree);


				{
				// AST REWRITE
				// elements: x2
				// token labels: 
				// rule labels: x2, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 488:23: -> $x2
				{
					DebugLocation(488, 27);
					adaptor.AddChild(root_0, stream_x2.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression03", 115);
			LeaveRule("expression03", 115);
			LeaveRule_expression03();
		}
		DebugLocation(489, 4);
		} finally { DebugExitRule(GrammarFileName, "expression03"); }
		return retval;

	}
	// $ANTLR end "expression03"

	partial void EnterRule_operator02();
	partial void LeaveRule_operator02();
	// $ANTLR start "operator02"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:491:1: operator02 : ( PLUS -> POSITIVE[$PLUS] | MINUS -> NEGATIVE[$MINUS] | NOT -> NOT );
	[GrammarRule("operator02")]
	private AstParserRuleReturnScope<object, IToken> operator02()
	{
		EnterRule_operator02();
		EnterRule("operator02", 116);
		TraceIn("operator02", 116);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken PLUS345 = default(IToken);
		IToken MINUS346 = default(IToken);
		IToken NOT347 = default(IToken);

		object PLUS345_tree = default(object);
		object MINUS346_tree = default(object);
		object NOT347_tree = default(object);
		RewriteRuleITokenStream stream_PLUS=new RewriteRuleITokenStream(adaptor,"token PLUS");
		RewriteRuleITokenStream stream_MINUS=new RewriteRuleITokenStream(adaptor,"token MINUS");
		RewriteRuleITokenStream stream_NOT=new RewriteRuleITokenStream(adaptor,"token NOT");
		try { DebugEnterRule(GrammarFileName, "operator02");
		DebugLocation(491, 5);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:491:12: ( PLUS -> POSITIVE[$PLUS] | MINUS -> NEGATIVE[$MINUS] | NOT -> NOT )
			int alt96=3;
			try { DebugEnterDecision(96, false);
			switch (input.LA(1))
			{
			case PLUS:
				{
				alt96 = 1;
				}
				break;
			case MINUS:
				{
				alt96 = 2;
				}
				break;
			case NOT:
				{
				alt96 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 96, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(96); }
			switch (alt96)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:491:14: PLUS
				{
				DebugLocation(491, 14);
				PLUS345=(IToken)Match(input,PLUS,Follow._PLUS_in_operator024537); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_PLUS.Add(PLUS345);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 491:19: -> POSITIVE[$PLUS]
				{
					DebugLocation(491, 22);
					adaptor.AddChild(root_0, (object)adaptor.Create(POSITIVE, PLUS345));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:492:8: MINUS
				{
				DebugLocation(492, 8);
				MINUS346=(IToken)Match(input,MINUS,Follow._MINUS_in_operator024551); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MINUS.Add(MINUS346);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 492:14: -> NEGATIVE[$MINUS]
				{
					DebugLocation(492, 17);
					adaptor.AddChild(root_0, (object)adaptor.Create(NEGATIVE, MINUS346));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:493:8: NOT
				{
				DebugLocation(493, 8);
				NOT347=(IToken)Match(input,NOT,Follow._NOT_in_operator024565); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NOT.Add(NOT347);



				{
				// AST REWRITE
				// elements: NOT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 493:12: -> NOT
				{
					DebugLocation(493, 15);
					adaptor.AddChild(root_0, stream_NOT.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("operator02", 116);
			LeaveRule("operator02", 116);
			LeaveRule_operator02();
		}
		DebugLocation(494, 5);
		} finally { DebugExitRule(GrammarFileName, "operator02"); }
		return retval;

	}
	// $ANTLR end "operator02"

	partial void EnterRule_expression02();
	partial void LeaveRule_expression02();
	// $ANTLR start "expression02"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:496:1: expression02 : (x1= expression00 -> $x1) ( options {greedy=true; } : (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) ) | ( TRANS -> ^( TRANS $expression02) ) | ( CTRANS -> ^( CTRANS $expression02) ) )* ;
	[GrammarRule("expression02")]
	private AstParserRuleReturnScope<object, IToken> expression02()
	{
		EnterRule_expression02();
		EnterRule("expression02", 117);
		TraceIn("expression02", 117);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TRANS348 = default(IToken);
		IToken CTRANS349 = default(IToken);
		AstParserRuleReturnScope<object, IToken> x1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> op = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x2 = default(AstParserRuleReturnScope<object, IToken>);

		object TRANS348_tree = default(object);
		object CTRANS349_tree = default(object);
		RewriteRuleITokenStream stream_TRANS=new RewriteRuleITokenStream(adaptor,"token TRANS");
		RewriteRuleITokenStream stream_CTRANS=new RewriteRuleITokenStream(adaptor,"token CTRANS");
		RewriteRuleSubtreeStream stream_expression00=new RewriteRuleSubtreeStream(adaptor,"rule expression00");
		RewriteRuleSubtreeStream stream_operator01=new RewriteRuleSubtreeStream(adaptor,"rule operator01");
		RewriteRuleSubtreeStream stream_expression01=new RewriteRuleSubtreeStream(adaptor,"rule expression01");
		try { DebugEnterRule(GrammarFileName, "expression02");
		DebugLocation(496, 9);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:496:14: ( (x1= expression00 -> $x1) ( options {greedy=true; } : (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) ) | ( TRANS -> ^( TRANS $expression02) ) | ( CTRANS -> ^( CTRANS $expression02) ) )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:496:16: (x1= expression00 -> $x1) ( options {greedy=true; } : (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) ) | ( TRANS -> ^( TRANS $expression02) ) | ( CTRANS -> ^( CTRANS $expression02) ) )*
			{
			DebugLocation(496, 16);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:496:16: (x1= expression00 -> $x1)
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:496:17: x1= expression00
			{
			DebugLocation(496, 19);
			PushFollow(Follow._expression00_in_expression024586);
			x1=expression00();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression00.Add(x1.Tree);


			{
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 496:33: -> $x1
			{
				DebugLocation(496, 37);
				adaptor.AddChild(root_0, stream_x1.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(497, 7);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:497:7: ( options {greedy=true; } : (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) ) | ( TRANS -> ^( TRANS $expression02) ) | ( CTRANS -> ^( CTRANS $expression02) ) )*
			try { DebugEnterSubRule(97);
			while (true)
			{
				int alt97=4;
				try { DebugEnterDecision(97, false);
				switch (input.LA(1))
				{
				case POW:
					{
					alt97 = 1;
					}
					break;
				case MPOW:
					{
					alt97 = 1;
					}
					break;
				case TRANS:
					{
					alt97 = 2;
					}
					break;
				case CTRANS:
					{
					alt97 = 3;
					}
					break;
				}

				} finally { DebugExitDecision(97); }
				switch ( alt97 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:498:9: (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) )
					{
					DebugLocation(498, 9);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:498:9: (op= operator01 x2= expression01 -> ^( $op $expression02 $x2) )
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:498:10: op= operator01 x2= expression01
					{
					DebugLocation(498, 12);
					PushFollow(Follow._operator01_in_expression024623);
					op=operator01();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_operator01.Add(op.Tree);
					DebugLocation(498, 26);
					PushFollow(Follow._expression01_in_expression024627);
					x2=expression01();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression01.Add(x2.Tree);


					{
					// AST REWRITE
					// elements: op, expression02, x2
					// token labels: 
					// rule labels: op, x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.Tree:null);
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 498:40: -> ^( $op $expression02 $x2)
					{
						DebugLocation(498, 43);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:498:43: ^( $op $expression02 $x2)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(498, 46);
						root_1 = (object)adaptor.BecomeRoot(stream_op.NextNode(), root_1);

						DebugLocation(498, 50);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(498, 64);
						adaptor.AddChild(root_1, stream_x2.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:499:9: ( TRANS -> ^( TRANS $expression02) )
					{
					DebugLocation(499, 9);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:499:9: ( TRANS -> ^( TRANS $expression02) )
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:499:10: TRANS
					{
					DebugLocation(499, 10);
					TRANS348=(IToken)Match(input,TRANS,Follow._TRANS_in_expression024652); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_TRANS.Add(TRANS348);



					{
					// AST REWRITE
					// elements: TRANS, expression02
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 499:16: -> ^( TRANS $expression02)
					{
						DebugLocation(499, 19);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:499:19: ^( TRANS $expression02)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(499, 21);
						root_1 = (object)adaptor.BecomeRoot(stream_TRANS.NextNode(), root_1);

						DebugLocation(499, 28);
						adaptor.AddChild(root_1, stream_retval.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:500:9: ( CTRANS -> ^( CTRANS $expression02) )
					{
					DebugLocation(500, 9);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:500:9: ( CTRANS -> ^( CTRANS $expression02) )
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:500:10: CTRANS
					{
					DebugLocation(500, 10);
					CTRANS349=(IToken)Match(input,CTRANS,Follow._CTRANS_in_expression024673); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_CTRANS.Add(CTRANS349);



					{
					// AST REWRITE
					// elements: CTRANS, expression02
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 500:17: -> ^( CTRANS $expression02)
					{
						DebugLocation(500, 20);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:500:20: ^( CTRANS $expression02)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(500, 22);
						root_1 = (object)adaptor.BecomeRoot(stream_CTRANS.NextNode(), root_1);

						DebugLocation(500, 30);
						adaptor.AddChild(root_1, stream_retval.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}


					}
					break;

				default:
					goto loop97;
				}
			}

			loop97:
				;

			} finally { DebugExitSubRule(97); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression02", 117);
			LeaveRule("expression02", 117);
			LeaveRule_expression02();
		}
		DebugLocation(501, 9);
		} finally { DebugExitRule(GrammarFileName, "expression02"); }
		return retval;

	}
	// $ANTLR end "expression02"

	partial void EnterRule_operator01();
	partial void LeaveRule_operator01();
	// $ANTLR start "operator01"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:503:1: operator01 : ( POW -> POW | MPOW -> MPOW );
	[GrammarRule("operator01")]
	private AstParserRuleReturnScope<object, IToken> operator01()
	{
		EnterRule_operator01();
		EnterRule("operator01", 118);
		TraceIn("operator01", 118);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken POW350 = default(IToken);
		IToken MPOW351 = default(IToken);

		object POW350_tree = default(object);
		object MPOW351_tree = default(object);
		RewriteRuleITokenStream stream_POW=new RewriteRuleITokenStream(adaptor,"token POW");
		RewriteRuleITokenStream stream_MPOW=new RewriteRuleITokenStream(adaptor,"token MPOW");
		try { DebugEnterRule(GrammarFileName, "operator01");
		DebugLocation(503, 5);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:503:12: ( POW -> POW | MPOW -> MPOW )
			int alt98=2;
			try { DebugEnterDecision(98, false);
			int LA98_1 = input.LA(1);

			if ((LA98_1==POW))
			{
				alt98 = 1;
			}
			else if ((LA98_1==MPOW))
			{
				alt98 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 98, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(98); }
			switch (alt98)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:503:14: POW
				{
				DebugLocation(503, 14);
				POW350=(IToken)Match(input,POW,Follow._POW_in_operator014702); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_POW.Add(POW350);



				{
				// AST REWRITE
				// elements: POW
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 503:18: -> POW
				{
					DebugLocation(503, 21);
					adaptor.AddChild(root_0, stream_POW.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:504:8: MPOW
				{
				DebugLocation(504, 8);
				MPOW351=(IToken)Match(input,MPOW,Follow._MPOW_in_operator014715); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MPOW.Add(MPOW351);



				{
				// AST REWRITE
				// elements: MPOW
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 504:13: -> MPOW
				{
					DebugLocation(504, 16);
					adaptor.AddChild(root_0, stream_MPOW.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("operator01", 118);
			LeaveRule("operator01", 118);
			LeaveRule_operator01();
		}
		DebugLocation(505, 5);
		} finally { DebugExitRule(GrammarFileName, "operator01"); }
		return retval;

	}
	// $ANTLR end "operator01"

	partial void EnterRule_expression01();
	partial void LeaveRule_expression01();
	// $ANTLR start "expression01"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:507:1: expression01 : (op= operator02 x1= expression01 -> ^( $op $x1) |x2= expression00 -> $x2);
	[GrammarRule("expression01")]
	private AstParserRuleReturnScope<object, IToken> expression01()
	{
		EnterRule_expression01();
		EnterRule("expression01", 119);
		TraceIn("expression01", 119);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> op = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x2 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_operator02=new RewriteRuleSubtreeStream(adaptor,"rule operator02");
		RewriteRuleSubtreeStream stream_expression01=new RewriteRuleSubtreeStream(adaptor,"rule expression01");
		RewriteRuleSubtreeStream stream_expression00=new RewriteRuleSubtreeStream(adaptor,"rule expression00");
		try { DebugEnterRule(GrammarFileName, "expression01");
		DebugLocation(507, 4);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:507:14: (op= operator02 x1= expression01 -> ^( $op $x1) |x2= expression00 -> $x2)
			int alt99=2;
			try { DebugEnterDecision(99, false);
			int LA99_1 = input.LA(1);

			if ((LA99_1==MINUS||LA99_1==NOT||LA99_1==PLUS))
			{
				alt99 = 1;
			}
			else if ((LA99_1==ID||LA99_1==IMAGINARY||LA99_1==LCURLY||(LA99_1>=LPAREN && LA99_1<=LSQUARE)||LA99_1==REAL||LA99_1==STRING))
			{
				alt99 = 2;
			}
			else if ((LA99_1==END) && ((Index_IsActive())))
			{
				alt99 = 2;
			}
			else if ((LA99_1==AT||LA99_1==QUESTION))
			{
				alt99 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 99, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(99); }
			switch (alt99)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:507:16: op= operator02 x1= expression01
				{
				DebugLocation(507, 18);
				PushFollow(Follow._operator02_in_expression014735);
				op=operator02();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_operator02.Add(op.Tree);
				DebugLocation(507, 32);
				PushFollow(Follow._expression01_in_expression014739);
				x1=expression01();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression01.Add(x1.Tree);


				{
				// AST REWRITE
				// elements: op, x1
				// token labels: 
				// rule labels: op, x1, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_op=new RewriteRuleSubtreeStream(adaptor,"rule op",op!=null?op.Tree:null);
				RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 507:46: -> ^( $op $x1)
				{
					DebugLocation(507, 49);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:507:49: ^( $op $x1)
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(507, 52);
					root_1 = (object)adaptor.BecomeRoot(stream_op.NextNode(), root_1);

					DebugLocation(507, 56);
					adaptor.AddChild(root_1, stream_x1.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:508:7: x2= expression00
				{
				DebugLocation(508, 9);
				PushFollow(Follow._expression00_in_expression014760);
				x2=expression00();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression00.Add(x2.Tree);


				{
				// AST REWRITE
				// elements: x2
				// token labels: 
				// rule labels: x2, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 508:23: -> $x2
				{
					DebugLocation(508, 27);
					adaptor.AddChild(root_0, stream_x2.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression01", 119);
			LeaveRule("expression01", 119);
			LeaveRule_expression01();
		}
		DebugLocation(509, 4);
		} finally { DebugExitRule(GrammarFileName, "expression01"); }
		return retval;

	}
	// $ANTLR end "expression01"

	partial void EnterRule_expression00();
	partial void LeaveRule_expression00();
	// $ANTLR start "expression00"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:511:1: expression00 : atom -> atom ;
	[GrammarRule("expression00")]
	private AstParserRuleReturnScope<object, IToken> expression00()
	{
		EnterRule_expression00();
		EnterRule("expression00", 120);
		TraceIn("expression00", 120);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> atom352 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_atom=new RewriteRuleSubtreeStream(adaptor,"rule atom");
		try { DebugEnterRule(GrammarFileName, "expression00");
		DebugLocation(511, 28);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:511:14: ( atom -> atom )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:511:16: atom
			{
			DebugLocation(511, 16);
			PushFollow(Follow._atom_in_expression004779);
			atom352=atom();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_atom.Add(atom352.Tree);


			{
			// AST REWRITE
			// elements: atom
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 511:21: -> atom
			{
				DebugLocation(511, 24);
				adaptor.AddChild(root_0, stream_atom.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression00", 120);
			LeaveRule("expression00", 120);
			LeaveRule_expression00();
		}
		DebugLocation(511, 28);
		} finally { DebugExitRule(GrammarFileName, "expression00"); }
		return retval;

	}
	// $ANTLR end "expression00"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();
	// $ANTLR start "atom"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:515:1: atom : ( chain -> chain | real -> real | imaginary -> imaginary | string -> string | regularArray -> regularArray | cellArray -> cellArray | parenthesized -> parenthesized | end -> end | functionHandle -> functionHandle | anonymousFunction -> anonymousFunction | metaclass -> metaclass );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 121);
		TraceIn("atom", 121);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> chain353 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> real354 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> imaginary355 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> string356 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> regularArray357 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> cellArray358 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> parenthesized359 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> end360 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> functionHandle361 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> anonymousFunction362 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> metaclass363 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_chain=new RewriteRuleSubtreeStream(adaptor,"rule chain");
		RewriteRuleSubtreeStream stream_real=new RewriteRuleSubtreeStream(adaptor,"rule real");
		RewriteRuleSubtreeStream stream_imaginary=new RewriteRuleSubtreeStream(adaptor,"rule imaginary");
		RewriteRuleSubtreeStream stream_string=new RewriteRuleSubtreeStream(adaptor,"rule string");
		RewriteRuleSubtreeStream stream_regularArray=new RewriteRuleSubtreeStream(adaptor,"rule regularArray");
		RewriteRuleSubtreeStream stream_cellArray=new RewriteRuleSubtreeStream(adaptor,"rule cellArray");
		RewriteRuleSubtreeStream stream_parenthesized=new RewriteRuleSubtreeStream(adaptor,"rule parenthesized");
		RewriteRuleSubtreeStream stream_end=new RewriteRuleSubtreeStream(adaptor,"rule end");
		RewriteRuleSubtreeStream stream_functionHandle=new RewriteRuleSubtreeStream(adaptor,"rule functionHandle");
		RewriteRuleSubtreeStream stream_anonymousFunction=new RewriteRuleSubtreeStream(adaptor,"rule anonymousFunction");
		RewriteRuleSubtreeStream stream_metaclass=new RewriteRuleSubtreeStream(adaptor,"rule metaclass");
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(515, 2);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:515:6: ( chain -> chain | real -> real | imaginary -> imaginary | string -> string | regularArray -> regularArray | cellArray -> cellArray | parenthesized -> parenthesized | end -> end | functionHandle -> functionHandle | anonymousFunction -> anonymousFunction | metaclass -> metaclass )
			int alt100=11;
			try { DebugEnterDecision(100, false);
			int LA100_1 = input.LA(1);

			if ((LA100_1==ID))
			{
				alt100 = 1;
			}
			else if ((LA100_1==REAL))
			{
				alt100 = 2;
			}
			else if ((LA100_1==IMAGINARY))
			{
				alt100 = 3;
			}
			else if ((LA100_1==STRING))
			{
				alt100 = 4;
			}
			else if ((LA100_1==LSQUARE))
			{
				alt100 = 5;
			}
			else if ((LA100_1==LCURLY))
			{
				alt100 = 6;
			}
			else if ((LA100_1==LPAREN))
			{
				alt100 = 7;
			}
			else if ((LA100_1==END) && ((Index_IsActive())))
			{
				alt100 = 8;
			}
			else if ((LA100_1==AT))
			{
				int LA100_2 = input.LA(2);

				if ((LA100_2==ID))
				{
					alt100 = 9;
				}
				else if ((LA100_2==LPAREN))
				{
					alt100 = 10;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 100, 9, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA100_1==QUESTION))
			{
				alt100 = 11;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 100, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(100); }
			switch (alt100)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:515:8: chain
				{
				DebugLocation(515, 8);
				PushFollow(Follow._chain_in_atom4794);
				chain353=chain();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_chain.Add(chain353.Tree);


				{
				// AST REWRITE
				// elements: chain
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 515:14: -> chain
				{
					DebugLocation(515, 17);
					adaptor.AddChild(root_0, stream_chain.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:516:8: real
				{
				DebugLocation(516, 8);
				PushFollow(Follow._real_in_atom4808);
				real354=real();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_real.Add(real354.Tree);


				{
				// AST REWRITE
				// elements: real
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 516:13: -> real
				{
					DebugLocation(516, 16);
					adaptor.AddChild(root_0, stream_real.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:517:5: imaginary
				{
				DebugLocation(517, 5);
				PushFollow(Follow._imaginary_in_atom4819);
				imaginary355=imaginary();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_imaginary.Add(imaginary355.Tree);


				{
				// AST REWRITE
				// elements: imaginary
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 517:15: -> imaginary
				{
					DebugLocation(517, 18);
					adaptor.AddChild(root_0, stream_imaginary.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:518:5: string
				{
				DebugLocation(518, 5);
				PushFollow(Follow._string_in_atom4830);
				string356=@string();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_string.Add(string356.Tree);


				{
				// AST REWRITE
				// elements: string
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 518:12: -> string
				{
					DebugLocation(518, 15);
					adaptor.AddChild(root_0, stream_string.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:519:5: regularArray
				{
				DebugLocation(519, 5);
				PushFollow(Follow._regularArray_in_atom4841);
				regularArray357=regularArray();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_regularArray.Add(regularArray357.Tree);


				{
				// AST REWRITE
				// elements: regularArray
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 519:18: -> regularArray
				{
					DebugLocation(519, 21);
					adaptor.AddChild(root_0, stream_regularArray.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:520:5: cellArray
				{
				DebugLocation(520, 5);
				PushFollow(Follow._cellArray_in_atom4852);
				cellArray358=cellArray();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_cellArray.Add(cellArray358.Tree);


				{
				// AST REWRITE
				// elements: cellArray
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 520:15: -> cellArray
				{
					DebugLocation(520, 18);
					adaptor.AddChild(root_0, stream_cellArray.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:521:5: parenthesized
				{
				DebugLocation(521, 5);
				PushFollow(Follow._parenthesized_in_atom4863);
				parenthesized359=parenthesized();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parenthesized.Add(parenthesized359.Tree);


				{
				// AST REWRITE
				// elements: parenthesized
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 521:19: -> parenthesized
				{
					DebugLocation(521, 22);
					adaptor.AddChild(root_0, stream_parenthesized.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:522:5: end
				{
				DebugLocation(522, 5);
				PushFollow(Follow._end_in_atom4874);
				end360=end();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_end.Add(end360.Tree);


				{
				// AST REWRITE
				// elements: end
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 522:9: -> end
				{
					DebugLocation(522, 12);
					adaptor.AddChild(root_0, stream_end.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:523:5: functionHandle
				{
				DebugLocation(523, 5);
				PushFollow(Follow._functionHandle_in_atom4885);
				functionHandle361=functionHandle();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_functionHandle.Add(functionHandle361.Tree);


				{
				// AST REWRITE
				// elements: functionHandle
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 523:20: -> functionHandle
				{
					DebugLocation(523, 23);
					adaptor.AddChild(root_0, stream_functionHandle.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:524:5: anonymousFunction
				{
				DebugLocation(524, 5);
				PushFollow(Follow._anonymousFunction_in_atom4896);
				anonymousFunction362=anonymousFunction();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_anonymousFunction.Add(anonymousFunction362.Tree);


				{
				// AST REWRITE
				// elements: anonymousFunction
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 524:23: -> anonymousFunction
				{
					DebugLocation(524, 26);
					adaptor.AddChild(root_0, stream_anonymousFunction.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:525:5: metaclass
				{
				DebugLocation(525, 5);
				PushFollow(Follow._metaclass_in_atom4907);
				metaclass363=metaclass();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_metaclass.Add(metaclass363.Tree);


				{
				// AST REWRITE
				// elements: metaclass
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 525:15: -> metaclass
				{
					DebugLocation(525, 18);
					adaptor.AddChild(root_0, stream_metaclass.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 121);
			LeaveRule("atom", 121);
			LeaveRule_atom();
		}
		DebugLocation(526, 2);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_chain();
	partial void LeaveRule_chain();
	// $ANTLR start "chain"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:530:1: chain : (x1= var -> $x1) ( ( DOT LPAREN )=>x2= dotExpressionOperator -> ^( DOTEXPRESSION[$x2.start] $chain $x2) |x3= dotNameOperator -> ^( DOTNAME[$x3.start] $chain $x3) |x4= parenthesisOperator -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? ) |x5= curlyBraceOperator -> ^( CURLYBRACE[$x5.start] $chain $x5) |x6= atBaseOperator -> ^( ATBASE[$x6.start] $chain $x6) )* ;
	[GrammarRule("chain")]
	private AstParserRuleReturnScope<object, IToken> chain()
	{
		EnterRule_chain();
		EnterRule("chain", 122);
		TraceIn("chain", 122);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> x1 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x2 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x3 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x4 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x5 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> x6 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_var=new RewriteRuleSubtreeStream(adaptor,"rule var");
		RewriteRuleSubtreeStream stream_dotExpressionOperator=new RewriteRuleSubtreeStream(adaptor,"rule dotExpressionOperator");
		RewriteRuleSubtreeStream stream_dotNameOperator=new RewriteRuleSubtreeStream(adaptor,"rule dotNameOperator");
		RewriteRuleSubtreeStream stream_parenthesisOperator=new RewriteRuleSubtreeStream(adaptor,"rule parenthesisOperator");
		RewriteRuleSubtreeStream stream_curlyBraceOperator=new RewriteRuleSubtreeStream(adaptor,"rule curlyBraceOperator");
		RewriteRuleSubtreeStream stream_atBaseOperator=new RewriteRuleSubtreeStream(adaptor,"rule atBaseOperator");
		Chain_Begin();
		try { DebugEnterRule(GrammarFileName, "chain");
		DebugLocation(530, 3);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:531:24: ( (x1= var -> $x1) ( ( DOT LPAREN )=>x2= dotExpressionOperator -> ^( DOTEXPRESSION[$x2.start] $chain $x2) |x3= dotNameOperator -> ^( DOTNAME[$x3.start] $chain $x3) |x4= parenthesisOperator -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? ) |x5= curlyBraceOperator -> ^( CURLYBRACE[$x5.start] $chain $x5) |x6= atBaseOperator -> ^( ATBASE[$x6.start] $chain $x6) )* )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:532:2: (x1= var -> $x1) ( ( DOT LPAREN )=>x2= dotExpressionOperator -> ^( DOTEXPRESSION[$x2.start] $chain $x2) |x3= dotNameOperator -> ^( DOTNAME[$x3.start] $chain $x3) |x4= parenthesisOperator -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? ) |x5= curlyBraceOperator -> ^( CURLYBRACE[$x5.start] $chain $x5) |x6= atBaseOperator -> ^( ATBASE[$x6.start] $chain $x6) )*
			{
			DebugLocation(532, 2);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:532:2: (x1= var -> $x1)
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:532:2: x1= var
			{
			DebugLocation(532, 4);
			PushFollow(Follow._var_in_chain4936);
			x1=var();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_var.Add(x1.Tree);


			{
			// AST REWRITE
			// elements: x1
			// token labels: 
			// rule labels: x1, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_x1=new RewriteRuleSubtreeStream(adaptor,"rule x1",x1!=null?x1.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 532:9: -> $x1
			{
				DebugLocation(532, 13);
				adaptor.AddChild(root_0, stream_x1.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(533, 5);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:533:5: ( ( DOT LPAREN )=>x2= dotExpressionOperator -> ^( DOTEXPRESSION[$x2.start] $chain $x2) |x3= dotNameOperator -> ^( DOTNAME[$x3.start] $chain $x3) |x4= parenthesisOperator -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? ) |x5= curlyBraceOperator -> ^( CURLYBRACE[$x5.start] $chain $x5) |x6= atBaseOperator -> ^( ATBASE[$x6.start] $chain $x6) )*
			try { DebugEnterSubRule(101);
			while (true)
			{
				int alt101=6;
				try { DebugEnterDecision(101, false);
				try
				{
					alt101 = dfa101.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(101); }
				switch ( alt101 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:533:5: ( DOT LPAREN )=>x2= dotExpressionOperator
					{
					DebugLocation(533, 22);
					PushFollow(Follow._dotExpressionOperator_in_chain4957);
					x2=dotExpressionOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_dotExpressionOperator.Add(x2.Tree);


					{
					// AST REWRITE
					// elements: chain, x2
					// token labels: 
					// rule labels: x2, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_x2=new RewriteRuleSubtreeStream(adaptor,"rule x2",x2!=null?x2.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 533:45: -> ^( DOTEXPRESSION[$x2.start] $chain $x2)
					{
						DebugLocation(533, 48);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:533:48: ^( DOTEXPRESSION[$x2.start] $chain $x2)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(533, 50);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DOTEXPRESSION, (x2!=null?((IToken)x2.Start):default(IToken))), root_1);

						DebugLocation(533, 76);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(533, 83);
						adaptor.AddChild(root_1, stream_x2.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:534:5: x3= dotNameOperator
					{
					DebugLocation(534, 7);
					PushFollow(Follow._dotNameOperator_in_chain4979);
					x3=dotNameOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_dotNameOperator.Add(x3.Tree);


					{
					// AST REWRITE
					// elements: chain, x3
					// token labels: 
					// rule labels: x3, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_x3=new RewriteRuleSubtreeStream(adaptor,"rule x3",x3!=null?x3.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 534:24: -> ^( DOTNAME[$x3.start] $chain $x3)
					{
						DebugLocation(534, 27);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:534:27: ^( DOTNAME[$x3.start] $chain $x3)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(534, 29);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(DOTNAME, (x3!=null?((IToken)x3.Start):default(IToken))), root_1);

						DebugLocation(534, 49);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(534, 56);
						adaptor.AddChild(root_1, stream_x3.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:535:5: x4= parenthesisOperator
					{
					DebugLocation(535, 7);
					PushFollow(Follow._parenthesisOperator_in_chain5001);
					x4=parenthesisOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_parenthesisOperator.Add(x4.Tree);


					{
					// AST REWRITE
					// elements: chain, x4
					// token labels: 
					// rule labels: x4, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_x4=new RewriteRuleSubtreeStream(adaptor,"rule x4",x4!=null?x4.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 535:28: -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? )
					{
						DebugLocation(535, 31);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:535:31: ^( PARENTHESIS[$x4.start] $chain ( $x4)? )
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(535, 33);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARENTHESIS, (x4!=null?((IToken)x4.Start):default(IToken))), root_1);

						DebugLocation(535, 57);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(535, 63);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:535:63: ( $x4)?
						if (stream_x4.HasNext)
						{
							DebugLocation(535, 65);
							adaptor.AddChild(root_1, stream_x4.NextTree());

						}
						stream_x4.Reset();

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:536:5: x5= curlyBraceOperator
					{
					DebugLocation(536, 7);
					PushFollow(Follow._curlyBraceOperator_in_chain5026);
					x5=curlyBraceOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_curlyBraceOperator.Add(x5.Tree);


					{
					// AST REWRITE
					// elements: chain, x5
					// token labels: 
					// rule labels: x5, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_x5=new RewriteRuleSubtreeStream(adaptor,"rule x5",x5!=null?x5.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 536:27: -> ^( CURLYBRACE[$x5.start] $chain $x5)
					{
						DebugLocation(536, 30);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:536:30: ^( CURLYBRACE[$x5.start] $chain $x5)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(536, 32);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CURLYBRACE, (x5!=null?((IToken)x5.Start):default(IToken))), root_1);

						DebugLocation(536, 55);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(536, 62);
						adaptor.AddChild(root_1, stream_x5.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:537:5: x6= atBaseOperator
					{
					DebugLocation(537, 7);
					PushFollow(Follow._atBaseOperator_in_chain5048);
					x6=atBaseOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_atBaseOperator.Add(x6.Tree);


					{
					// AST REWRITE
					// elements: chain, x6
					// token labels: 
					// rule labels: x6, retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_x6=new RewriteRuleSubtreeStream(adaptor,"rule x6",x6!=null?x6.Tree:null);
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (object)adaptor.Nil();
					// 537:23: -> ^( ATBASE[$x6.start] $chain $x6)
					{
						DebugLocation(537, 26);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:537:26: ^( ATBASE[$x6.start] $chain $x6)
						{
						object root_1 = (object)adaptor.Nil();
						DebugLocation(537, 28);
						root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ATBASE, (x6!=null?((IToken)x6.Start):default(IToken))), root_1);

						DebugLocation(537, 47);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(537, 54);
						adaptor.AddChild(root_1, stream_x6.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop101;
				}
			}

			loop101:
				;

			} finally { DebugExitSubRule(101); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("chain", 122);
			LeaveRule("chain", 122);
			LeaveRule_chain();
			Chain_End();
		}
		DebugLocation(538, 3);
		} finally { DebugExitRule(GrammarFileName, "chain"); }
		return retval;

	}
	// $ANTLR end "chain"

	partial void EnterRule_var();
	partial void LeaveRule_var();
	// $ANTLR start "var"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:541:1: var : name -> ^( VAR[\"\"] name ) ;
	[GrammarRule("var")]
	private AstParserRuleReturnScope<object, IToken> var()
	{
		EnterRule_var();
		EnterRule("var", 123);
		TraceIn("var", 123);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> name364 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_name=new RewriteRuleSubtreeStream(adaptor,"rule name");
		try { DebugEnterRule(GrammarFileName, "var");
		DebugLocation(541, 30);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:541:5: ( name -> ^( VAR[\"\"] name ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:541:7: name
			{
			DebugLocation(541, 7);
			PushFollow(Follow._name_in_var5078);
			name364=name();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_name.Add(name364.Tree);


			{
			// AST REWRITE
			// elements: name
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 541:12: -> ^( VAR[\"\"] name )
			{
				DebugLocation(541, 15);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:541:15: ^( VAR[\"\"] name )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(541, 17);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, ""), root_1);

				DebugLocation(541, 25);
				adaptor.AddChild(root_1, stream_name.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("var", 123);
			LeaveRule("var", 123);
			LeaveRule_var();
		}
		DebugLocation(541, 30);
		} finally { DebugExitRule(GrammarFileName, "var"); }
		return retval;

	}
	// $ANTLR end "var"

	partial void EnterRule_dotExpressionOperator();
	partial void LeaveRule_dotExpressionOperator();
	// $ANTLR start "dotExpressionOperator"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:543:1: dotExpressionOperator :{...}? => DOT LPAREN expression RPAREN -> expression ;
	[GrammarRule("dotExpressionOperator")]
	private AstParserRuleReturnScope<object, IToken> dotExpressionOperator()
	{
		EnterRule_dotExpressionOperator();
		EnterRule("dotExpressionOperator", 124);
		TraceIn("dotExpressionOperator", 124);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DOT365 = default(IToken);
		IToken LPAREN366 = default(IToken);
		IToken RPAREN368 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression367 = default(AstParserRuleReturnScope<object, IToken>);

		object DOT365_tree = default(object);
		object LPAREN366_tree = default(object);
		object RPAREN368_tree = default(object);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		Balance_EnterParenthesis();
		try { DebugEnterRule(GrammarFileName, "dotExpressionOperator");
		DebugLocation(543, 76);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:544:37: ({...}? => DOT LPAREN expression RPAREN -> expression )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:545:1: {...}? => DOT LPAREN expression RPAREN
			{
			DebugLocation(545, 1);
			if (!((Chain_MayAddDotExpression())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "dotExpressionOperator", "Chain_MayAddDotExpression()");
			}
			DebugLocation(545, 34);
			DOT365=(IToken)Match(input,DOT,Follow._DOT_in_dotExpressionOperator5106); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DOT.Add(DOT365);

			DebugLocation(545, 38);
			LPAREN366=(IToken)Match(input,LPAREN,Follow._LPAREN_in_dotExpressionOperator5108); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN366);

			DebugLocation(545, 45);
			PushFollow(Follow._expression_in_dotExpressionOperator5110);
			expression367=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression367.Tree);
			DebugLocation(545, 56);
			RPAREN368=(IToken)Match(input,RPAREN,Follow._RPAREN_in_dotExpressionOperator5112); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN368);



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 545:63: -> expression
			{
				DebugLocation(545, 66);
				adaptor.AddChild(root_0, stream_expression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("dotExpressionOperator", 124);
			LeaveRule("dotExpressionOperator", 124);
			LeaveRule_dotExpressionOperator();
			Balance_ExitParenthesis(); Chain_AddedDotExpression();
		}
		DebugLocation(545, 76);
		} finally { DebugExitRule(GrammarFileName, "dotExpressionOperator"); }
		return retval;

	}
	// $ANTLR end "dotExpressionOperator"

	partial void EnterRule_dotNameOperator();
	partial void LeaveRule_dotNameOperator();
	// $ANTLR start "dotNameOperator"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:548:1: dotNameOperator :{...}? => DOT anyName -> anyName ;
	[GrammarRule("dotNameOperator")]
	private AstParserRuleReturnScope<object, IToken> dotNameOperator()
	{
		EnterRule_dotNameOperator();
		EnterRule("dotNameOperator", 125);
		TraceIn("dotNameOperator", 125);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DOT369 = default(IToken);
		AstParserRuleReturnScope<object, IToken> anyName370 = default(AstParserRuleReturnScope<object, IToken>);

		object DOT369_tree = default(object);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_anyName=new RewriteRuleSubtreeStream(adaptor,"rule anyName");
		try { DebugEnterRule(GrammarFileName, "dotNameOperator");
		DebugLocation(548, 68);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:548:17: ({...}? => DOT anyName -> anyName )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:548:19: {...}? => DOT anyName
			{
			DebugLocation(548, 19);
			if (!((Chain_MayAddDotName())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "dotNameOperator", "Chain_MayAddDotName()");
			}
			DebugLocation(548, 46);
			DOT369=(IToken)Match(input,DOT,Follow._DOT_in_dotNameOperator5133); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DOT.Add(DOT369);

			DebugLocation(548, 50);
			PushFollow(Follow._anyName_in_dotNameOperator5135);
			anyName370=anyName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_anyName.Add(anyName370.Tree);


			{
			// AST REWRITE
			// elements: anyName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 548:58: -> anyName
			{
				DebugLocation(548, 61);
				adaptor.AddChild(root_0, stream_anyName.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("dotNameOperator", 125);
			LeaveRule("dotNameOperator", 125);
			LeaveRule_dotNameOperator();
			Chain_AddedDotName();
		}
		DebugLocation(548, 68);
		} finally { DebugExitRule(GrammarFileName, "dotNameOperator"); }
		return retval;

	}
	// $ANTLR end "dotNameOperator"

	partial void EnterRule_anyName();
	partial void LeaveRule_anyName();
	// $ANTLR start "anyName"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:551:1: anyName : xANYID -> ^( NAME[\"\"] xANYID ) ;
	[GrammarRule("anyName")]
	private AstParserRuleReturnScope<object, IToken> anyName()
	{
		EnterRule_anyName();
		EnterRule("anyName", 126);
		TraceIn("anyName", 126);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> xANYID371 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_xANYID=new RewriteRuleSubtreeStream(adaptor,"rule xANYID");
		try { DebugEnterRule(GrammarFileName, "anyName");
		DebugLocation(551, 39);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:551:9: ( xANYID -> ^( NAME[\"\"] xANYID ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:551:11: xANYID
			{
			DebugLocation(551, 11);
			PushFollow(Follow._xANYID_in_anyName5152);
			xANYID371=xANYID();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xANYID.Add(xANYID371.Tree);


			{
			// AST REWRITE
			// elements: xANYID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 551:18: -> ^( NAME[\"\"] xANYID )
			{
				DebugLocation(551, 21);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:551:21: ^( NAME[\"\"] xANYID )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(551, 23);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAME, ""), root_1);

				DebugLocation(551, 32);
				adaptor.AddChild(root_1, stream_xANYID.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("anyName", 126);
			LeaveRule("anyName", 126);
			LeaveRule_anyName();
		}
		DebugLocation(551, 39);
		} finally { DebugExitRule(GrammarFileName, "anyName"); }
		return retval;

	}
	// $ANTLR end "anyName"

	partial void EnterRule_parenthesisOperator();
	partial void LeaveRule_parenthesisOperator();
	// $ANTLR start "parenthesisOperator"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:553:1: parenthesisOperator :{...}? =>{...}? => LPAREN ( arguments )? RPAREN -> ( arguments )? ;
	[GrammarRule("parenthesisOperator")]
	private AstParserRuleReturnScope<object, IToken> parenthesisOperator()
	{
		EnterRule_parenthesisOperator();
		EnterRule("parenthesisOperator", 127);
		TraceIn("parenthesisOperator", 127);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN372 = default(IToken);
		IToken RPAREN374 = default(IToken);
		AstParserRuleReturnScope<object, IToken> arguments373 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN372_tree = default(object);
		object RPAREN374_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		Index_EnterParenthesis(); Balance_EnterParenthesis();
		try { DebugEnterRule(GrammarFileName, "parenthesisOperator");
		DebugLocation(553, 121);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:554:63: ({...}? =>{...}? => LPAREN ( arguments )? RPAREN -> ( arguments )? )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:555:1: {...}? =>{...}? => LPAREN ( arguments )? RPAREN
			{
			DebugLocation(555, 1);
			if (!((Chain_MayAddParenthesis())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "parenthesisOperator", "Chain_MayAddParenthesis()");
			}
			DebugLocation(555, 32);
			if (!((!Balance_InCreationOrStore_SpacesOnLeft())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "parenthesisOperator", "!Balance_InCreationOrStore_SpacesOnLeft()");
			}
			DebugLocation(555, 79);
			LPAREN372=(IToken)Match(input,LPAREN,Follow._LPAREN_in_parenthesisOperator5182); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN372);

			DebugLocation(555, 86);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:555:86: ( arguments )?
			int alt102=2;
			try { DebugEnterSubRule(102);
			try { DebugEnterDecision(102, false);
			int LA102_1 = input.LA(1);

			if ((LA102_1==ID||LA102_1==IMAGINARY||LA102_1==LCURLY||(LA102_1>=LPAREN && LA102_1<=LSQUARE)||LA102_1==MINUS||LA102_1==NOT||LA102_1==PLUS||LA102_1==REAL||LA102_1==STRING))
			{
				alt102 = 1;
			}
			else if ((LA102_1==END) && ((Index_IsActive())))
			{
				alt102 = 1;
			}
			else if ((LA102_1==AT||LA102_1==COLON||LA102_1==QUESTION))
			{
				alt102 = 1;
			}
			} finally { DebugExitDecision(102); }
			switch (alt102)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:555:87: arguments
				{
				DebugLocation(555, 87);
				PushFollow(Follow._arguments_in_parenthesisOperator5185);
				arguments373=arguments();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_arguments.Add(arguments373.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(102); }

			DebugLocation(555, 99);
			RPAREN374=(IToken)Match(input,RPAREN,Follow._RPAREN_in_parenthesisOperator5189); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN374);



			{
			// AST REWRITE
			// elements: arguments
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 555:106: -> ( arguments )?
			{
				DebugLocation(555, 109);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:555:109: ( arguments )?
				if (stream_arguments.HasNext)
				{
					DebugLocation(555, 110);
					adaptor.AddChild(root_0, stream_arguments.NextTree());

				}
				stream_arguments.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parenthesisOperator", 127);
			LeaveRule("parenthesisOperator", 127);
			LeaveRule_parenthesisOperator();
			Balance_ExitParenthesis(); Index_ExitParenthesis(); Chain_AddedParenthesis();
		}
		DebugLocation(555, 121);
		} finally { DebugExitRule(GrammarFileName, "parenthesisOperator"); }
		return retval;

	}
	// $ANTLR end "parenthesisOperator"

	partial void EnterRule_arguments();
	partial void LeaveRule_arguments();
	// $ANTLR start "arguments"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:558:1: arguments : argument ( COMMA argument )* -> ( argument )+ ;
	[GrammarRule("arguments")]
	private AstParserRuleReturnScope<object, IToken> arguments()
	{
		EnterRule_arguments();
		EnterRule("arguments", 128);
		TraceIn("arguments", 128);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA376 = default(IToken);
		AstParserRuleReturnScope<object, IToken> argument375 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> argument377 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA376_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_argument=new RewriteRuleSubtreeStream(adaptor,"rule argument");
		try { DebugEnterRule(GrammarFileName, "arguments");
		DebugLocation(558, 54);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:558:11: ( argument ( COMMA argument )* -> ( argument )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:558:13: argument ( COMMA argument )*
			{
			DebugLocation(558, 13);
			PushFollow(Follow._argument_in_arguments5209);
			argument375=argument();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_argument.Add(argument375.Tree);
			DebugLocation(558, 22);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:558:22: ( COMMA argument )*
			try { DebugEnterSubRule(103);
			while (true)
			{
				int alt103=2;
				try { DebugEnterDecision(103, false);
				int LA103_1 = input.LA(1);

				if ((LA103_1==COMMA))
				{
					alt103 = 1;
				}


				} finally { DebugExitDecision(103); }
				switch ( alt103 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:558:23: COMMA argument
					{
					DebugLocation(558, 23);
					COMMA376=(IToken)Match(input,COMMA,Follow._COMMA_in_arguments5212); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA376);

					DebugLocation(558, 29);
					PushFollow(Follow._argument_in_arguments5214);
					argument377=argument();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_argument.Add(argument377.Tree);

					}
					break;

				default:
					goto loop103;
				}
			}

			loop103:
				;

			} finally { DebugExitSubRule(103); }



			{
			// AST REWRITE
			// elements: argument
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 558:40: -> ( argument )+
			{
				DebugLocation(558, 43);
				if (!(stream_argument.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_argument.HasNext )
				{
					DebugLocation(558, 44);
					adaptor.AddChild(root_0, stream_argument.NextTree());

				}
				stream_argument.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arguments", 128);
			LeaveRule("arguments", 128);
			LeaveRule_arguments();
		}
		DebugLocation(558, 54);
		} finally { DebugExitRule(GrammarFileName, "arguments"); }
		return retval;

	}
	// $ANTLR end "arguments"

	partial void EnterRule_argument();
	partial void LeaveRule_argument();
	// $ANTLR start "argument"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:560:1: argument : ( expression -> expression | COLON -> ALL[$COLON] );
	[GrammarRule("argument")]
	private AstParserRuleReturnScope<object, IToken> argument()
	{
		EnterRule_argument();
		EnterRule("argument", 129);
		TraceIn("argument", 129);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COLON379 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression378 = default(AstParserRuleReturnScope<object, IToken>);

		object COLON379_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "argument");
		DebugLocation(560, 3);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:560:10: ( expression -> expression | COLON -> ALL[$COLON] )
			int alt104=2;
			try { DebugEnterDecision(104, false);
			int LA104_1 = input.LA(1);

			if ((LA104_1==ID||LA104_1==IMAGINARY||LA104_1==LCURLY||(LA104_1>=LPAREN && LA104_1<=LSQUARE)||LA104_1==MINUS||LA104_1==NOT||LA104_1==PLUS||LA104_1==REAL||LA104_1==STRING))
			{
				alt104 = 1;
			}
			else if ((LA104_1==END) && ((Index_IsActive())))
			{
				alt104 = 1;
			}
			else if ((LA104_1==AT||LA104_1==QUESTION))
			{
				alt104 = 1;
			}
			else if ((LA104_1==COLON))
			{
				alt104 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 104, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(104); }
			switch (alt104)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:560:12: expression
				{
				DebugLocation(560, 12);
				PushFollow(Follow._expression_in_argument5232);
				expression378=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression378.Tree);


				{
				// AST REWRITE
				// elements: expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 560:23: -> expression
				{
					DebugLocation(560, 26);
					adaptor.AddChild(root_0, stream_expression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:561:6: COLON
				{
				DebugLocation(561, 6);
				COLON379=(IToken)Match(input,COLON,Follow._COLON_in_argument5245); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON379);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 561:12: -> ALL[$COLON]
				{
					DebugLocation(561, 15);
					adaptor.AddChild(root_0, (object)adaptor.Create(ALL, COLON379));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("argument", 129);
			LeaveRule("argument", 129);
			LeaveRule_argument();
		}
		DebugLocation(562, 3);
		} finally { DebugExitRule(GrammarFileName, "argument"); }
		return retval;

	}
	// $ANTLR end "argument"

	partial void EnterRule_curlyBraceOperator();
	partial void LeaveRule_curlyBraceOperator();
	// $ANTLR start "curlyBraceOperator"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:564:1: curlyBraceOperator :{...}? =>{...}? => LCURLY arguments RCURLY -> arguments ;
	[GrammarRule("curlyBraceOperator")]
	private AstParserRuleReturnScope<object, IToken> curlyBraceOperator()
	{
		EnterRule_curlyBraceOperator();
		EnterRule("curlyBraceOperator", 130);
		TraceIn("curlyBraceOperator", 130);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LCURLY380 = default(IToken);
		IToken RCURLY382 = default(IToken);
		AstParserRuleReturnScope<object, IToken> arguments381 = default(AstParserRuleReturnScope<object, IToken>);

		object LCURLY380_tree = default(object);
		object RCURLY382_tree = default(object);
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		Index_EnterCurlyBrace(); Balance_EnterIndexCurlyBrace();
		try { DebugEnterRule(GrammarFileName, "curlyBraceOperator");
		DebugLocation(564, 114);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:565:66: ({...}? =>{...}? => LCURLY arguments RCURLY -> arguments )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:566:1: {...}? =>{...}? => LCURLY arguments RCURLY
			{
			DebugLocation(566, 1);
			if (!((Chain_MayAddCurlyBrace())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "curlyBraceOperator", "Chain_MayAddCurlyBrace()");
			}
			DebugLocation(566, 31);
			if (!((!Balance_InCreationOrStore_SpacesOnLeft())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "curlyBraceOperator", "!Balance_InCreationOrStore_SpacesOnLeft()");
			}
			DebugLocation(566, 78);
			LCURLY380=(IToken)Match(input,LCURLY,Follow._LCURLY_in_curlyBraceOperator5276); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY380);

			DebugLocation(566, 85);
			PushFollow(Follow._arguments_in_curlyBraceOperator5278);
			arguments381=arguments();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_arguments.Add(arguments381.Tree);
			DebugLocation(566, 95);
			RCURLY382=(IToken)Match(input,RCURLY,Follow._RCURLY_in_curlyBraceOperator5280); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY382);



			{
			// AST REWRITE
			// elements: arguments
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 566:102: -> arguments
			{
				DebugLocation(566, 105);
				adaptor.AddChild(root_0, stream_arguments.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("curlyBraceOperator", 130);
			LeaveRule("curlyBraceOperator", 130);
			LeaveRule_curlyBraceOperator();
			Balance_ExitIndexCurlyBrace(); Index_ExitCurlyBrace(); Chain_AddedCurlyBrace();
		}
		DebugLocation(566, 114);
		} finally { DebugExitRule(GrammarFileName, "curlyBraceOperator"); }
		return retval;

	}
	// $ANTLR end "curlyBraceOperator"

	partial void EnterRule_atBaseOperator();
	partial void LeaveRule_atBaseOperator();
	// $ANTLR start "atBaseOperator"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:569:1: atBaseOperator :{...}? =>{...}? => AT classReference -> classReference ;
	[GrammarRule("atBaseOperator")]
	private AstParserRuleReturnScope<object, IToken> atBaseOperator()
	{
		EnterRule_atBaseOperator();
		EnterRule("atBaseOperator", 131);
		TraceIn("atBaseOperator", 131);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AT383 = default(IToken);
		AstParserRuleReturnScope<object, IToken> classReference384 = default(AstParserRuleReturnScope<object, IToken>);

		object AT383_tree = default(object);
		RewriteRuleITokenStream stream_AT=new RewriteRuleITokenStream(adaptor,"token AT");
		RewriteRuleSubtreeStream stream_classReference=new RewriteRuleSubtreeStream(adaptor,"rule classReference");
		try { DebugEnterRule(GrammarFileName, "atBaseOperator");
		DebugLocation(569, 126);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:569:16: ({...}? =>{...}? => AT classReference -> classReference )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:569:18: {...}? =>{...}? => AT classReference
			{
			DebugLocation(569, 18);
			if (!((Chain_MayAddAtBase())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "atBaseOperator", "Chain_MayAddAtBase()");
			}
			DebugLocation(569, 44);
			if (!((!Balance_InCreationOrStore_SpacesOnLeft())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "atBaseOperator", "!Balance_InCreationOrStore_SpacesOnLeft()");
			}
			DebugLocation(569, 91);
			AT383=(IToken)Match(input,AT,Follow._AT_in_atBaseOperator5303); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_AT.Add(AT383);

			DebugLocation(569, 94);
			PushFollow(Follow._classReference_in_atBaseOperator5305);
			classReference384=classReference();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_classReference.Add(classReference384.Tree);


			{
			// AST REWRITE
			// elements: classReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 569:109: -> classReference
			{
				DebugLocation(569, 112);
				adaptor.AddChild(root_0, stream_classReference.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atBaseOperator", 131);
			LeaveRule("atBaseOperator", 131);
			LeaveRule_atBaseOperator();
			Chain_AddedAtBase();
		}
		DebugLocation(569, 126);
		} finally { DebugExitRule(GrammarFileName, "atBaseOperator"); }
		return retval;

	}
	// $ANTLR end "atBaseOperator"

	partial void EnterRule_real();
	partial void LeaveRule_real();
	// $ANTLR start "real"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:574:1: real : REAL -> REAL ;
	[GrammarRule("real")]
	private AstParserRuleReturnScope<object, IToken> real()
	{
		EnterRule_real();
		EnterRule("real", 132);
		TraceIn("real", 132);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken REAL385 = default(IToken);

		object REAL385_tree = default(object);
		RewriteRuleITokenStream stream_REAL=new RewriteRuleITokenStream(adaptor,"token REAL");
		try { DebugEnterRule(GrammarFileName, "real");
		DebugLocation(574, 20);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:574:6: ( REAL -> REAL )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:574:8: REAL
			{
			DebugLocation(574, 8);
			REAL385=(IToken)Match(input,REAL,Follow._REAL_in_real5324); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_REAL.Add(REAL385);



			{
			// AST REWRITE
			// elements: REAL
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 574:13: -> REAL
			{
				DebugLocation(574, 16);
				adaptor.AddChild(root_0, stream_REAL.NextNode());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("real", 132);
			LeaveRule("real", 132);
			LeaveRule_real();
		}
		DebugLocation(574, 20);
		} finally { DebugExitRule(GrammarFileName, "real"); }
		return retval;

	}
	// $ANTLR end "real"

	partial void EnterRule_imaginary();
	partial void LeaveRule_imaginary();
	// $ANTLR start "imaginary"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:578:1: imaginary : IMAGINARY -> IMAGINARY ;
	[GrammarRule("imaginary")]
	private AstParserRuleReturnScope<object, IToken> imaginary()
	{
		EnterRule_imaginary();
		EnterRule("imaginary", 133);
		TraceIn("imaginary", 133);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IMAGINARY386 = default(IToken);

		object IMAGINARY386_tree = default(object);
		RewriteRuleITokenStream stream_IMAGINARY=new RewriteRuleITokenStream(adaptor,"token IMAGINARY");
		try { DebugEnterRule(GrammarFileName, "imaginary");
		DebugLocation(578, 35);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:578:11: ( IMAGINARY -> IMAGINARY )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:578:13: IMAGINARY
			{
			DebugLocation(578, 13);
			IMAGINARY386=(IToken)Match(input,IMAGINARY,Follow._IMAGINARY_in_imaginary5339); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IMAGINARY.Add(IMAGINARY386);



			{
			// AST REWRITE
			// elements: IMAGINARY
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 578:23: -> IMAGINARY
			{
				DebugLocation(578, 26);
				adaptor.AddChild(root_0, stream_IMAGINARY.NextNode());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("imaginary", 133);
			LeaveRule("imaginary", 133);
			LeaveRule_imaginary();
		}
		DebugLocation(578, 35);
		} finally { DebugExitRule(GrammarFileName, "imaginary"); }
		return retval;

	}
	// $ANTLR end "imaginary"

	partial void EnterRule_string();
	partial void LeaveRule_string();
	// $ANTLR start "string"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:582:1: string : STRING -> STRING ;
	[GrammarRule("string")]
	private AstParserRuleReturnScope<object, IToken> @string()
	{
		EnterRule_string();
		EnterRule("string", 134);
		TraceIn("string", 134);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken STRING387 = default(IToken);

		object STRING387_tree = default(object);
		RewriteRuleITokenStream stream_STRING=new RewriteRuleITokenStream(adaptor,"token STRING");
		try { DebugEnterRule(GrammarFileName, "string");
		DebugLocation(582, 26);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:582:8: ( STRING -> STRING )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:582:10: STRING
			{
			DebugLocation(582, 10);
			STRING387=(IToken)Match(input,STRING,Follow._STRING_in_string5354); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_STRING.Add(STRING387);



			{
			// AST REWRITE
			// elements: STRING
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 582:17: -> STRING
			{
				DebugLocation(582, 20);
				adaptor.AddChild(root_0, stream_STRING.NextNode());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("string", 134);
			LeaveRule("string", 134);
			LeaveRule_string();
		}
		DebugLocation(582, 26);
		} finally { DebugExitRule(GrammarFileName, "string"); }
		return retval;

	}
	// $ANTLR end "string"

	partial void EnterRule_regularArray();
	partial void LeaveRule_regularArray();
	// $ANTLR start "regularArray"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:588:1: regularArray : LSQUARE rows RSQUARE -> ^( REGULARARRAY[$LSQUARE] ^( VCAT[\"\"] rows ) ) ;
	[GrammarRule("regularArray")]
	private AstParserRuleReturnScope<object, IToken> regularArray()
	{
		EnterRule_regularArray();
		EnterRule("regularArray", 135);
		TraceIn("regularArray", 135);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LSQUARE388 = default(IToken);
		IToken RSQUARE390 = default(IToken);
		AstParserRuleReturnScope<object, IToken> rows389 = default(AstParserRuleReturnScope<object, IToken>);

		object LSQUARE388_tree = default(object);
		object RSQUARE390_tree = default(object);
		RewriteRuleITokenStream stream_LSQUARE=new RewriteRuleITokenStream(adaptor,"token LSQUARE");
		RewriteRuleITokenStream stream_RSQUARE=new RewriteRuleITokenStream(adaptor,"token RSQUARE");
		RewriteRuleSubtreeStream stream_rows=new RewriteRuleSubtreeStream(adaptor,"rule rows");
		Balance_EnterCreationSquareBrace();
		try { DebugEnterRule(GrammarFileName, "regularArray");
		DebugLocation(588, 67);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:589:45: ( LSQUARE rows RSQUARE -> ^( REGULARARRAY[$LSQUARE] ^( VCAT[\"\"] rows ) ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:590:1: LSQUARE rows RSQUARE
			{
			DebugLocation(590, 1);
			LSQUARE388=(IToken)Match(input,LSQUARE,Follow._LSQUARE_in_regularArray5378); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LSQUARE.Add(LSQUARE388);

			DebugLocation(590, 9);
			PushFollow(Follow._rows_in_regularArray5380);
			rows389=rows();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_rows.Add(rows389.Tree);
			DebugLocation(590, 14);
			RSQUARE390=(IToken)Match(input,RSQUARE,Follow._RSQUARE_in_regularArray5382); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RSQUARE.Add(RSQUARE390);



			{
			// AST REWRITE
			// elements: rows
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 590:22: -> ^( REGULARARRAY[$LSQUARE] ^( VCAT[\"\"] rows ) )
			{
				DebugLocation(590, 25);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:590:25: ^( REGULARARRAY[$LSQUARE] ^( VCAT[\"\"] rows ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(590, 27);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(REGULARARRAY, LSQUARE388), root_1);

				DebugLocation(590, 50);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:590:50: ^( VCAT[\"\"] rows )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(590, 52);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(VCAT, ""), root_2);

				DebugLocation(590, 61);
				adaptor.AddChild(root_2, stream_rows.NextTree());

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("regularArray", 135);
			LeaveRule("regularArray", 135);
			LeaveRule_regularArray();
			Balance_ExitCreationSquareBrace();
		}
		DebugLocation(590, 67);
		} finally { DebugExitRule(GrammarFileName, "regularArray"); }
		return retval;

	}
	// $ANTLR end "regularArray"

	partial void EnterRule_rows();
	partial void LeaveRule_rows();
	// $ANTLR start "rows"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:593:1: rows : row ( ( SEMICOLON | EOL ) row )* -> ( row )+ ;
	[GrammarRule("rows")]
	private AstParserRuleReturnScope<object, IToken> rows()
	{
		EnterRule_rows();
		EnterRule("rows", 136);
		TraceIn("rows", 136);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMICOLON392 = default(IToken);
		IToken EOL393 = default(IToken);
		AstParserRuleReturnScope<object, IToken> row391 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> row394 = default(AstParserRuleReturnScope<object, IToken>);

		object SEMICOLON392_tree = default(object);
		object EOL393_tree = default(object);
		RewriteRuleITokenStream stream_SEMICOLON=new RewriteRuleITokenStream(adaptor,"token SEMICOLON");
		RewriteRuleITokenStream stream_EOL=new RewriteRuleITokenStream(adaptor,"token EOL");
		RewriteRuleSubtreeStream stream_row=new RewriteRuleSubtreeStream(adaptor,"rule row");
		try { DebugEnterRule(GrammarFileName, "rows");
		DebugLocation(593, 46);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:593:6: ( row ( ( SEMICOLON | EOL ) row )* -> ( row )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:593:8: row ( ( SEMICOLON | EOL ) row )*
			{
			DebugLocation(593, 8);
			PushFollow(Follow._row_in_rows5409);
			row391=row();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_row.Add(row391.Tree);
			DebugLocation(593, 12);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:593:12: ( ( SEMICOLON | EOL ) row )*
			try { DebugEnterSubRule(106);
			while (true)
			{
				int alt106=2;
				try { DebugEnterDecision(106, false);
				int LA106_1 = input.LA(1);

				if ((LA106_1==EOL||LA106_1==SEMICOLON))
				{
					alt106 = 1;
				}


				} finally { DebugExitDecision(106); }
				switch ( alt106 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:593:13: ( SEMICOLON | EOL ) row
					{
					DebugLocation(593, 13);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:593:13: ( SEMICOLON | EOL )
					int alt105=2;
					try { DebugEnterSubRule(105);
					try { DebugEnterDecision(105, false);
					int LA105_1 = input.LA(1);

					if ((LA105_1==SEMICOLON))
					{
						alt105 = 1;
					}
					else if ((LA105_1==EOL))
					{
						alt105 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 105, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(105); }
					switch (alt105)
					{
					case 1:
						DebugEnterAlt(1);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:593:14: SEMICOLON
						{
						DebugLocation(593, 14);
						SEMICOLON392=(IToken)Match(input,SEMICOLON,Follow._SEMICOLON_in_rows5413); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_SEMICOLON.Add(SEMICOLON392);


						}
						break;
					case 2:
						DebugEnterAlt(2);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:593:26: EOL
						{
						DebugLocation(593, 26);
						EOL393=(IToken)Match(input,EOL,Follow._EOL_in_rows5417); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_EOL.Add(EOL393);


						}
						break;

					}
					} finally { DebugExitSubRule(105); }

					DebugLocation(593, 31);
					PushFollow(Follow._row_in_rows5420);
					row394=row();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_row.Add(row394.Tree);

					}
					break;

				default:
					goto loop106;
				}
			}

			loop106:
				;

			} finally { DebugExitSubRule(106); }



			{
			// AST REWRITE
			// elements: row
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 593:37: -> ( row )+
			{
				DebugLocation(593, 40);
				if (!(stream_row.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_row.HasNext )
				{
					DebugLocation(593, 41);
					adaptor.AddChild(root_0, stream_row.NextTree());

				}
				stream_row.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("rows", 136);
			LeaveRule("rows", 136);
			LeaveRule_rows();
		}
		DebugLocation(593, 46);
		} finally { DebugExitRule(GrammarFileName, "rows"); }
		return retval;

	}
	// $ANTLR end "rows"

	partial void EnterRule_row();
	partial void LeaveRule_row();
	// $ANTLR start "row"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:595:1: row : ( ( COMMA )? columns ( COMMA )? -> ^( HCAT[\"\"] columns ) | COMMA -> HCAT[\"\"] | () -> HCAT[\"\"] );
	[GrammarRule("row")]
	private AstParserRuleReturnScope<object, IToken> row()
	{
		EnterRule_row();
		EnterRule("row", 137);
		TraceIn("row", 137);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA395 = default(IToken);
		IToken COMMA397 = default(IToken);
		IToken COMMA398 = default(IToken);
		AstParserRuleReturnScope<object, IToken> columns396 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA395_tree = default(object);
		object COMMA397_tree = default(object);
		object COMMA398_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_columns=new RewriteRuleSubtreeStream(adaptor,"rule columns");
		try { DebugEnterRule(GrammarFileName, "row");
		DebugLocation(595, 1);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:595:5: ( ( COMMA )? columns ( COMMA )? -> ^( HCAT[\"\"] columns ) | COMMA -> HCAT[\"\"] | () -> HCAT[\"\"] )
			int alt109=3;
			try { DebugEnterDecision(109, false);
			int LA109_1 = input.LA(1);

			if ((LA109_1==COMMA))
			{
				switch (input.LA(2))
				{
				case NOT:
					{
					alt109 = 1;
					}
					break;
				case AT:
				case END:
				case ID:
				case IMAGINARY:
				case LCURLY:
				case LPAREN:
				case LSQUARE:
				case MINUS:
				case PLUS:
				case QUESTION:
				case REAL:
				case STRING:
					{
					alt109 = 1;
					}
					break;
				case EOL:
				case RCURLY:
				case RSQUARE:
				case SEMICOLON:
					{
					alt109 = 2;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 109, 1, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else if ((LA109_1==ID||LA109_1==IMAGINARY||LA109_1==LCURLY||(LA109_1>=LPAREN && LA109_1<=LSQUARE)||LA109_1==MINUS||LA109_1==NOT||LA109_1==PLUS||LA109_1==REAL||LA109_1==STRING))
			{
				alt109 = 1;
			}
			else if ((LA109_1==END) && ((Index_IsActive())))
			{
				alt109 = 1;
			}
			else if ((LA109_1==AT||LA109_1==QUESTION))
			{
				alt109 = 1;
			}
			else if ((LA109_1==EOL||LA109_1==RCURLY||(LA109_1>=RSQUARE && LA109_1<=SEMICOLON)))
			{
				alt109 = 3;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 109, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(109); }
			switch (alt109)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:595:7: ( COMMA )? columns ( COMMA )?
				{
				DebugLocation(595, 7);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:595:7: ( COMMA )?
				int alt107=2;
				try { DebugEnterSubRule(107);
				try { DebugEnterDecision(107, false);
				int LA107_1 = input.LA(1);

				if ((LA107_1==COMMA))
				{
					alt107 = 1;
				}
				} finally { DebugExitDecision(107); }
				switch (alt107)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:595:8: COMMA
					{
					DebugLocation(595, 8);
					COMMA395=(IToken)Match(input,COMMA,Follow._COMMA_in_row5439); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA395);


					}
					break;

				}
				} finally { DebugExitSubRule(107); }

				DebugLocation(595, 16);
				PushFollow(Follow._columns_in_row5443);
				columns396=columns();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_columns.Add(columns396.Tree);
				DebugLocation(595, 24);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:595:24: ( COMMA )?
				int alt108=2;
				try { DebugEnterSubRule(108);
				try { DebugEnterDecision(108, false);
				int LA108_1 = input.LA(1);

				if ((LA108_1==COMMA))
				{
					alt108 = 1;
				}
				} finally { DebugExitDecision(108); }
				switch (alt108)
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:595:25: COMMA
					{
					DebugLocation(595, 25);
					COMMA397=(IToken)Match(input,COMMA,Follow._COMMA_in_row5446); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA397);


					}
					break;

				}
				} finally { DebugExitSubRule(108); }



				{
				// AST REWRITE
				// elements: columns
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 595:33: -> ^( HCAT[\"\"] columns )
				{
					DebugLocation(595, 36);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:595:36: ^( HCAT[\"\"] columns )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(595, 38);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(HCAT, ""), root_1);

					DebugLocation(595, 47);
					adaptor.AddChild(root_1, stream_columns.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:596:4: COMMA
				{
				DebugLocation(596, 4);
				COMMA398=(IToken)Match(input,COMMA,Follow._COMMA_in_row5463); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COMMA.Add(COMMA398);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 596:10: -> HCAT[\"\"]
				{
					DebugLocation(596, 13);
					adaptor.AddChild(root_0, (object)adaptor.Create(HCAT, ""));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:597:4: ()
				{
				DebugLocation(597, 4);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:597:4: ()
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:597:5: 
				{
				}



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 597:7: -> HCAT[\"\"]
				{
					DebugLocation(597, 10);
					adaptor.AddChild(root_0, (object)adaptor.Create(HCAT, ""));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("row", 137);
			LeaveRule("row", 137);
			LeaveRule_row();
		}
		DebugLocation(598, 1);
		} finally { DebugExitRule(GrammarFileName, "row"); }
		return retval;

	}
	// $ANTLR end "row"

	partial void EnterRule_columns();
	partial void LeaveRule_columns();
	// $ANTLR start "columns"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:600:1: columns : column ({...}? => ( COMMA )? column )* -> ( column )+ ;
	[GrammarRule("columns")]
	private AstParserRuleReturnScope<object, IToken> columns()
	{
		EnterRule_columns();
		EnterRule("columns", 138);
		TraceIn("columns", 138);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA400 = default(IToken);
		AstParserRuleReturnScope<object, IToken> column399 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> column401 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA400_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_column=new RewriteRuleSubtreeStream(adaptor,"rule column");
		try { DebugEnterRule(GrammarFileName, "columns");
		DebugLocation(600, 94);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:600:9: ( column ({...}? => ( COMMA )? column )* -> ( column )+ )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:600:11: column ({...}? => ( COMMA )? column )*
			{
			DebugLocation(600, 11);
			PushFollow(Follow._column_in_columns5490);
			column399=column();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_column.Add(column399.Tree);
			DebugLocation(600, 18);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:600:18: ({...}? => ( COMMA )? column )*
			try { DebugEnterSubRule(111);
			while (true)
			{
				int alt111=2;
				try { DebugEnterDecision(111, false);
				int LA111_1 = input.LA(1);

				if ((LA111_1==COMMA))
				{
					int LA111_2 = input.LA(2);

					if ((LA111_2==NOT) && ((Separator_CommaFollowsOrSpacesPrecede())))
					{
						alt111 = 1;
					}
					else if ((LA111_2==AT||LA111_2==END||LA111_2==ID||LA111_2==IMAGINARY||LA111_2==LCURLY||(LA111_2>=LPAREN && LA111_2<=LSQUARE)||LA111_2==MINUS||LA111_2==PLUS||LA111_2==QUESTION||LA111_2==REAL||LA111_2==STRING) && ((Separator_CommaFollowsOrSpacesPrecede())))
					{
						alt111 = 1;
					}


				}
				else if ((LA111_1==ID||LA111_1==IMAGINARY||LA111_1==LCURLY||(LA111_1>=LPAREN && LA111_1<=LSQUARE)||LA111_1==MINUS||LA111_1==NOT||LA111_1==PLUS||LA111_1==REAL||LA111_1==STRING) && ((Separator_CommaFollowsOrSpacesPrecede())))
				{
					alt111 = 1;
				}
				else if ((LA111_1==END) && (((Separator_CommaFollowsOrSpacesPrecede())&&(Index_IsActive()))))
				{
					alt111 = 1;
				}
				else if ((LA111_1==AT||LA111_1==QUESTION) && ((Separator_CommaFollowsOrSpacesPrecede())))
				{
					alt111 = 1;
				}


				} finally { DebugExitDecision(111); }
				switch ( alt111 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:600:19: {...}? => ( COMMA )? column
					{
					DebugLocation(600, 19);
					if (!((Separator_CommaFollowsOrSpacesPrecede())))
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						throw new FailedPredicateException(input, "columns", "Separator_CommaFollowsOrSpacesPrecede()");
					}
					DebugLocation(600, 64);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:600:64: ( COMMA )?
					int alt110=2;
					try { DebugEnterSubRule(110);
					try { DebugEnterDecision(110, false);
					int LA110_1 = input.LA(1);

					if ((LA110_1==COMMA))
					{
						alt110 = 1;
					}
					} finally { DebugExitDecision(110); }
					switch (alt110)
					{
					case 1:
						DebugEnterAlt(1);
						// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:600:65: COMMA
						{
						DebugLocation(600, 65);
						COMMA400=(IToken)Match(input,COMMA,Follow._COMMA_in_columns5497); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA400);


						}
						break;

					}
					} finally { DebugExitSubRule(110); }

					DebugLocation(600, 73);
					PushFollow(Follow._column_in_columns5501);
					column401=column();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_column.Add(column401.Tree);

					}
					break;

				default:
					goto loop111;
				}
			}

			loop111:
				;

			} finally { DebugExitSubRule(111); }



			{
			// AST REWRITE
			// elements: column
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 600:82: -> ( column )+
			{
				DebugLocation(600, 85);
				if (!(stream_column.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_column.HasNext )
				{
					DebugLocation(600, 86);
					adaptor.AddChild(root_0, stream_column.NextTree());

				}
				stream_column.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("columns", 138);
			LeaveRule("columns", 138);
			LeaveRule_columns();
		}
		DebugLocation(600, 94);
		} finally { DebugExitRule(GrammarFileName, "columns"); }
		return retval;

	}
	// $ANTLR end "columns"

	partial void EnterRule_column();
	partial void LeaveRule_column();
	// $ANTLR start "column"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:602:1: column : ( ( NOT ( COMMA | SEMICOLON | EOL | RSQUARE ) )=> NOT -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) ) | expression -> expression );
	[GrammarRule("column")]
	private AstParserRuleReturnScope<object, IToken> column()
	{
		EnterRule_column();
		EnterRule("column", 139);
		TraceIn("column", 139);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NOT402 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression403 = default(AstParserRuleReturnScope<object, IToken>);

		object NOT402_tree = default(object);
		RewriteRuleITokenStream stream_NOT=new RewriteRuleITokenStream(adaptor,"token NOT");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "column");
		DebugLocation(602, 4);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:602:8: ( ( NOT ( COMMA | SEMICOLON | EOL | RSQUARE ) )=> NOT -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) ) | expression -> expression )
			int alt112=2;
			try { DebugEnterDecision(112, false);
			int LA112_1 = input.LA(1);

			if ((LA112_1==NOT))
			{
				int LA112_2 = input.LA(2);

				if ((EvaluatePredicate(synpred8_MatlabParser_fragment)))
				{
					alt112 = 1;
				}
				else if ((true))
				{
					alt112 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 112, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA112_1==ID||LA112_1==IMAGINARY||LA112_1==LCURLY||(LA112_1>=LPAREN && LA112_1<=LSQUARE)||LA112_1==MINUS||LA112_1==PLUS||LA112_1==REAL||LA112_1==STRING))
			{
				alt112 = 2;
			}
			else if ((LA112_1==END) && ((Index_IsActive())))
			{
				alt112 = 2;
			}
			else if ((LA112_1==AT||LA112_1==QUESTION))
			{
				alt112 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 112, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(112); }
			switch (alt112)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:602:10: ( NOT ( COMMA | SEMICOLON | EOL | RSQUARE ) )=> NOT
				{
				DebugLocation(602, 54);
				NOT402=(IToken)Match(input,NOT,Follow._NOT_in_column5540); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NOT.Add(NOT402);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 602:58: -> ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) )
				{
					DebugLocation(602, 61);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:602:61: ^( VAR[\"\"] ^( NAME[\"\"] ID[$NOT] ) )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(602, 63);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR, ""), root_1);

					DebugLocation(602, 71);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:602:71: ^( NAME[\"\"] ID[$NOT] )
					{
					object root_2 = (object)adaptor.Nil();
					DebugLocation(602, 73);
					root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAME, ""), root_2);

					DebugLocation(602, 82);
					adaptor.AddChild(root_2, (object)adaptor.Create(ID, NOT402));

					adaptor.AddChild(root_1, root_2);
					}

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:603:7: expression
				{
				DebugLocation(603, 7);
				PushFollow(Follow._expression_in_column5563);
				expression403=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression403.Tree);


				{
				// AST REWRITE
				// elements: expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 603:18: -> expression
				{
					DebugLocation(603, 21);
					adaptor.AddChild(root_0, stream_expression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("column", 139);
			LeaveRule("column", 139);
			LeaveRule_column();
		}
		DebugLocation(604, 4);
		} finally { DebugExitRule(GrammarFileName, "column"); }
		return retval;

	}
	// $ANTLR end "column"

	partial void EnterRule_cellArray();
	partial void LeaveRule_cellArray();
	// $ANTLR start "cellArray"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:608:1: cellArray : LCURLY rows RCURLY -> ^( CELLARRAY[$LCURLY] ^( VCAT[\"\"] rows ) ) ;
	[GrammarRule("cellArray")]
	private AstParserRuleReturnScope<object, IToken> cellArray()
	{
		EnterRule_cellArray();
		EnterRule("cellArray", 140);
		TraceIn("cellArray", 140);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LCURLY404 = default(IToken);
		IToken RCURLY406 = default(IToken);
		AstParserRuleReturnScope<object, IToken> rows405 = default(AstParserRuleReturnScope<object, IToken>);

		object LCURLY404_tree = default(object);
		object RCURLY406_tree = default(object);
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_rows=new RewriteRuleSubtreeStream(adaptor,"rule rows");
		Balance_EnterCreationCurlyBrace();
		try { DebugEnterRule(GrammarFileName, "cellArray");
		DebugLocation(608, 61);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:609:44: ( LCURLY rows RCURLY -> ^( CELLARRAY[$LCURLY] ^( VCAT[\"\"] rows ) ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:610:1: LCURLY rows RCURLY
			{
			DebugLocation(610, 1);
			LCURLY404=(IToken)Match(input,LCURLY,Follow._LCURLY_in_cellArray5590); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY404);

			DebugLocation(610, 8);
			PushFollow(Follow._rows_in_cellArray5592);
			rows405=rows();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_rows.Add(rows405.Tree);
			DebugLocation(610, 13);
			RCURLY406=(IToken)Match(input,RCURLY,Follow._RCURLY_in_cellArray5594); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY406);



			{
			// AST REWRITE
			// elements: rows
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 610:20: -> ^( CELLARRAY[$LCURLY] ^( VCAT[\"\"] rows ) )
			{
				DebugLocation(610, 23);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:610:23: ^( CELLARRAY[$LCURLY] ^( VCAT[\"\"] rows ) )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(610, 25);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(CELLARRAY, LCURLY404), root_1);

				DebugLocation(610, 44);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:610:44: ^( VCAT[\"\"] rows )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(610, 46);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(VCAT, ""), root_2);

				DebugLocation(610, 55);
				adaptor.AddChild(root_2, stream_rows.NextTree());

				adaptor.AddChild(root_1, root_2);
				}

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("cellArray", 140);
			LeaveRule("cellArray", 140);
			LeaveRule_cellArray();
			Balance_ExitCreationCurlyBrace();
		}
		DebugLocation(610, 61);
		} finally { DebugExitRule(GrammarFileName, "cellArray"); }
		return retval;

	}
	// $ANTLR end "cellArray"

	partial void EnterRule_parenthesized();
	partial void LeaveRule_parenthesized();
	// $ANTLR start "parenthesized"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:615:1: parenthesized : LPAREN expression RPAREN -> expression ;
	[GrammarRule("parenthesized")]
	private AstParserRuleReturnScope<object, IToken> parenthesized()
	{
		EnterRule_parenthesized();
		EnterRule("parenthesized", 141);
		TraceIn("parenthesized", 141);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN407 = default(IToken);
		IToken RPAREN409 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression408 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN407_tree = default(object);
		object RPAREN409_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		Balance_EnterParenthesis();
		try { DebugEnterRule(GrammarFileName, "parenthesized");
		DebugLocation(615, 39);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:616:37: ( LPAREN expression RPAREN -> expression )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:617:1: LPAREN expression RPAREN
			{
			DebugLocation(617, 1);
			LPAREN407=(IToken)Match(input,LPAREN,Follow._LPAREN_in_parenthesized5630); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN407);

			DebugLocation(617, 8);
			PushFollow(Follow._expression_in_parenthesized5632);
			expression408=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression408.Tree);
			DebugLocation(617, 19);
			RPAREN409=(IToken)Match(input,RPAREN,Follow._RPAREN_in_parenthesized5634); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN409);



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 617:26: -> expression
			{
				DebugLocation(617, 29);
				adaptor.AddChild(root_0, stream_expression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parenthesized", 141);
			LeaveRule("parenthesized", 141);
			LeaveRule_parenthesized();
			Balance_ExitParenthesis();
		}
		DebugLocation(617, 39);
		} finally { DebugExitRule(GrammarFileName, "parenthesized"); }
		return retval;

	}
	// $ANTLR end "parenthesized"

	partial void EnterRule_end();
	partial void LeaveRule_end();
	// $ANTLR start "end"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:622:1: end :{...}? => END -> END ;
	[GrammarRule("end")]
	private AstParserRuleReturnScope<object, IToken> end()
	{
		EnterRule_end();
		EnterRule("end", 142);
		TraceIn("end", 142);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken END410 = default(IToken);

		object END410_tree = default(object);
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		try { DebugEnterRule(GrammarFileName, "end");
		DebugLocation(622, 39);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:622:5: ({...}? => END -> END )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:622:7: {...}? => END
			{
			DebugLocation(622, 7);
			if (!((Index_IsActive())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "end", "Index_IsActive()");
			}
			DebugLocation(622, 29);
			END410=(IToken)Match(input,END,Follow._END_in_end5656); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_END.Add(END410);



			{
			// AST REWRITE
			// elements: END
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 622:33: -> END
			{
				DebugLocation(622, 36);
				adaptor.AddChild(root_0, stream_END.NextNode());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("end", 142);
			LeaveRule("end", 142);
			LeaveRule_end();
		}
		DebugLocation(622, 39);
		} finally { DebugExitRule(GrammarFileName, "end"); }
		return retval;

	}
	// $ANTLR end "end"

	partial void EnterRule_functionHandle();
	partial void LeaveRule_functionHandle();
	// $ANTLR start "functionHandle"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:626:1: functionHandle : AT functionReference -> ^( FUNCTIONHANDLE[$AT] functionReference ) ;
	[GrammarRule("functionHandle")]
	private AstParserRuleReturnScope<object, IToken> functionHandle()
	{
		EnterRule_functionHandle();
		EnterRule("functionHandle", 143);
		TraceIn("functionHandle", 143);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AT411 = default(IToken);
		AstParserRuleReturnScope<object, IToken> functionReference412 = default(AstParserRuleReturnScope<object, IToken>);

		object AT411_tree = default(object);
		RewriteRuleITokenStream stream_AT=new RewriteRuleITokenStream(adaptor,"token AT");
		RewriteRuleSubtreeStream stream_functionReference=new RewriteRuleSubtreeStream(adaptor,"rule functionReference");
		try { DebugEnterRule(GrammarFileName, "functionHandle");
		DebugLocation(626, 82);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:626:16: ( AT functionReference -> ^( FUNCTIONHANDLE[$AT] functionReference ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:626:18: AT functionReference
			{
			DebugLocation(626, 18);
			AT411=(IToken)Match(input,AT,Follow._AT_in_functionHandle5671); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_AT.Add(AT411);

			DebugLocation(626, 21);
			PushFollow(Follow._functionReference_in_functionHandle5673);
			functionReference412=functionReference();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_functionReference.Add(functionReference412.Tree);


			{
			// AST REWRITE
			// elements: functionReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 626:39: -> ^( FUNCTIONHANDLE[$AT] functionReference )
			{
				DebugLocation(626, 42);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:626:42: ^( FUNCTIONHANDLE[$AT] functionReference )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(626, 44);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTIONHANDLE, AT411), root_1);

				DebugLocation(626, 64);
				adaptor.AddChild(root_1, stream_functionReference.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionHandle", 143);
			LeaveRule("functionHandle", 143);
			LeaveRule_functionHandle();
		}
		DebugLocation(626, 82);
		} finally { DebugExitRule(GrammarFileName, "functionHandle"); }
		return retval;

	}
	// $ANTLR end "functionHandle"

	partial void EnterRule_functionReference();
	partial void LeaveRule_functionReference();
	// $ANTLR start "functionReference"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:628:1: functionReference : fullFunctioName -> ^( FUNCTIONREF[\"\"] fullFunctioName ) ;
	[GrammarRule("functionReference")]
	private AstParserRuleReturnScope<object, IToken> functionReference()
	{
		EnterRule_functionReference();
		EnterRule("functionReference", 144);
		TraceIn("functionReference", 144);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> fullFunctioName413 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_fullFunctioName=new RewriteRuleSubtreeStream(adaptor,"rule fullFunctioName");
		try { DebugEnterRule(GrammarFileName, "functionReference");
		DebugLocation(628, 74);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:628:19: ( fullFunctioName -> ^( FUNCTIONREF[\"\"] fullFunctioName ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:628:21: fullFunctioName
			{
			DebugLocation(628, 21);
			PushFollow(Follow._fullFunctioName_in_functionReference5691);
			fullFunctioName413=fullFunctioName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_fullFunctioName.Add(fullFunctioName413.Tree);


			{
			// AST REWRITE
			// elements: fullFunctioName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 628:37: -> ^( FUNCTIONREF[\"\"] fullFunctioName )
			{
				DebugLocation(628, 40);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:628:40: ^( FUNCTIONREF[\"\"] fullFunctioName )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(628, 42);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUNCTIONREF, ""), root_1);

				DebugLocation(628, 58);
				adaptor.AddChild(root_1, stream_fullFunctioName.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionReference", 144);
			LeaveRule("functionReference", 144);
			LeaveRule_functionReference();
		}
		DebugLocation(628, 74);
		} finally { DebugExitRule(GrammarFileName, "functionReference"); }
		return retval;

	}
	// $ANTLR end "functionReference"

	partial void EnterRule_fullFunctioName();
	partial void LeaveRule_fullFunctioName();
	// $ANTLR start "fullFunctioName"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:630:1: fullFunctioName : xID ( DOT xANYID )* -> ^( NAME[\"\"] xID ( xANYID )* ) ;
	[GrammarRule("fullFunctioName")]
	private AstParserRuleReturnScope<object, IToken> fullFunctioName()
	{
		EnterRule_fullFunctioName();
		EnterRule("fullFunctioName", 145);
		TraceIn("fullFunctioName", 145);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DOT415 = default(IToken);
		AstParserRuleReturnScope<object, IToken> xID414 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> xANYID416 = default(AstParserRuleReturnScope<object, IToken>);

		object DOT415_tree = default(object);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_xID=new RewriteRuleSubtreeStream(adaptor,"rule xID");
		RewriteRuleSubtreeStream stream_xANYID=new RewriteRuleSubtreeStream(adaptor,"rule xANYID");
		try { DebugEnterRule(GrammarFileName, "fullFunctioName");
		DebugLocation(630, 65);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:630:17: ( xID ( DOT xANYID )* -> ^( NAME[\"\"] xID ( xANYID )* ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:630:19: xID ( DOT xANYID )*
			{
			DebugLocation(630, 19);
			PushFollow(Follow._xID_in_fullFunctioName5709);
			xID414=xID();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_xID.Add(xID414.Tree);
			DebugLocation(630, 23);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:630:23: ( DOT xANYID )*
			try { DebugEnterSubRule(113);
			while (true)
			{
				int alt113=2;
				try { DebugEnterDecision(113, false);
				int LA113_1 = input.LA(1);

				if ((LA113_1==DOT))
				{
					alt113 = 1;
				}


				} finally { DebugExitDecision(113); }
				switch ( alt113 )
				{
				case 1:
					DebugEnterAlt(1);
					// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:630:24: DOT xANYID
					{
					DebugLocation(630, 24);
					DOT415=(IToken)Match(input,DOT,Follow._DOT_in_fullFunctioName5712); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_DOT.Add(DOT415);

					DebugLocation(630, 28);
					PushFollow(Follow._xANYID_in_fullFunctioName5714);
					xANYID416=xANYID();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_xANYID.Add(xANYID416.Tree);

					}
					break;

				default:
					goto loop113;
				}
			}

			loop113:
				;

			} finally { DebugExitSubRule(113); }



			{
			// AST REWRITE
			// elements: xID, xANYID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 630:37: -> ^( NAME[\"\"] xID ( xANYID )* )
			{
				DebugLocation(630, 40);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:630:40: ^( NAME[\"\"] xID ( xANYID )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(630, 42);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NAME, ""), root_1);

				DebugLocation(630, 51);
				adaptor.AddChild(root_1, stream_xID.NextTree());
				DebugLocation(630, 55);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:630:55: ( xANYID )*
				while ( stream_xANYID.HasNext )
				{
					DebugLocation(630, 56);
					adaptor.AddChild(root_1, stream_xANYID.NextTree());

				}
				stream_xANYID.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fullFunctioName", 145);
			LeaveRule("fullFunctioName", 145);
			LeaveRule_fullFunctioName();
		}
		DebugLocation(630, 65);
		} finally { DebugExitRule(GrammarFileName, "fullFunctioName"); }
		return retval;

	}
	// $ANTLR end "fullFunctioName"

	partial void EnterRule_anonymousFunction();
	partial void LeaveRule_anonymousFunction();
	// $ANTLR start "anonymousFunction"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:634:1: anonymousFunction : AT inputPortion expression -> ^( ANONYMOUSFUNCTION[$AT] ( inputPortion )? expression ) ;
	[GrammarRule("anonymousFunction")]
	private AstParserRuleReturnScope<object, IToken> anonymousFunction()
	{
		EnterRule_anonymousFunction();
		EnterRule("anonymousFunction", 146);
		TraceIn("anonymousFunction", 146);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AT417 = default(IToken);
		AstParserRuleReturnScope<object, IToken> inputPortion418 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression419 = default(AstParserRuleReturnScope<object, IToken>);

		object AT417_tree = default(object);
		RewriteRuleITokenStream stream_AT=new RewriteRuleITokenStream(adaptor,"token AT");
		RewriteRuleSubtreeStream stream_inputPortion=new RewriteRuleSubtreeStream(adaptor,"rule inputPortion");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "anonymousFunction");
		DebugLocation(634, 103);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:634:19: ( AT inputPortion expression -> ^( ANONYMOUSFUNCTION[$AT] ( inputPortion )? expression ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:634:21: AT inputPortion expression
			{
			DebugLocation(634, 21);
			AT417=(IToken)Match(input,AT,Follow._AT_in_anonymousFunction5741); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_AT.Add(AT417);

			DebugLocation(634, 24);
			PushFollow(Follow._inputPortion_in_anonymousFunction5743);
			inputPortion418=inputPortion();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_inputPortion.Add(inputPortion418.Tree);
			DebugLocation(634, 37);
			PushFollow(Follow._expression_in_anonymousFunction5745);
			expression419=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression419.Tree);


			{
			// AST REWRITE
			// elements: inputPortion, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 634:48: -> ^( ANONYMOUSFUNCTION[$AT] ( inputPortion )? expression )
			{
				DebugLocation(634, 51);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:634:51: ^( ANONYMOUSFUNCTION[$AT] ( inputPortion )? expression )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(634, 53);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ANONYMOUSFUNCTION, AT417), root_1);

				DebugLocation(634, 76);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:634:76: ( inputPortion )?
				if (stream_inputPortion.HasNext)
				{
					DebugLocation(634, 77);
					adaptor.AddChild(root_1, stream_inputPortion.NextTree());

				}
				stream_inputPortion.Reset();
				DebugLocation(634, 92);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("anonymousFunction", 146);
			LeaveRule("anonymousFunction", 146);
			LeaveRule_anonymousFunction();
		}
		DebugLocation(634, 103);
		} finally { DebugExitRule(GrammarFileName, "anonymousFunction"); }
		return retval;

	}
	// $ANTLR end "anonymousFunction"

	partial void EnterRule_metaclass();
	partial void LeaveRule_metaclass();
	// $ANTLR start "metaclass"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:638:1: metaclass : QUESTION classReference -> ^( QUESTION classReference ) ;
	[GrammarRule("metaclass")]
	private AstParserRuleReturnScope<object, IToken> metaclass()
	{
		EnterRule_metaclass();
		EnterRule("metaclass", 147);
		TraceIn("metaclass", 147);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken QUESTION420 = default(IToken);
		AstParserRuleReturnScope<object, IToken> classReference421 = default(AstParserRuleReturnScope<object, IToken>);

		object QUESTION420_tree = default(object);
		RewriteRuleITokenStream stream_QUESTION=new RewriteRuleITokenStream(adaptor,"token QUESTION");
		RewriteRuleSubtreeStream stream_classReference=new RewriteRuleSubtreeStream(adaptor,"rule classReference");
		try { DebugEnterRule(GrammarFileName, "metaclass");
		DebugLocation(638, 66);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:638:11: ( QUESTION classReference -> ^( QUESTION classReference ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:638:13: QUESTION classReference
			{
			DebugLocation(638, 13);
			QUESTION420=(IToken)Match(input,QUESTION,Follow._QUESTION_in_metaclass5770); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_QUESTION.Add(QUESTION420);

			DebugLocation(638, 22);
			PushFollow(Follow._classReference_in_metaclass5772);
			classReference421=classReference();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_classReference.Add(classReference421.Tree);


			{
			// AST REWRITE
			// elements: QUESTION, classReference
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 638:37: -> ^( QUESTION classReference )
			{
				DebugLocation(638, 40);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:638:40: ^( QUESTION classReference )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(638, 42);
				root_1 = (object)adaptor.BecomeRoot(stream_QUESTION.NextNode(), root_1);

				DebugLocation(638, 51);
				adaptor.AddChild(root_1, stream_classReference.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("metaclass", 147);
			LeaveRule("metaclass", 147);
			LeaveRule_metaclass();
		}
		DebugLocation(638, 66);
		} finally { DebugExitRule(GrammarFileName, "metaclass"); }
		return retval;

	}
	// $ANTLR end "metaclass"

	partial void EnterRule_xEOS();
	partial void LeaveRule_xEOS();
	// $ANTLR start "xEOS"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:642:1: xEOS : ( SEMICOLON -> NOPRINT[$SEMICOLON] | COMMA -> PRINT[$COMMA] | EOL -> PRINT[$EOL] );
	[GrammarRule("xEOS")]
	private AstParserRuleReturnScope<object, IToken> xEOS()
	{
		EnterRule_xEOS();
		EnterRule("xEOS", 148);
		TraceIn("xEOS", 148);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMICOLON422 = default(IToken);
		IToken COMMA423 = default(IToken);
		IToken EOL424 = default(IToken);

		object SEMICOLON422_tree = default(object);
		object COMMA423_tree = default(object);
		object EOL424_tree = default(object);
		RewriteRuleITokenStream stream_SEMICOLON=new RewriteRuleITokenStream(adaptor,"token SEMICOLON");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_EOL=new RewriteRuleITokenStream(adaptor,"token EOL");
		try { DebugEnterRule(GrammarFileName, "xEOS");
		DebugLocation(642, 2);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:642:6: ( SEMICOLON -> NOPRINT[$SEMICOLON] | COMMA -> PRINT[$COMMA] | EOL -> PRINT[$EOL] )
			int alt114=3;
			try { DebugEnterDecision(114, false);
			switch (input.LA(1))
			{
			case SEMICOLON:
				{
				alt114 = 1;
				}
				break;
			case COMMA:
				{
				alt114 = 2;
				}
				break;
			case EOL:
				{
				alt114 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 114, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(114); }
			switch (alt114)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:642:8: SEMICOLON
				{
				DebugLocation(642, 8);
				SEMICOLON422=(IToken)Match(input,SEMICOLON,Follow._SEMICOLON_in_xEOS5791); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SEMICOLON.Add(SEMICOLON422);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 642:18: -> NOPRINT[$SEMICOLON]
				{
					DebugLocation(642, 21);
					adaptor.AddChild(root_0, (object)adaptor.Create(NOPRINT, SEMICOLON422));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:643:5: COMMA
				{
				DebugLocation(643, 5);
				COMMA423=(IToken)Match(input,COMMA,Follow._COMMA_in_xEOS5802); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COMMA.Add(COMMA423);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 643:11: -> PRINT[$COMMA]
				{
					DebugLocation(643, 14);
					adaptor.AddChild(root_0, (object)adaptor.Create(PRINT, COMMA423));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:644:5: EOL
				{
				DebugLocation(644, 5);
				EOL424=(IToken)Match(input,EOL,Follow._EOL_in_xEOS5814); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_EOL.Add(EOL424);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 644:9: -> PRINT[$EOL]
				{
					DebugLocation(644, 12);
					adaptor.AddChild(root_0, (object)adaptor.Create(PRINT, EOL424));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("xEOS", 148);
			LeaveRule("xEOS", 148);
			LeaveRule_xEOS();
		}
		DebugLocation(645, 2);
		} finally { DebugExitRule(GrammarFileName, "xEOS"); }
		return retval;

	}
	// $ANTLR end "xEOS"

	partial void EnterRule_xEOL();
	partial void LeaveRule_xEOL();
	// $ANTLR start "xEOL"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:647:1: xEOL : EOL -> PRINT[$EOL] ;
	[GrammarRule("xEOL")]
	private AstParserRuleReturnScope<object, IToken> xEOL()
	{
		EnterRule_xEOL();
		EnterRule("xEOL", 149);
		TraceIn("xEOL", 149);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOL425 = default(IToken);

		object EOL425_tree = default(object);
		RewriteRuleITokenStream stream_EOL=new RewriteRuleITokenStream(adaptor,"token EOL");
		try { DebugEnterRule(GrammarFileName, "xEOL");
		DebugLocation(647, 26);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:647:6: ( EOL -> PRINT[$EOL] )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:647:8: EOL
			{
			DebugLocation(647, 8);
			EOL425=(IToken)Match(input,EOL,Follow._EOL_in_xEOL5831); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOL.Add(EOL425);



			{
			// AST REWRITE
			// elements: 
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 647:12: -> PRINT[$EOL]
			{
				DebugLocation(647, 15);
				adaptor.AddChild(root_0, (object)adaptor.Create(PRINT, EOL425));

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("xEOL", 149);
			LeaveRule("xEOL", 149);
			LeaveRule_xEOL();
		}
		DebugLocation(647, 26);
		} finally { DebugExitRule(GrammarFileName, "xEOL"); }
		return retval;

	}
	// $ANTLR end "xEOL"

	partial void EnterRule_xID();
	partial void LeaveRule_xID();
	// $ANTLR start "xID"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:649:1: xID : ID -> ID ;
	[GrammarRule("xID")]
	private AstParserRuleReturnScope<object, IToken> xID()
	{
		EnterRule_xID();
		EnterRule("xID", 150);
		TraceIn("xID", 150);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID426 = default(IToken);

		object ID426_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		try { DebugEnterRule(GrammarFileName, "xID");
		DebugLocation(649, 15);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:649:5: ( ID -> ID )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:649:7: ID
			{
			DebugLocation(649, 7);
			ID426=(IToken)Match(input,ID,Follow._ID_in_xID5845); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID426);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 649:10: -> ID
			{
				DebugLocation(649, 13);
				adaptor.AddChild(root_0, stream_ID.NextNode());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("xID", 150);
			LeaveRule("xID", 150);
			LeaveRule_xID();
		}
		DebugLocation(649, 15);
		} finally { DebugExitRule(GrammarFileName, "xID"); }
		return retval;

	}
	// $ANTLR end "xID"

	partial void EnterRule_xANYID();
	partial void LeaveRule_xANYID();
	// $ANTLR start "xANYID"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:651:1: xANYID : ( ID -> ID | BREAK -> ID[$BREAK] | CASE -> ID[$CASE] | CATCH -> ID[$CATCH] | CLASSDEF -> ID[$CLASSDEF] | CONTINUE -> ID[$CONTINUE] | ELSE -> ID[$ELSE] | ELSEIF -> ID[$ELSEIF] | END -> ID[$END] | FOR -> ID[$FOR] | FUNCTION -> ID[$FUNCTION] | GLOBAL -> ID[$GLOBAL] | IF -> ID[$IF] | OTHERWISE -> ID[$OTHERWISE] | PARFOR -> ID[$PARFOR] | PERSISTENT -> ID[$PERSISTENT] | RETURN -> ID[$RETURN] | SPMD -> ID[$SPMD] | SWITCH -> ID[$SWITCH] | TRY -> ID[$TRY] | WHILE -> ID[$WHILE] );
	[GrammarRule("xANYID")]
	private AstParserRuleReturnScope<object, IToken> xANYID()
	{
		EnterRule_xANYID();
		EnterRule("xANYID", 151);
		TraceIn("xANYID", 151);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID427 = default(IToken);
		IToken BREAK428 = default(IToken);
		IToken CASE429 = default(IToken);
		IToken CATCH430 = default(IToken);
		IToken CLASSDEF431 = default(IToken);
		IToken CONTINUE432 = default(IToken);
		IToken ELSE433 = default(IToken);
		IToken ELSEIF434 = default(IToken);
		IToken END435 = default(IToken);
		IToken FOR436 = default(IToken);
		IToken FUNCTION437 = default(IToken);
		IToken GLOBAL438 = default(IToken);
		IToken IF439 = default(IToken);
		IToken OTHERWISE440 = default(IToken);
		IToken PARFOR441 = default(IToken);
		IToken PERSISTENT442 = default(IToken);
		IToken RETURN443 = default(IToken);
		IToken SPMD444 = default(IToken);
		IToken SWITCH445 = default(IToken);
		IToken TRY446 = default(IToken);
		IToken WHILE447 = default(IToken);

		object ID427_tree = default(object);
		object BREAK428_tree = default(object);
		object CASE429_tree = default(object);
		object CATCH430_tree = default(object);
		object CLASSDEF431_tree = default(object);
		object CONTINUE432_tree = default(object);
		object ELSE433_tree = default(object);
		object ELSEIF434_tree = default(object);
		object END435_tree = default(object);
		object FOR436_tree = default(object);
		object FUNCTION437_tree = default(object);
		object GLOBAL438_tree = default(object);
		object IF439_tree = default(object);
		object OTHERWISE440_tree = default(object);
		object PARFOR441_tree = default(object);
		object PERSISTENT442_tree = default(object);
		object RETURN443_tree = default(object);
		object SPMD444_tree = default(object);
		object SWITCH445_tree = default(object);
		object TRY446_tree = default(object);
		object WHILE447_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_BREAK=new RewriteRuleITokenStream(adaptor,"token BREAK");
		RewriteRuleITokenStream stream_CASE=new RewriteRuleITokenStream(adaptor,"token CASE");
		RewriteRuleITokenStream stream_CATCH=new RewriteRuleITokenStream(adaptor,"token CATCH");
		RewriteRuleITokenStream stream_CLASSDEF=new RewriteRuleITokenStream(adaptor,"token CLASSDEF");
		RewriteRuleITokenStream stream_CONTINUE=new RewriteRuleITokenStream(adaptor,"token CONTINUE");
		RewriteRuleITokenStream stream_ELSE=new RewriteRuleITokenStream(adaptor,"token ELSE");
		RewriteRuleITokenStream stream_ELSEIF=new RewriteRuleITokenStream(adaptor,"token ELSEIF");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleITokenStream stream_GLOBAL=new RewriteRuleITokenStream(adaptor,"token GLOBAL");
		RewriteRuleITokenStream stream_IF=new RewriteRuleITokenStream(adaptor,"token IF");
		RewriteRuleITokenStream stream_OTHERWISE=new RewriteRuleITokenStream(adaptor,"token OTHERWISE");
		RewriteRuleITokenStream stream_PARFOR=new RewriteRuleITokenStream(adaptor,"token PARFOR");
		RewriteRuleITokenStream stream_PERSISTENT=new RewriteRuleITokenStream(adaptor,"token PERSISTENT");
		RewriteRuleITokenStream stream_RETURN=new RewriteRuleITokenStream(adaptor,"token RETURN");
		RewriteRuleITokenStream stream_SPMD=new RewriteRuleITokenStream(adaptor,"token SPMD");
		RewriteRuleITokenStream stream_SWITCH=new RewriteRuleITokenStream(adaptor,"token SWITCH");
		RewriteRuleITokenStream stream_TRY=new RewriteRuleITokenStream(adaptor,"token TRY");
		RewriteRuleITokenStream stream_WHILE=new RewriteRuleITokenStream(adaptor,"token WHILE");
		try { DebugEnterRule(GrammarFileName, "xANYID");
		DebugLocation(651, 4);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:651:8: ( ID -> ID | BREAK -> ID[$BREAK] | CASE -> ID[$CASE] | CATCH -> ID[$CATCH] | CLASSDEF -> ID[$CLASSDEF] | CONTINUE -> ID[$CONTINUE] | ELSE -> ID[$ELSE] | ELSEIF -> ID[$ELSEIF] | END -> ID[$END] | FOR -> ID[$FOR] | FUNCTION -> ID[$FUNCTION] | GLOBAL -> ID[$GLOBAL] | IF -> ID[$IF] | OTHERWISE -> ID[$OTHERWISE] | PARFOR -> ID[$PARFOR] | PERSISTENT -> ID[$PERSISTENT] | RETURN -> ID[$RETURN] | SPMD -> ID[$SPMD] | SWITCH -> ID[$SWITCH] | TRY -> ID[$TRY] | WHILE -> ID[$WHILE] )
			int alt115=21;
			try { DebugEnterDecision(115, false);
			switch (input.LA(1))
			{
			case ID:
				{
				alt115 = 1;
				}
				break;
			case BREAK:
				{
				alt115 = 2;
				}
				break;
			case CASE:
				{
				alt115 = 3;
				}
				break;
			case CATCH:
				{
				alt115 = 4;
				}
				break;
			case CLASSDEF:
				{
				alt115 = 5;
				}
				break;
			case CONTINUE:
				{
				alt115 = 6;
				}
				break;
			case ELSE:
				{
				alt115 = 7;
				}
				break;
			case ELSEIF:
				{
				alt115 = 8;
				}
				break;
			case END:
				{
				alt115 = 9;
				}
				break;
			case FOR:
				{
				alt115 = 10;
				}
				break;
			case FUNCTION:
				{
				alt115 = 11;
				}
				break;
			case GLOBAL:
				{
				alt115 = 12;
				}
				break;
			case IF:
				{
				alt115 = 13;
				}
				break;
			case OTHERWISE:
				{
				alt115 = 14;
				}
				break;
			case PARFOR:
				{
				alt115 = 15;
				}
				break;
			case PERSISTENT:
				{
				alt115 = 16;
				}
				break;
			case RETURN:
				{
				alt115 = 17;
				}
				break;
			case SPMD:
				{
				alt115 = 18;
				}
				break;
			case SWITCH:
				{
				alt115 = 19;
				}
				break;
			case TRY:
				{
				alt115 = 20;
				}
				break;
			case WHILE:
				{
				alt115 = 21;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 115, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(115); }
			switch (alt115)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:651:10: ID
				{
				DebugLocation(651, 10);
				ID427=(IToken)Match(input,ID,Follow._ID_in_xANYID5858); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID427);



				{
				// AST REWRITE
				// elements: ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 651:13: -> ID
				{
					DebugLocation(651, 16);
					adaptor.AddChild(root_0, stream_ID.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:652:7: BREAK
				{
				DebugLocation(652, 7);
				BREAK428=(IToken)Match(input,BREAK,Follow._BREAK_in_xANYID5871); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BREAK.Add(BREAK428);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 652:13: -> ID[$BREAK]
				{
					DebugLocation(652, 16);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, BREAK428));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:653:7: CASE
				{
				DebugLocation(653, 7);
				CASE429=(IToken)Match(input,CASE,Follow._CASE_in_xANYID5885); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CASE.Add(CASE429);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 653:12: -> ID[$CASE]
				{
					DebugLocation(653, 15);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, CASE429));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:654:7: CATCH
				{
				DebugLocation(654, 7);
				CATCH430=(IToken)Match(input,CATCH,Follow._CATCH_in_xANYID5899); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CATCH.Add(CATCH430);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 654:13: -> ID[$CATCH]
				{
					DebugLocation(654, 16);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, CATCH430));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:655:7: CLASSDEF
				{
				DebugLocation(655, 7);
				CLASSDEF431=(IToken)Match(input,CLASSDEF,Follow._CLASSDEF_in_xANYID5913); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CLASSDEF.Add(CLASSDEF431);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 655:16: -> ID[$CLASSDEF]
				{
					DebugLocation(655, 19);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, CLASSDEF431));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:656:7: CONTINUE
				{
				DebugLocation(656, 7);
				CONTINUE432=(IToken)Match(input,CONTINUE,Follow._CONTINUE_in_xANYID5927); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CONTINUE.Add(CONTINUE432);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 656:16: -> ID[$CONTINUE]
				{
					DebugLocation(656, 19);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, CONTINUE432));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:657:7: ELSE
				{
				DebugLocation(657, 7);
				ELSE433=(IToken)Match(input,ELSE,Follow._ELSE_in_xANYID5941); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ELSE.Add(ELSE433);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 657:12: -> ID[$ELSE]
				{
					DebugLocation(657, 15);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, ELSE433));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:658:7: ELSEIF
				{
				DebugLocation(658, 7);
				ELSEIF434=(IToken)Match(input,ELSEIF,Follow._ELSEIF_in_xANYID5955); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ELSEIF.Add(ELSEIF434);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 658:14: -> ID[$ELSEIF]
				{
					DebugLocation(658, 17);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, ELSEIF434));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:659:7: END
				{
				DebugLocation(659, 7);
				END435=(IToken)Match(input,END,Follow._END_in_xANYID5969); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_END.Add(END435);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 659:11: -> ID[$END]
				{
					DebugLocation(659, 14);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, END435));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:660:7: FOR
				{
				DebugLocation(660, 7);
				FOR436=(IToken)Match(input,FOR,Follow._FOR_in_xANYID5983); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_FOR.Add(FOR436);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 660:11: -> ID[$FOR]
				{
					DebugLocation(660, 14);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, FOR436));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:661:7: FUNCTION
				{
				DebugLocation(661, 7);
				FUNCTION437=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_xANYID5997); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION437);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 661:16: -> ID[$FUNCTION]
				{
					DebugLocation(661, 19);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, FUNCTION437));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:662:7: GLOBAL
				{
				DebugLocation(662, 7);
				GLOBAL438=(IToken)Match(input,GLOBAL,Follow._GLOBAL_in_xANYID6011); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_GLOBAL.Add(GLOBAL438);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 662:14: -> ID[$GLOBAL]
				{
					DebugLocation(662, 17);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, GLOBAL438));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:663:7: IF
				{
				DebugLocation(663, 7);
				IF439=(IToken)Match(input,IF,Follow._IF_in_xANYID6025); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IF.Add(IF439);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 663:10: -> ID[$IF]
				{
					DebugLocation(663, 13);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, IF439));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:664:7: OTHERWISE
				{
				DebugLocation(664, 7);
				OTHERWISE440=(IToken)Match(input,OTHERWISE,Follow._OTHERWISE_in_xANYID6039); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_OTHERWISE.Add(OTHERWISE440);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 664:17: -> ID[$OTHERWISE]
				{
					DebugLocation(664, 20);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, OTHERWISE440));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:665:7: PARFOR
				{
				DebugLocation(665, 7);
				PARFOR441=(IToken)Match(input,PARFOR,Follow._PARFOR_in_xANYID6053); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_PARFOR.Add(PARFOR441);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 665:14: -> ID[$PARFOR]
				{
					DebugLocation(665, 17);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, PARFOR441));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:666:7: PERSISTENT
				{
				DebugLocation(666, 7);
				PERSISTENT442=(IToken)Match(input,PERSISTENT,Follow._PERSISTENT_in_xANYID6067); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_PERSISTENT.Add(PERSISTENT442);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 666:18: -> ID[$PERSISTENT]
				{
					DebugLocation(666, 21);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, PERSISTENT442));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 17:
				DebugEnterAlt(17);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:667:7: RETURN
				{
				DebugLocation(667, 7);
				RETURN443=(IToken)Match(input,RETURN,Follow._RETURN_in_xANYID6081); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RETURN.Add(RETURN443);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 667:14: -> ID[$RETURN]
				{
					DebugLocation(667, 17);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, RETURN443));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 18:
				DebugEnterAlt(18);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:668:7: SPMD
				{
				DebugLocation(668, 7);
				SPMD444=(IToken)Match(input,SPMD,Follow._SPMD_in_xANYID6095); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SPMD.Add(SPMD444);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 668:12: -> ID[$SPMD]
				{
					DebugLocation(668, 15);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, SPMD444));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 19:
				DebugEnterAlt(19);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:669:7: SWITCH
				{
				DebugLocation(669, 7);
				SWITCH445=(IToken)Match(input,SWITCH,Follow._SWITCH_in_xANYID6109); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_SWITCH.Add(SWITCH445);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 669:14: -> ID[$SWITCH]
				{
					DebugLocation(669, 17);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, SWITCH445));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 20:
				DebugEnterAlt(20);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:670:7: TRY
				{
				DebugLocation(670, 7);
				TRY446=(IToken)Match(input,TRY,Follow._TRY_in_xANYID6123); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_TRY.Add(TRY446);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 670:11: -> ID[$TRY]
				{
					DebugLocation(670, 14);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, TRY446));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 21:
				DebugEnterAlt(21);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:671:7: WHILE
				{
				DebugLocation(671, 7);
				WHILE447=(IToken)Match(input,WHILE,Follow._WHILE_in_xANYID6137); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_WHILE.Add(WHILE447);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 671:13: -> ID[$WHILE]
				{
					DebugLocation(671, 16);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, WHILE447));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("xANYID", 151);
			LeaveRule("xANYID", 151);
			LeaveRule_xANYID();
		}
		DebugLocation(672, 4);
		} finally { DebugExitRule(GrammarFileName, "xANYID"); }
		return retval;

	}
	// $ANTLR end "xANYID"

	partial void EnterRule_xFUNCTIONID();
	partial void LeaveRule_xFUNCTIONID();
	// $ANTLR start "xFUNCTIONID"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:674:1: xFUNCTIONID : ( ID -> ID | END -> ID[$END] );
	[GrammarRule("xFUNCTIONID")]
	private AstParserRuleReturnScope<object, IToken> xFUNCTIONID()
	{
		EnterRule_xFUNCTIONID();
		EnterRule("xFUNCTIONID", 152);
		TraceIn("xFUNCTIONID", 152);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID448 = default(IToken);
		IToken END449 = default(IToken);

		object ID448_tree = default(object);
		object END449_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		try { DebugEnterRule(GrammarFileName, "xFUNCTIONID");
		DebugLocation(674, 3);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:674:13: ( ID -> ID | END -> ID[$END] )
			int alt116=2;
			try { DebugEnterDecision(116, false);
			int LA116_1 = input.LA(1);

			if ((LA116_1==ID))
			{
				alt116 = 1;
			}
			else if ((LA116_1==END))
			{
				alt116 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 116, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(116); }
			switch (alt116)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:674:15: ID
				{
				DebugLocation(674, 15);
				ID448=(IToken)Match(input,ID,Follow._ID_in_xFUNCTIONID6156); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID448);



				{
				// AST REWRITE
				// elements: ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 674:18: -> ID
				{
					DebugLocation(674, 21);
					adaptor.AddChild(root_0, stream_ID.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:675:6: END
				{
				DebugLocation(675, 6);
				END449=(IToken)Match(input,END,Follow._END_in_xFUNCTIONID6168); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_END.Add(END449);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 675:10: -> ID[$END]
				{
					DebugLocation(675, 13);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, END449));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("xFUNCTIONID", 152);
			LeaveRule("xFUNCTIONID", 152);
			LeaveRule_xFUNCTIONID();
		}
		DebugLocation(676, 3);
		} finally { DebugExitRule(GrammarFileName, "xFUNCTIONID"); }
		return retval;

	}
	// $ANTLR end "xFUNCTIONID"

	partial void EnterRule_xPARAMETERID();
	partial void LeaveRule_xPARAMETERID();
	// $ANTLR start "xPARAMETERID"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:678:1: xPARAMETERID : ( ID -> ID | NOT -> ID[$NOT] );
	[GrammarRule("xPARAMETERID")]
	private AstParserRuleReturnScope<object, IToken> xPARAMETERID()
	{
		EnterRule_xPARAMETERID();
		EnterRule("xPARAMETERID", 153);
		TraceIn("xPARAMETERID", 153);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID450 = default(IToken);
		IToken NOT451 = default(IToken);

		object ID450_tree = default(object);
		object NOT451_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_NOT=new RewriteRuleITokenStream(adaptor,"token NOT");
		try { DebugEnterRule(GrammarFileName, "xPARAMETERID");
		DebugLocation(678, 4);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:678:14: ( ID -> ID | NOT -> ID[$NOT] )
			int alt117=2;
			try { DebugEnterDecision(117, false);
			int LA117_1 = input.LA(1);

			if ((LA117_1==ID))
			{
				alt117 = 1;
			}
			else if ((LA117_1==NOT))
			{
				alt117 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 117, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(117); }
			switch (alt117)
			{
			case 1:
				DebugEnterAlt(1);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:678:16: ID
				{
				DebugLocation(678, 16);
				ID450=(IToken)Match(input,ID,Follow._ID_in_xPARAMETERID6186); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ID.Add(ID450);



				{
				// AST REWRITE
				// elements: ID
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 678:19: -> ID
				{
					DebugLocation(678, 22);
					adaptor.AddChild(root_0, stream_ID.NextNode());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:679:7: NOT
				{
				DebugLocation(679, 7);
				NOT451=(IToken)Match(input,NOT,Follow._NOT_in_xPARAMETERID6200); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NOT.Add(NOT451);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 679:11: -> ID[$NOT]
				{
					DebugLocation(679, 14);
					adaptor.AddChild(root_0, (object)adaptor.Create(ID, NOT451));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("xPARAMETERID", 153);
			LeaveRule("xPARAMETERID", 153);
			LeaveRule_xPARAMETERID();
		}
		DebugLocation(680, 4);
		} finally { DebugExitRule(GrammarFileName, "xPARAMETERID"); }
		return retval;

	}
	// $ANTLR end "xPARAMETERID"

	partial void EnterRule_xEVENTS();
	partial void LeaveRule_xEVENTS();
	// $ANTLR start "xEVENTS"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:682:1: xEVENTS :{...}? => ID -> ID ;
	[GrammarRule("xEVENTS")]
	private AstParserRuleReturnScope<object, IToken> xEVENTS()
	{
		EnterRule_xEVENTS();
		EnterRule("xEVENTS", 154);
		TraceIn("xEVENTS", 154);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID452 = default(IToken);

		object ID452_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		try { DebugEnterRule(GrammarFileName, "xEVENTS");
		DebugLocation(682, 50);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:682:9: ({...}? => ID -> ID )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:682:11: {...}? => ID
			{
			DebugLocation(682, 11);
			if (!((Keyword_EventsIdFollows())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xEVENTS", "Keyword_EventsIdFollows()");
			}
			DebugLocation(682, 42);
			ID452=(IToken)Match(input,ID,Follow._ID_in_xEVENTS6223); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID452);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 682:45: -> ID
			{
				DebugLocation(682, 48);
				adaptor.AddChild(root_0, stream_ID.NextNode());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("xEVENTS", 154);
			LeaveRule("xEVENTS", 154);
			LeaveRule_xEVENTS();
		}
		DebugLocation(682, 50);
		} finally { DebugExitRule(GrammarFileName, "xEVENTS"); }
		return retval;

	}
	// $ANTLR end "xEVENTS"

	partial void EnterRule_xPROPERTIES();
	partial void LeaveRule_xPROPERTIES();
	// $ANTLR start "xPROPERTIES"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:684:1: xPROPERTIES :{...}? => ID -> ID ;
	[GrammarRule("xPROPERTIES")]
	private AstParserRuleReturnScope<object, IToken> xPROPERTIES()
	{
		EnterRule_xPROPERTIES();
		EnterRule("xPROPERTIES", 155);
		TraceIn("xPROPERTIES", 155);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID453 = default(IToken);

		object ID453_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		try { DebugEnterRule(GrammarFileName, "xPROPERTIES");
		DebugLocation(684, 58);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:684:13: ({...}? => ID -> ID )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:684:15: {...}? => ID
			{
			DebugLocation(684, 15);
			if (!((Keyword_PropertiesIdFollows())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xPROPERTIES", "Keyword_PropertiesIdFollows()");
			}
			DebugLocation(684, 50);
			ID453=(IToken)Match(input,ID,Follow._ID_in_xPROPERTIES6239); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID453);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 684:53: -> ID
			{
				DebugLocation(684, 56);
				adaptor.AddChild(root_0, stream_ID.NextNode());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("xPROPERTIES", 155);
			LeaveRule("xPROPERTIES", 155);
			LeaveRule_xPROPERTIES();
		}
		DebugLocation(684, 58);
		} finally { DebugExitRule(GrammarFileName, "xPROPERTIES"); }
		return retval;

	}
	// $ANTLR end "xPROPERTIES"

	partial void EnterRule_xMETHODS();
	partial void LeaveRule_xMETHODS();
	// $ANTLR start "xMETHODS"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:686:1: xMETHODS :{...}? => ID -> ID ;
	[GrammarRule("xMETHODS")]
	private AstParserRuleReturnScope<object, IToken> xMETHODS()
	{
		EnterRule_xMETHODS();
		EnterRule("xMETHODS", 156);
		TraceIn("xMETHODS", 156);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID454 = default(IToken);

		object ID454_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		try { DebugEnterRule(GrammarFileName, "xMETHODS");
		DebugLocation(686, 52);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:686:10: ({...}? => ID -> ID )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:686:12: {...}? => ID
			{
			DebugLocation(686, 12);
			if (!((Keyword_MethodsIdFollows())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xMETHODS", "Keyword_MethodsIdFollows()");
			}
			DebugLocation(686, 44);
			ID454=(IToken)Match(input,ID,Follow._ID_in_xMETHODS6255); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID454);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 686:47: -> ID
			{
				DebugLocation(686, 50);
				adaptor.AddChild(root_0, stream_ID.NextNode());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("xMETHODS", 156);
			LeaveRule("xMETHODS", 156);
			LeaveRule_xMETHODS();
		}
		DebugLocation(686, 52);
		} finally { DebugExitRule(GrammarFileName, "xMETHODS"); }
		return retval;

	}
	// $ANTLR end "xMETHODS"

	partial void EnterRule_xENUMERATION();
	partial void LeaveRule_xENUMERATION();
	// $ANTLR start "xENUMERATION"
	// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:688:1: xENUMERATION :{...}? => ID -> ID ;
	[GrammarRule("xENUMERATION")]
	private AstParserRuleReturnScope<object, IToken> xENUMERATION()
	{
		EnterRule_xENUMERATION();
		EnterRule("xENUMERATION", 157);
		TraceIn("xENUMERATION", 157);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID455 = default(IToken);

		object ID455_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		try { DebugEnterRule(GrammarFileName, "xENUMERATION");
		DebugLocation(688, 60);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:688:14: ({...}? => ID -> ID )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:688:16: {...}? => ID
			{
			DebugLocation(688, 16);
			if (!((Keyword_EnumerationIdFollows())))
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				throw new FailedPredicateException(input, "xENUMERATION", "Keyword_EnumerationIdFollows()");
			}
			DebugLocation(688, 52);
			ID455=(IToken)Match(input,ID,Follow._ID_in_xENUMERATION6271); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID455);



			{
			// AST REWRITE
			// elements: ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 688:55: -> ID
			{
				DebugLocation(688, 58);
				adaptor.AddChild(root_0, stream_ID.NextNode());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("xENUMERATION", 157);
			LeaveRule("xENUMERATION", 157);
			LeaveRule_xENUMERATION();
		}
		DebugLocation(688, 60);
		} finally { DebugExitRule(GrammarFileName, "xENUMERATION"); }
		return retval;

	}
	// $ANTLR end "xENUMERATION"

	partial void EnterRule_synpred1_MatlabParser_fragment();
	partial void LeaveRule_synpred1_MatlabParser_fragment();

	// $ANTLR start synpred1_MatlabParser
	private void synpred1_MatlabParser_fragment()
	{
		EnterRule_synpred1_MatlabParser_fragment();
		EnterRule("synpred1_MatlabParser_fragment", 158);
		TraceIn("synpred1_MatlabParser_fragment", 158);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:128:16: ( openFunctionFile )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:128:17: openFunctionFile
			{
			DebugLocation(128, 17);
			PushFollow(Follow._openFunctionFile_in_synpred1_MatlabParser388);
			openFunctionFile();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_MatlabParser_fragment", 158);
			LeaveRule("synpred1_MatlabParser_fragment", 158);
			LeaveRule_synpred1_MatlabParser_fragment();
		}
	}
	// $ANTLR end synpred1_MatlabParser

	partial void EnterRule_synpred2_MatlabParser_fragment();
	partial void LeaveRule_synpred2_MatlabParser_fragment();

	// $ANTLR start synpred2_MatlabParser
	private void synpred2_MatlabParser_fragment()
	{
		EnterRule_synpred2_MatlabParser_fragment();
		EnterRule("synpred2_MatlabParser_fragment", 159);
		TraceIn("synpred2_MatlabParser_fragment", 159);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:286:13: ( assignment )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:286:14: assignment
			{
			DebugLocation(286, 14);
			PushFollow(Follow._assignment_in_synpred2_MatlabParser2114);
			assignment();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_MatlabParser_fragment", 159);
			LeaveRule("synpred2_MatlabParser_fragment", 159);
			LeaveRule_synpred2_MatlabParser_fragment();
		}
	}
	// $ANTLR end synpred2_MatlabParser

	partial void EnterRule_synpred3_MatlabParser_fragment();
	partial void LeaveRule_synpred3_MatlabParser_fragment();

	// $ANTLR start synpred3_MatlabParser
	private void synpred3_MatlabParser_fragment()
	{
		EnterRule_synpred3_MatlabParser_fragment();
		EnterRule("synpred3_MatlabParser_fragment", 160);
		TraceIn("synpred3_MatlabParser_fragment", 160);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:287:13: ( action )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:287:14: action
			{
			DebugLocation(287, 14);
			PushFollow(Follow._action_in_synpred3_MatlabParser2139);
			action();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_MatlabParser_fragment", 160);
			LeaveRule("synpred3_MatlabParser_fragment", 160);
			LeaveRule_synpred3_MatlabParser_fragment();
		}
	}
	// $ANTLR end synpred3_MatlabParser

	partial void EnterRule_synpred4_MatlabParser_fragment();
	partial void LeaveRule_synpred4_MatlabParser_fragment();

	// $ANTLR start synpred4_MatlabParser
	private void synpred4_MatlabParser_fragment()
	{
		EnterRule_synpred4_MatlabParser_fragment();
		EnterRule("synpred4_MatlabParser_fragment", 161);
		TraceIn("synpred4_MatlabParser_fragment", 161);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:288:7: ( simpleCommand )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:288:8: simpleCommand
			{
			DebugLocation(288, 8);
			PushFollow(Follow._simpleCommand_in_synpred4_MatlabParser2158);
			simpleCommand();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred4_MatlabParser_fragment", 161);
			LeaveRule("synpred4_MatlabParser_fragment", 161);
			LeaveRule_synpred4_MatlabParser_fragment();
		}
	}
	// $ANTLR end synpred4_MatlabParser

	partial void EnterRule_synpred5_MatlabParser_fragment();
	partial void LeaveRule_synpred5_MatlabParser_fragment();

	// $ANTLR start synpred5_MatlabParser
	private void synpred5_MatlabParser_fragment()
	{
		EnterRule_synpred5_MatlabParser_fragment();
		EnterRule("synpred5_MatlabParser_fragment", 162);
		TraceIn("synpred5_MatlabParser_fragment", 162);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:289:7: ( abortCommand )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:289:8: abortCommand
			{
			DebugLocation(289, 8);
			PushFollow(Follow._abortCommand_in_synpred5_MatlabParser2177);
			abortCommand();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred5_MatlabParser_fragment", 162);
			LeaveRule("synpred5_MatlabParser_fragment", 162);
			LeaveRule_synpred5_MatlabParser_fragment();
		}
	}
	// $ANTLR end synpred5_MatlabParser

	partial void EnterRule_synpred6_MatlabParser_fragment();
	partial void LeaveRule_synpred6_MatlabParser_fragment();

	// $ANTLR start synpred6_MatlabParser
	private void synpred6_MatlabParser_fragment()
	{
		EnterRule_synpred6_MatlabParser_fragment();
		EnterRule("synpred6_MatlabParser_fragment", 163);
		TraceIn("synpred6_MatlabParser_fragment", 163);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:404:14: ( LPAREN var ASSIGN expression COMMA )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:404:15: LPAREN var ASSIGN expression COMMA
			{
			DebugLocation(404, 15);
			Match(input,LPAREN,Follow._LPAREN_in_synpred6_MatlabParser3393); if (state.failed) return;
			DebugLocation(404, 22);
			PushFollow(Follow._var_in_synpred6_MatlabParser3395);
			var();
			PopFollow();
			if (state.failed) return;
			DebugLocation(404, 26);
			Match(input,ASSIGN,Follow._ASSIGN_in_synpred6_MatlabParser3397); if (state.failed) return;
			DebugLocation(404, 33);
			PushFollow(Follow._expression_in_synpred6_MatlabParser3399);
			expression();
			PopFollow();
			if (state.failed) return;
			DebugLocation(404, 44);
			Match(input,COMMA,Follow._COMMA_in_synpred6_MatlabParser3401); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred6_MatlabParser_fragment", 163);
			LeaveRule("synpred6_MatlabParser_fragment", 163);
			LeaveRule_synpred6_MatlabParser_fragment();
		}
	}
	// $ANTLR end synpred6_MatlabParser

	partial void EnterRule_synpred7_MatlabParser_fragment();
	partial void LeaveRule_synpred7_MatlabParser_fragment();

	// $ANTLR start synpred7_MatlabParser
	private void synpred7_MatlabParser_fragment()
	{
		EnterRule_synpred7_MatlabParser_fragment();
		EnterRule("synpred7_MatlabParser_fragment", 164);
		TraceIn("synpred7_MatlabParser_fragment", 164);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:533:5: ( DOT LPAREN )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:533:6: DOT LPAREN
			{
			DebugLocation(533, 6);
			Match(input,DOT,Follow._DOT_in_synpred7_MatlabParser4949); if (state.failed) return;
			DebugLocation(533, 10);
			Match(input,LPAREN,Follow._LPAREN_in_synpred7_MatlabParser4951); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred7_MatlabParser_fragment", 164);
			LeaveRule("synpred7_MatlabParser_fragment", 164);
			LeaveRule_synpred7_MatlabParser_fragment();
		}
	}
	// $ANTLR end synpred7_MatlabParser

	partial void EnterRule_synpred8_MatlabParser_fragment();
	partial void LeaveRule_synpred8_MatlabParser_fragment();

	// $ANTLR start synpred8_MatlabParser
	private void synpred8_MatlabParser_fragment()
	{
		EnterRule_synpred8_MatlabParser_fragment();
		EnterRule("synpred8_MatlabParser_fragment", 165);
		TraceIn("synpred8_MatlabParser_fragment", 165);
		try
		{
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:602:10: ( NOT ( COMMA | SEMICOLON | EOL | RSQUARE ) )
			DebugEnterAlt(1);
			// d:\\!users\\samuel\\documents\\visual studio 2013\\Projects\\Matlab\\Matlab.Recognizer\\01 ANTLR\\MatlabParser.g3:602:11: NOT ( COMMA | SEMICOLON | EOL | RSQUARE )
			{
			DebugLocation(602, 11);
			Match(input,NOT,Follow._NOT_in_synpred8_MatlabParser5520); if (state.failed) return;
			DebugLocation(602, 15);
			if (input.LA(1)==COMMA||input.LA(1)==EOL||(input.LA(1)>=RSQUARE && input.LA(1)<=SEMICOLON))
			{
				input.Consume();
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred8_MatlabParser_fragment", 165);
			LeaveRule("synpred8_MatlabParser_fragment", 165);
			LeaveRule_synpred8_MatlabParser_fragment();
		}
	}
	// $ANTLR end synpred8_MatlabParser
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA1 dfa1;
	private DFA22 dfa22;
	private DFA51 dfa51;
	private DFA101 dfa101;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa1 = new DFA1( this, SpecialStateTransition1 );
		dfa22 = new DFA22( this );
		dfa51 = new DFA51( this );
		dfa101 = new DFA101( this, SpecialStateTransition101 );
	}

	private class DFA1 : DFA
	{
		private const string DFA1_eotS =
			"\x9\xFFFF";
		private const string DFA1_eofS =
			"\x1\x5\x5\xFFFF\x1\x5\x2\xFFFF";
		private const string DFA1_minS =
			"\x1\x6\x5\xFFFF\x1\x6\x2\xFFFF";
		private const string DFA1_maxS =
			"\x1\x5D\x5\xFFFF\x1\x5D\x2\xFFFF";
		private const string DFA1_acceptS =
			"\x1\xFFFF\x5\x1\x1\xFFFF\x1\x2\x1\x3";
		private const string DFA1_specialS =
			"\x1\x0\x8\xFFFF}>";
		private static readonly string[] DFA1_transitionS =
			{
				"\x1\x4\x2\xFFFF\x1\x5\x2\xFFFF\x1\x8\x1\xFFFF\x2\x5\x1\xFFFF\x1\x5\xC"+
				"\xFFFF\x1\x3\x1\x6\x1\xFFFF\x1\x5\x1\xFFFF\x1\x5\x1\x7\x1\x5\x2\xFFFF"+
				"\x1\x1\x1\x5\x1\x2\x1\xFFFF\x1\x2\x7\xFFFF\x2\x2\x2\xFFFF\x1\x2\x4\xFFFF"+
				"\x1\x2\x4\xFFFF\x2\x5\x1\x2\x2\xFFFF\x1\x4\x3\xFFFF\x1\x2\x1\x5\x2\xFFFF"+
				"\x1\x5\x4\xFFFF\x1\x5\x1\xFFFF\x1\x2\x1\xFFFF\x1\x5\x2\xFFFF\x1\x5\x1"+
				"\xFFFF\x1\x5",
				"",
				"",
				"",
				"",
				"",
				"\x1\x5\x2\xFFFF\x1\x5\x2\xFFFF\x1\x8\x1\xFFFF\x2\x5\x1\xFFFF\x1\x5\xC"+
				"\xFFFF\x1\x5\x1\x6\x1\xFFFF\x1\x5\x1\xFFFF\x1\x5\x1\x7\x1\x5\x2\xFFFF"+
				"\x3\x5\x1\xFFFF\x1\x5\x7\xFFFF\x2\x5\x2\xFFFF\x1\x5\x4\xFFFF\x1\x5\x4"+
				"\xFFFF\x3\x5\x2\xFFFF\x1\x5\x3\xFFFF\x2\x5\x2\xFFFF\x1\x5\x4\xFFFF\x1"+
				"\x5\x1\xFFFF\x1\x5\x1\xFFFF\x1\x5\x2\xFFFF\x1\x5\x1\xFFFF\x1\x5",
				"",
				""
			};

		private static readonly short[] DFA1_eot = DFA.UnpackEncodedString(DFA1_eotS);
		private static readonly short[] DFA1_eof = DFA.UnpackEncodedString(DFA1_eofS);
		private static readonly char[] DFA1_min = DFA.UnpackEncodedStringToUnsignedChars(DFA1_minS);
		private static readonly char[] DFA1_max = DFA.UnpackEncodedStringToUnsignedChars(DFA1_maxS);
		private static readonly short[] DFA1_accept = DFA.UnpackEncodedString(DFA1_acceptS);
		private static readonly short[] DFA1_special = DFA.UnpackEncodedString(DFA1_specialS);
		private static readonly short[][] DFA1_transition;

		static DFA1()
		{
			int numStates = DFA1_transitionS.Length;
			DFA1_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA1_transition[i] = DFA.UnpackEncodedString(DFA1_transitionS[i]);
			}
		}

		public DFA1( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 1;
			this.eot = DFA1_eot;
			this.eof = DFA1_eof;
			this.min = DFA1_min;
			this.max = DFA1_max;
			this.accept = DFA1_accept;
			this.special = DFA1_special;
			this.transition = DFA1_transition;
		}

		public override string Description { get { return "115:8: public file : ( scriptFile -> scriptFile | functionFile -> functionFile | classFile -> classFile );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition1(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		s = -1;
		int LA1_1 = input.LA(1);
		int index1_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				input.Rewind();
				if ((LA1_1==ID) && (((True())||(Command_IsEnabled())))) {s = 1;}

				else if ((LA1_1==IMAGINARY||LA1_1==LCURLY||(LA1_1>=LPAREN && LA1_1<=LSQUARE)||LA1_1==MINUS||LA1_1==NOT||LA1_1==PLUS||LA1_1==REAL||LA1_1==STRING) && ((True()))) {s = 2;}

				else if ((LA1_1==END) && (((True())&&(Index_IsActive())))) {s = 3;}

				else if ((LA1_1==AT||LA1_1==QUESTION) && ((True()))) {s = 4;}

				else if ((LA1_1==EOF||LA1_1==BREAK||(LA1_1>=COMMA && LA1_1<=COMMAND)||LA1_1==CONTINUE||LA1_1==EXCLAMATION||LA1_1==FOR||LA1_1==GLOBAL||LA1_1==IF||(LA1_1>=PARFOR && LA1_1<=PERSISTENT)||LA1_1==RETURN||LA1_1==SEMICOLON||LA1_1==SPMD||LA1_1==SWITCH||LA1_1==TRY||LA1_1==WHILE)) {s = 5;}

				else if ((LA1_1==EOL)) {s = 6;}

				else if ((LA1_1==FUNCTION)) {s = 7;}

				else if ((LA1_1==CLASSDEF)) {s = 8;}

				input.Seek(index1_1);
				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 1, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA22 : DFA
	{
		private const string DFA22_eotS =
			"\x4\xFFFF";
		private const string DFA22_eofS =
			"\x2\x2\x2\xFFFF";
		private const string DFA22_minS =
			"\x2\x1F\x2\xFFFF";
		private const string DFA22_maxS =
			"\x2\x24\x2\xFFFF";
		private const string DFA22_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA22_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA22_transitionS =
			{
				"\x1\x1\x4\xFFFF\x1\x3",
				"\x1\x1\x4\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA22_eot = DFA.UnpackEncodedString(DFA22_eotS);
		private static readonly short[] DFA22_eof = DFA.UnpackEncodedString(DFA22_eofS);
		private static readonly char[] DFA22_min = DFA.UnpackEncodedStringToUnsignedChars(DFA22_minS);
		private static readonly char[] DFA22_max = DFA.UnpackEncodedStringToUnsignedChars(DFA22_maxS);
		private static readonly short[] DFA22_accept = DFA.UnpackEncodedString(DFA22_acceptS);
		private static readonly short[] DFA22_special = DFA.UnpackEncodedString(DFA22_specialS);
		private static readonly short[][] DFA22_transition;

		static DFA22()
		{
			int numStates = DFA22_transitionS.Length;
			DFA22_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA22_transition[i] = DFA.UnpackEncodedString(DFA22_transitionS[i]);
			}
		}

		public DFA22( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 22;
			this.eot = DFA22_eot;
			this.eof = DFA22_eof;
			this.min = DFA22_min;
			this.max = DFA22_max;
			this.accept = DFA22_accept;
			this.special = DFA22_special;
			this.transition = DFA22_transition;
		}

		public override string Description { get { return "()* loopback of 180:32: ( ( EOL )* closeFunction )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA51 : DFA
	{
		private const string DFA51_eotS =
			"\x3D\xFFFF";
		private const string DFA51_eofS =
			"\x3D\xFFFF";
		private const string DFA51_minS =
			"\x1\x28\x1\x5\x1\x28\x1\x1E\x2\xFFFF\x1\x6\x1\x5\x1\xE\x1\xFFFF\x2\x28"+
			"\x1\x6\x1\x1E\x1\xE\x1\x28\x1\x9\x16\xE\x1\x9\x15\xE";
		private const string DFA51_maxS =
			"\x1\x35\x1\x4F\x1\x4E\x1\x28\x2\xFFFF\x1\x4E\x1\x5\x1\x4F\x1\xFFFF\x2"+
			"\x28\x1\x4E\x1\x28\x1\x4E\x1\x28\x1\x5D\x16\x4E\x1\x5D\x15\x4E";
		private const string DFA51_acceptS =
			"\x4\xFFFF\x1\x1\x1\x3\x3\xFFFF\x1\x2\x33\xFFFF";
		private const string DFA51_specialS =
			"\x3D\xFFFF}>";
		private static readonly string[] DFA51_transitionS =
			{
				"\x1\x1\xC\xFFFF\x1\x2",
				"\x1\x3\x8\xFFFF\x1\x5\xB\xFFFF\x1\x4\x3\xFFFF\x2\x5\x14\xFFFF\x1\x5"+
				"\x1A\xFFFF\x1\x5",
				"\x1\x6\x25\xFFFF\x1\x7",
				"\x1\x9\x9\xFFFF\x1\x8",
				"",
				"",
				"\x1\xA\x7\xFFFF\x1\xB\x19\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xD",
				"\x1\x9\xB\xFFFF\x1\x4\x3\xFFFF\x2\x9\x14\xFFFF\x1\x9\x1A\xFFFF\x1\x9",
				"",
				"\x1\xE",
				"\x1\xC",
				"\x1\xF\x7\xFFFF\x1\xB\x19\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\x9\x9\xFFFF\x1\x8",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\x11",
				"\x1\x13\x1\x14\x1\x15\x1\x16\x4\xFFFF\x1\x17\xA\xFFFF\x1\x18\x1\x19"+
				"\x1\x1A\x4\xFFFF\x1\x1B\x1\x1C\x1\x1D\x2\xFFFF\x1\x12\x1\x1E\x17\xFFFF"+
				"\x1\x1F\x1\x20\x1\x21\x8\xFFFF\x1\x22\x7\xFFFF\x1\x23\x3\xFFFF\x1\x24"+
				"\x2\xFFFF\x1\x25\x1\xFFFF\x1\x26",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x10\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\x29\x1\x2A\x1\x2B\x1\x2C\x4\xFFFF\x1\x2D\xA\xFFFF\x1\x2E\x1\x2F"+
				"\x1\x30\x4\xFFFF\x1\x31\x1\x32\x1\x33\x2\xFFFF\x1\x28\x1\x34\x17\xFFFF"+
				"\x1\x35\x1\x36\x1\x37\x8\xFFFF\x1\x38\x7\xFFFF\x1\x39\x3\xFFFF\x1\x3A"+
				"\x2\xFFFF\x1\x3B\x1\xFFFF\x1\x3C",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7",
				"\x1\xB\xB\xFFFF\x1\x27\xD\xFFFF\x1\xC\x25\xFFFF\x1\x7"
			};

		private static readonly short[] DFA51_eot = DFA.UnpackEncodedString(DFA51_eotS);
		private static readonly short[] DFA51_eof = DFA.UnpackEncodedString(DFA51_eofS);
		private static readonly char[] DFA51_min = DFA.UnpackEncodedStringToUnsignedChars(DFA51_minS);
		private static readonly char[] DFA51_max = DFA.UnpackEncodedStringToUnsignedChars(DFA51_maxS);
		private static readonly short[] DFA51_accept = DFA.UnpackEncodedString(DFA51_acceptS);
		private static readonly short[] DFA51_special = DFA.UnpackEncodedString(DFA51_specialS);
		private static readonly short[][] DFA51_transition;

		static DFA51()
		{
			int numStates = DFA51_transitionS.Length;
			DFA51_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA51_transition[i] = DFA.UnpackEncodedString(DFA51_transitionS[i]);
			}
		}

		public DFA51( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 51;
			this.eot = DFA51_eot;
			this.eof = DFA51_eof;
			this.min = DFA51_min;
			this.max = DFA51_max;
			this.accept = DFA51_accept;
			this.special = DFA51_special;
			this.transition = DFA51_transition;
		}

		public override string Description { get { return "253:1: methodSignature : ( ( outputPortion )? methodName1 ( inputPortion )? -> methodName1 ( inputPortion )? ( outputPortion )? | outputPortion methodName2 ( inputPortion )? -> methodName2 ( inputPortion )? ( outputPortion )? | methodName3 ( inputPortion )? -> methodName3 ( inputPortion )? );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA101 : DFA
	{
		private const string DFA101_eotS =
			"\x42\xFFFF";
		private const string DFA101_eofS =
			"\x42\xFFFF";
		private const string DFA101_minS =
			"\x1\x4\x25\xFFFF\x3\x0\x13\xFFFF\x1\x0\x5\xFFFF";
		private const string DFA101_maxS =
			"\x1\x5D\x25\xFFFF\x3\x0\x13\xFFFF\x1\x0\x5\xFFFF";
		private const string DFA101_acceptS =
			"\x1\xFFFF\x1\x6\x2\xFFFF\x1\x6\x1\xFFFF\x1\x6\xA\xFFFF\x1\x6\x1\xFFFF"+
			"\x1\x6\xE\xFFFF\x1\x6\x6\xFFFF\x1\x6\x13\xFFFF\x1\x4\x1\x3\x1\x5\x1\x1"+
			"\x1\x2";
		private const string DFA101_specialS =
			"\x1\x0\x25\xFFFF\x1\x1\x1\x2\x1\x3\x13\xFFFF\x1\x4\x5\xFFFF}>";
		private static readonly string[] DFA101_transitionS =
			{
				"\x1\x13\x1\x1\x1\x28\x2\xFFFF\x2\x29\x2\xFFFF\x1\x13\x1\x1\x1\x29\x1"+
				"\xFFFF\x1\x29\x1\x6\x7\xFFFF\x1\x3C\x1\xFFFF\x2\x29\x3\x13\x1\x29\x1"+
				"\xFFFF\x1\x29\x1\xFFFF\x1\x29\x2\x13\x1\x1\x1\x29\x1\x22\x1\xFFFF\x1"+
				"\x26\x1\x6\x6\xFFFF\x1\x27\x1\x22\x2\x13\x1\x11\x4\x6\x1\x4\x1\x13\x1"+
				"\xFFFF\x1\x13\x3\x29\x1\x11\x1\xFFFF\x1\x6\x1\x4\x1\xFFFF\x1\x29\x1"+
				"\x6\x1\x22\x1\x29\x1\x13\x1\x6\x3\x13\x2\xFFFF\x1\x29\x1\xFFFF\x1\x22"+
				"\x1\xFFFF\x1\x29\x2\x6\x1\x29\x1\xFFFF\x1\x29",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA101_eot = DFA.UnpackEncodedString(DFA101_eotS);
		private static readonly short[] DFA101_eof = DFA.UnpackEncodedString(DFA101_eofS);
		private static readonly char[] DFA101_min = DFA.UnpackEncodedStringToUnsignedChars(DFA101_minS);
		private static readonly char[] DFA101_max = DFA.UnpackEncodedStringToUnsignedChars(DFA101_maxS);
		private static readonly short[] DFA101_accept = DFA.UnpackEncodedString(DFA101_acceptS);
		private static readonly short[] DFA101_special = DFA.UnpackEncodedString(DFA101_specialS);
		private static readonly short[][] DFA101_transition;

		static DFA101()
		{
			int numStates = DFA101_transitionS.Length;
			DFA101_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA101_transition[i] = DFA.UnpackEncodedString(DFA101_transitionS[i]);
			}
		}

		public DFA101( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 101;
			this.eot = DFA101_eot;
			this.eof = DFA101_eof;
			this.min = DFA101_min;
			this.max = DFA101_max;
			this.accept = DFA101_accept;
			this.special = DFA101_special;
			this.transition = DFA101_transition;
		}

		public override string Description { get { return "()* loopback of 533:5: ( ( DOT LPAREN )=>x2= dotExpressionOperator -> ^( DOTEXPRESSION[$x2.start] $chain $x2) |x3= dotNameOperator -> ^( DOTNAME[$x3.start] $chain $x3) |x4= parenthesisOperator -> ^( PARENTHESIS[$x4.start] $chain ( $x4)? ) |x5= curlyBraceOperator -> ^( CURLYBRACE[$x5.start] $chain $x5) |x6= atBaseOperator -> ^( ATBASE[$x6.start] $chain $x6) )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition101(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		s = -1;
		int LA101_1 = input.LA(1);
		int index101_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				input.Rewind();
				if ((LA101_1==ASSIGN||LA101_1==COMMA||LA101_1==ID)) {s = 1;}

				else if ((LA101_1==NOT||LA101_1==QUESTION) && (((Separator_CommaFollowsOrSpacesPrecede())||(True())))) {s = 4;}

				else if ((LA101_1==CTRANS||LA101_1==LDIV||(LA101_1>=MLDIV && LA101_1<=MTIMES)||LA101_1==POW||LA101_1==RDIV||LA101_1==RSQUARE||(LA101_1>=TIMES && LA101_1<=TRANS))) {s = 6;}

				else if ((LA101_1==MINUS||LA101_1==PLUS) && (((!Balance_InCreationOrStore_SpacesOnLeftButNotOnRight())||(True())||(Separator_CommaFollowsOrSpacesPrecede())))) {s = 17;}

				else if ((LA101_1==AND||LA101_1==COLON||(LA101_1>=END && LA101_1<=EQ)||(LA101_1>=GT && LA101_1<=GTEQ)||(LA101_1>=LT && LA101_1<=LTEQ)||LA101_1==NOTEQ||LA101_1==OR||LA101_1==RPAREN||(LA101_1>=SEMICOLON && LA101_1<=SHORTOR))) {s = 19;}

				else if ((LA101_1==IMAGINARY||LA101_1==LSQUARE||LA101_1==REAL||LA101_1==STRING) && (((True())||(Separator_CommaFollowsOrSpacesPrecede())))) {s = 34;}

				else if ((LA101_1==LCURLY) && (((True())||(Separator_CommaFollowsOrSpacesPrecede())||((Chain_MayAddCurlyBrace())&&(!Balance_InCreationOrStore_SpacesOnLeft()))))) {s = 38;}

				else if ((LA101_1==LPAREN) && (((True())||(Separator_CommaFollowsOrSpacesPrecede())||((Chain_MayAddParenthesis())&&(!Balance_InCreationOrStore_SpacesOnLeft()))))) {s = 39;}

				else if ((LA101_1==AT) && (((True())||(Separator_CommaFollowsOrSpacesPrecede())||((Chain_MayAddAtBase())&&(!Balance_InCreationOrStore_SpacesOnLeft()))))) {s = 40;}

				else if (((LA101_1>=BREAK && LA101_1<=CASE)||LA101_1==COMMAND||LA101_1==CONTINUE||(LA101_1>=ELSE && LA101_1<=ELSEIF)||LA101_1==EXCLAMATION||LA101_1==FOR||LA101_1==GLOBAL||LA101_1==IF||(LA101_1>=OTHERWISE && LA101_1<=PERSISTENT)||LA101_1==RCURLY||LA101_1==RETURN||LA101_1==SPMD||LA101_1==SWITCH||LA101_1==TRY||LA101_1==WHILE)) {s = 41;}

				else if ((LA101_1==DOT) && ((Chain_MayAddDotName()))) {s = 60;}

				input.Seek(index101_1);
				break;
			}
		case 1:
			{
				input.Rewind();
				if ((((Chain_MayAddCurlyBrace())&&(!Balance_InCreationOrStore_SpacesOnLeft())))) {s = 61;}

				else if ((((True())||(Separator_CommaFollowsOrSpacesPrecede())))) {s = 41;}

				input.Seek(index101_1);
				break;
			}
		case 2:
			{
				input.Rewind();
				if ((((Chain_MayAddParenthesis())&&(!Balance_InCreationOrStore_SpacesOnLeft())))) {s = 62;}

				else if ((((True())||(Separator_CommaFollowsOrSpacesPrecede())))) {s = 41;}

				input.Seek(index101_1);
				break;
			}
		case 3:
			{
				input.Rewind();
				if ((((Chain_MayAddAtBase())&&(!Balance_InCreationOrStore_SpacesOnLeft())))) {s = 63;}

				else if ((((True())||(Separator_CommaFollowsOrSpacesPrecede())))) {s = 41;}

				input.Seek(index101_1);
				break;
			}
		case 4:
			{
				input.Rewind();
				if (((EvaluatePredicate(synpred7_MatlabParser_fragment)&&(Chain_MayAddDotExpression())))) {s = 64;}

				else if (((Chain_MayAddDotName()))) {s = 65;}

				input.Seek(index101_1);
				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 101, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}

	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _scriptFile_in_file296 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionFile_in_file308 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classFile_in_file320 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statements_in_scriptFile339 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_scriptFile341 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_statements363 = new BitSet(new ulong[]{0x2130172AC002C242UL,0x2950989CUL});
		public static readonly BitSet _xEOS_in_statements367 = new BitSet(new ulong[]{0x2130172AC002C242UL,0x2950989CUL});
		public static readonly BitSet _openFunctionFile_in_functionFile392 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _closeFunctionFile_in_functionFile405 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOL_in_openFunctionFile426 = new BitSet(new ulong[]{0x1080000000UL});
		public static readonly BitSet _openFunctions_in_openFunctionFile430 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_openFunctionFile432 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _openFunction_in_openFunctions451 = new BitSet(new ulong[]{0x1000000002UL});
		public static readonly BitSet _FUNCTION_in_openFunction469 = new BitSet(new ulong[]{0x20010000000000UL});
		public static readonly BitSet _functionSignature_in_openFunction471 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _openBody_in_openFunction473 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _outputPortion_in_functionSignature495 = new BitSet(new ulong[]{0x10040000000UL});
		public static readonly BitSet _functionName_in_functionSignature497 = new BitSet(new ulong[]{0x10000000000002UL});
		public static readonly BitSet _inputPortion_in_functionSignature500 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_in_functionSignature526 = new BitSet(new ulong[]{0x10000000000002UL});
		public static readonly BitSet _inputPortion_in_functionSignature529 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _output_in_outputPortion555 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_outputPortion557 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _outputVector_in_outputPortion571 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_outputPortion573 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_in_output594 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xID_in_name612 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LSQUARE_in_outputVector630 = new BitSet(new ulong[]{0x10000000000UL,0x4000UL});
		public static readonly BitSet _vectorOutputs_in_outputVector633 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RSQUARE_in_outputVector637 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _vectorOutput_in_vectorOutputs653 = new BitSet(new ulong[]{0x10000004002UL});
		public static readonly BitSet _COMMA_in_vectorOutputs660 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _vectorOutput_in_vectorOutputs664 = new BitSet(new ulong[]{0x10000004002UL});
		public static readonly BitSet _name_in_vectorOutput682 = new BitSet(new ulong[]{0x42UL});
		public static readonly BitSet _filter_in_vectorOutput688 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _AT_in_filter713 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _classReference_in_filter715 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xFUNCTIONID_in_functionName728 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_inputPortion746 = new BitSet(new ulong[]{0x2000010000000000UL,0x2000UL});
		public static readonly BitSet _parameters_in_inputPortion749 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _RPAREN_in_inputPortion753 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parameter_in_parameters769 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _COMMA_in_parameters772 = new BitSet(new ulong[]{0x2000010000000000UL});
		public static readonly BitSet _parameter_in_parameters774 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _parameterName_in_parameter792 = new BitSet(new ulong[]{0x42UL});
		public static readonly BitSet _filter_in_parameter798 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xPARAMETERID_in_parameterName823 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xEOS_in_openBody842 = new BitSet(new ulong[]{0x2130172AC002C240UL,0x2950989CUL});
		public static readonly BitSet _openItems_in_openBody844 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _openItem_in_openItems863 = new BitSet(new ulong[]{0x2130172AC002C242UL,0x2950989CUL});
		public static readonly BitSet _xEOS_in_openItems867 = new BitSet(new ulong[]{0x2130172AC002C242UL,0x2950989CUL});
		public static readonly BitSet _statement_in_openItem885 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOL_in_closeFunctionFile901 = new BitSet(new ulong[]{0x1080000000UL});
		public static readonly BitSet _closeFunctions_in_closeFunctionFile905 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOL_in_closeFunctionFile908 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_closeFunctionFile912 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _closeFunction_in_closeFunctions930 = new BitSet(new ulong[]{0x1080000002UL});
		public static readonly BitSet _EOL_in_closeFunctions934 = new BitSet(new ulong[]{0x1080000000UL});
		public static readonly BitSet _closeFunction_in_closeFunctions938 = new BitSet(new ulong[]{0x1080000002UL});
		public static readonly BitSet _FUNCTION_in_closeFunction956 = new BitSet(new ulong[]{0x20010000000000UL});
		public static readonly BitSet _functionSignature_in_closeFunction958 = new BitSet(new ulong[]{0xC0004000UL,0x8000UL});
		public static readonly BitSet _closeBody_in_closeFunction960 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _END_in_closeFunction962 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xEOS_in_closeBody985 = new BitSet(new ulong[]{0x2130173AC002C240UL,0x2950989CUL});
		public static readonly BitSet _closeItems_in_closeBody987 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _closeItem_in_closeItems1006 = new BitSet(new ulong[]{0x2130173AC002C242UL,0x2950989CUL});
		public static readonly BitSet _xEOS_in_closeItems1010 = new BitSet(new ulong[]{0x2130173AC002C242UL,0x2950989CUL});
		public static readonly BitSet _nestedFunction_in_closeItem1028 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_closeItem1047 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_in_nestedFunction1065 = new BitSet(new ulong[]{0x20010000000000UL});
		public static readonly BitSet _functionSignature_in_nestedFunction1067 = new BitSet(new ulong[]{0xC0004000UL,0x8000UL});
		public static readonly BitSet _closeBody_in_nestedFunction1069 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _END_in_nestedFunction1071 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOL_in_classFile1097 = new BitSet(new ulong[]{0x80001000UL});
		public static readonly BitSet _class_in_classFile1101 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOL_in_classFile1104 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _closeFunctions_in_classFile1109 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOL_in_classFile1112 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_classFile1118 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CLASSDEF_in_class1141 = new BitSet(new ulong[]{0x10010000000000UL});
		public static readonly BitSet _annotationPortion_in_class1144 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _name_in_class1148 = new BitSet(new ulong[]{0x40000080004000UL,0x8000UL});
		public static readonly BitSet _genealogyPortion_in_class1151 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_class1155 = new BitSet(new ulong[]{0x100C0004000UL,0x8000UL});
		public static readonly BitSet _sections_in_class1157 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _END_in_class1159 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_annotationPortion1191 = new BitSet(new ulong[]{0x2000010000000000UL});
		public static readonly BitSet _attributes_in_annotationPortion1193 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _RPAREN_in_annotationPortion1195 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _attribute_in_attributes1208 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _COMMA_in_attributes1211 = new BitSet(new ulong[]{0x2000010000000000UL});
		public static readonly BitSet _attribute_in_attributes1213 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _NOT_in_attribute1231 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _name_in_attribute1233 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_in_attribute1266 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _name_in_attribute1305 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_attribute1307 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_attribute1309 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_genealogyPortion1334 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _baseClasses_in_genealogyPortion1336 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classReference_in_baseClasses1349 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _AND_in_baseClasses1352 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _classReference_in_baseClasses1354 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _fullClassName_in_classReference1372 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xID_in_fullClassName1390 = new BitSet(new ulong[]{0x4000002UL});
		public static readonly BitSet _DOT_in_fullClassName1396 = new BitSet(new ulong[]{0x33870021E00UL,0x2910100EUL});
		public static readonly BitSet _xANYID_in_fullClassName1398 = new BitSet(new ulong[]{0x4000002UL});
		public static readonly BitSet _section_in_sections1424 = new BitSet(new ulong[]{0x10080004002UL,0x8000UL});
		public static readonly BitSet _xEOS_in_sections1428 = new BitSet(new ulong[]{0x10080004002UL,0x8000UL});
		public static readonly BitSet _eventSection_in_section1446 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertySection_in_section1458 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodSection_in_section1470 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enumerationSection_in_section1481 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xEVENTS_in_eventSection1499 = new BitSet(new ulong[]{0x100100C0004000UL,0x8000UL});
		public static readonly BitSet _annotationPortion_in_eventSection1502 = new BitSet(new ulong[]{0x100C0004000UL,0x8000UL});
		public static readonly BitSet _events_in_eventSection1506 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _END_in_eventSection1508 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _event_in_events1535 = new BitSet(new ulong[]{0x10080004002UL,0x8000UL});
		public static readonly BitSet _xEOS_in_events1539 = new BitSet(new ulong[]{0x10080004002UL,0x8000UL});
		public static readonly BitSet _name_in_event1557 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_event1559 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xPROPERTIES_in_propertySection1579 = new BitSet(new ulong[]{0x100100C0004000UL,0x8000UL});
		public static readonly BitSet _annotationPortion_in_propertySection1582 = new BitSet(new ulong[]{0x100C0004000UL,0x8000UL});
		public static readonly BitSet _properties_in_propertySection1586 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _END_in_propertySection1588 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _property_in_properties1615 = new BitSet(new ulong[]{0x10080004002UL,0x8000UL});
		public static readonly BitSet _xEOS_in_properties1619 = new BitSet(new ulong[]{0x10080004002UL,0x8000UL});
		public static readonly BitSet _name_in_property1637 = new BitSet(new ulong[]{0x62UL});
		public static readonly BitSet _filter_in_property1640 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _ASSIGN_in_property1645 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_property1647 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xMETHODS_in_methodSection1679 = new BitSet(new ulong[]{0x300110C0004000UL,0x8000UL});
		public static readonly BitSet _annotationPortion_in_methodSection1682 = new BitSet(new ulong[]{0x200110C0004000UL,0x8000UL});
		public static readonly BitSet _methods_in_methodSection1686 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _END_in_methodSection1688 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _method_in_methods1715 = new BitSet(new ulong[]{0x20011080004002UL,0x8000UL});
		public static readonly BitSet _xEOS_in_methods1719 = new BitSet(new ulong[]{0x20011080004002UL,0x8000UL});
		public static readonly BitSet _regularMethod_in_method1737 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _externalMethod_in_method1750 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_in_regularMethod1768 = new BitSet(new ulong[]{0x20010000000000UL});
		public static readonly BitSet _methodSignature_in_regularMethod1770 = new BitSet(new ulong[]{0xC0004000UL,0x8000UL});
		public static readonly BitSet _closeBody_in_regularMethod1772 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _END_in_regularMethod1774 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _outputPortion_in_methodSignature1807 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _methodName1_in_methodSignature1811 = new BitSet(new ulong[]{0x10000000000002UL});
		public static readonly BitSet _inputPortion_in_methodSignature1814 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _outputPortion_in_methodSignature1834 = new BitSet(new ulong[]{0x10040000000UL});
		public static readonly BitSet _methodName2_in_methodSignature1836 = new BitSet(new ulong[]{0x10000000000002UL});
		public static readonly BitSet _inputPortion_in_methodSignature1839 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodName3_in_methodSignature1859 = new BitSet(new ulong[]{0x10000000000002UL});
		public static readonly BitSet _inputPortion_in_methodSignature1862 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xID_in_methodName11886 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _DOT_in_methodName11888 = new BitSet(new ulong[]{0x10040000000UL});
		public static readonly BitSet _xFUNCTIONID_in_methodName11890 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xFUNCTIONID_in_methodName21910 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xID_in_methodName31928 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodSignature_in_externalMethod1946 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_externalMethod1948 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xENUMERATION_in_enumerationSection1968 = new BitSet(new ulong[]{0x100100C0004000UL,0x8000UL});
		public static readonly BitSet _annotationPortion_in_enumerationSection1971 = new BitSet(new ulong[]{0x100C0004000UL,0x8000UL});
		public static readonly BitSet _enumerations_in_enumerationSection1975 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _END_in_enumerationSection1977 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enumeration_in_enumerations2004 = new BitSet(new ulong[]{0x10080004002UL,0x8000UL});
		public static readonly BitSet _xEOS_in_enumerations2008 = new BitSet(new ulong[]{0x10080004002UL,0x8000UL});
		public static readonly BitSet _name_in_enumeration2026 = new BitSet(new ulong[]{0x10000000000002UL});
		public static readonly BitSet _call_in_enumeration2029 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_call2061 = new BitSet(new ulong[]{0x2130150040000040UL,0x402890UL});
		public static readonly BitSet _expressions_in_call2064 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _RPAREN_in_call2068 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_expressions2088 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _COMMA_in_expressions2091 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_expressions2093 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _assignment_in_statement2118 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _action_in_statement2143 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simpleCommand_in_statement2162 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _abortCommand_in_statement2181 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _standardCommand_in_statement2195 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bang_in_statement2209 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _break_in_statement2228 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _continue_in_statement2248 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _for_in_statement2268 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _global_in_statement2287 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _if_in_statement2306 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parfor_in_statement2325 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _persistent_in_statement2344 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _return_in_statement2363 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _spmd_in_statement2376 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _switch_in_statement2395 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _try_in_statement2414 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _while_in_statement2433 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentCore_in_assignment2471 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _chain_in_assignmentCore2484 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_assignmentCore2486 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_assignmentCore2488 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_assignmentCore2490 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _storage_in_assignmentCore2513 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_assignmentCore2515 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_assignmentCore2517 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_assignmentCore2519 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LSQUARE_in_storage2554 = new BitSet(new ulong[]{0x2000010000004000UL,0x80UL});
		public static readonly BitSet _COMMA_in_storage2557 = new BitSet(new ulong[]{0x2000010000000000UL,0x80UL});
		public static readonly BitSet _slots_in_storage2561 = new BitSet(new ulong[]{0x4000UL,0x4000UL});
		public static readonly BitSet _COMMA_in_storage2564 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RSQUARE_in_storage2568 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _slot_in_slots2590 = new BitSet(new ulong[]{0x2000010000004002UL,0x80UL});
		public static readonly BitSet _COMMA_in_slots2597 = new BitSet(new ulong[]{0x2000010000000000UL,0x80UL});
		public static readonly BitSet _slot_in_slots2601 = new BitSet(new ulong[]{0x2000010000004002UL,0x80UL});
		public static readonly BitSet _chain_in_slot2619 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _metaclass_in_slot2630 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_slot2641 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_action2672 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_action2674 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _var_in_simpleCommand2699 = new BitSet(new ulong[]{0xFFCFEFFF7FFBBFF0UL,0xFFFFFFFFFBFF1CFFUL,0x1FFUL});
		public static readonly BitSet _simpleTexts_in_simpleCommand2701 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_simpleCommand2703 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simpleText_in_simpleTexts2730 = new BitSet(new ulong[]{0xFFCFEFFF7FFBBFF2UL,0xFFFFFFFFFBFF1CFFUL,0x1FFUL});
		public static readonly BitSet _simpleText_in_simpleTexts2736 = new BitSet(new ulong[]{0xFFCFEFFF7FFBBFF2UL,0xFFFFFFFFFBFF1CFFUL,0x1FFUL});
		public static readonly BitSet _simpleBlock_in_simpleText2764 = new BitSet(new ulong[]{0xFFCFEFFF7FFBBFF2UL,0xFFFFFFFFFBFF1CFFUL,0x1FFUL});
		public static readonly BitSet _simpleBlock_in_simpleText2783 = new BitSet(new ulong[]{0xFFCFEFFF7FFBBFF2UL,0xFFFFFFFFFBFF1CFFUL,0x1FFUL});
		public static readonly BitSet _STRING_in_simpleBlock2812 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _set_in_simpleBlock2822 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _var_in_abortCommand2892 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMAND_in_standardCommand2909 = new BitSet(new ulong[]{0x80000UL,0x800000UL});
		public static readonly BitSet _standardTexts_in_standardCommand2911 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_standardCommand2913 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _standardText_in_standardTexts2951 = new BitSet(new ulong[]{0x80002UL,0x800000UL});
		public static readonly BitSet _standardText_in_standardTexts2957 = new BitSet(new ulong[]{0x80002UL,0x800000UL});
		public static readonly BitSet _standardBlock_in_standardText2985 = new BitSet(new ulong[]{0x80002UL,0x800000UL});
		public static readonly BitSet _standardBlock_in_standardText3004 = new BitSet(new ulong[]{0x80002UL,0x800000UL});
		public static readonly BitSet _STRINGBLOCK_in_standardBlock3034 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEFAULTBLOCK_in_standardBlock3043 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXCLAMATION_in_bang3064 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _LINE_in_bang3066 = new BitSet(new ulong[]{0x80000000UL});
		public static readonly BitSet _xEOL_in_bang3070 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BREAK_in_break3092 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_break3094 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONTINUE_in_continue3113 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_continue3115 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_for3134 = new BitSet(new ulong[]{0x10010000000000UL});
		public static readonly BitSet _forHead_in_for3136 = new BitSet(new ulong[]{0x2130172AC002C240UL,0x2950989CUL});
		public static readonly BitSet _statements_in_for3138 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _END_in_for3140 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_for3142 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _var_in_forHead3166 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_forHead3168 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_forHead3170 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_forHead3182 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _var_in_forHead3184 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_forHead3186 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_forHead3188 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _RPAREN_in_forHead3190 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GLOBAL_in_global3209 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _var_in_global3212 = new BitSet(new ulong[]{0x10080004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_global3216 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifPart_in_if3240 = new BitSet(new ulong[]{0x70000000UL});
		public static readonly BitSet _elseIfPart_in_if3243 = new BitSet(new ulong[]{0x70000000UL});
		public static readonly BitSet _elsePart_in_if3248 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _END_in_if3252 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_if3254 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_ifPart3284 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_ifPart3286 = new BitSet(new ulong[]{0x2130172AC002C240UL,0x2950989CUL});
		public static readonly BitSet _statements_in_ifPart3288 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELSEIF_in_elseIfPart3310 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_elseIfPart3312 = new BitSet(new ulong[]{0x2130172AC002C240UL,0x2950989CUL});
		public static readonly BitSet _statements_in_elseIfPart3314 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELSE_in_elsePart3336 = new BitSet(new ulong[]{0x2130172AC002C240UL,0x2950989CUL});
		public static readonly BitSet _statements_in_elsePart3338 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PARFOR_in_parfor3360 = new BitSet(new ulong[]{0x10010000000000UL});
		public static readonly BitSet _parforHead_in_parfor3362 = new BitSet(new ulong[]{0x2130172AC002C240UL,0x2950989CUL});
		public static readonly BitSet _statements_in_parfor3364 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _END_in_parfor3366 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_parfor3368 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_parforHead3405 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _var_in_parforHead3407 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_parforHead3409 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_parforHead3411 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _COMMA_in_parforHead3413 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_parforHead3415 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _RPAREN_in_parforHead3417 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_parforHead3436 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _var_in_parforHead3438 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_parforHead3440 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_parforHead3442 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _RPAREN_in_parforHead3444 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _var_in_parforHead3459 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_parforHead3461 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_parforHead3463 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PERSISTENT_in_persistent3485 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _var_in_persistent3488 = new BitSet(new ulong[]{0x10080004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_persistent3492 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_return3516 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_return3518 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SPMD_in_spmd3538 = new BitSet(new ulong[]{0x2130172AC002C240UL,0x2950989CUL});
		public static readonly BitSet _spmdHead_in_spmd3549 = new BitSet(new ulong[]{0x2130172AC002C240UL,0x2950989CUL});
		public static readonly BitSet _statements_in_spmd3553 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _END_in_spmd3555 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_spmd3557 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_spmdHead3584 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_spmdHead3586 = new BitSet(new ulong[]{0x4000UL,0x2000UL});
		public static readonly BitSet _COMMA_in_spmdHead3589 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_spmdHead3591 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _RPAREN_in_spmdHead3595 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _switchPart_in_switch3613 = new BitSet(new ulong[]{0x40000400UL,0x2UL});
		public static readonly BitSet _casePart_in_switch3616 = new BitSet(new ulong[]{0x40000400UL,0x2UL});
		public static readonly BitSet _otherwisePart_in_switch3621 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _END_in_switch3625 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_switch3627 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SWITCH_in_switchPart3657 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_switchPart3659 = new BitSet(new ulong[]{0x80004002UL,0x8000UL});
		public static readonly BitSet _xEOS_in_switchPart3662 = new BitSet(new ulong[]{0x80004002UL,0x8000UL});
		public static readonly BitSet _CASE_in_casePart3681 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_casePart3683 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_casePart3685 = new BitSet(new ulong[]{0x2130172AC002C240UL,0x2950989CUL});
		public static readonly BitSet _statements_in_casePart3687 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OTHERWISE_in_otherwisePart3709 = new BitSet(new ulong[]{0x2130172AC002C240UL,0x2950989CUL});
		public static readonly BitSet _statements_in_otherwisePart3711 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tryPart_in_try3733 = new BitSet(new ulong[]{0x40000800UL});
		public static readonly BitSet _catchPart_in_try3736 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _END_in_try3740 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_try3742 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRY_in_tryPart3767 = new BitSet(new ulong[]{0x2130172AC002C240UL,0x2950989CUL});
		public static readonly BitSet _statements_in_tryPart3769 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CATCH_in_catchPart3789 = new BitSet(new ulong[]{0x2130172AC002C240UL,0x2950989CUL});
		public static readonly BitSet _capturePortion_in_catchPart3803 = new BitSet(new ulong[]{0x2130172AC002C240UL,0x2950989CUL});
		public static readonly BitSet _statements_in_catchPart3807 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _var_in_capturePortion3832 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_capturePortion3834 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_while3849 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_while3851 = new BitSet(new ulong[]{0x2130172AC002C240UL,0x2950989CUL});
		public static readonly BitSet _statements_in_while3853 = new BitSet(new ulong[]{0x40000000UL});
		public static readonly BitSet _END_in_while3855 = new BitSet(new ulong[]{0x80004000UL,0x8000UL});
		public static readonly BitSet _xEOS_in_while3857 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression11_in_expression3883 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression10_in_expression113899 = new BitSet(new ulong[]{0x2UL,0x20000UL});
		public static readonly BitSet _SHORTOR_in_expression113916 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression10_in_expression113920 = new BitSet(new ulong[]{0x2UL,0x20000UL});
		public static readonly BitSet _expression09_in_expression103946 = new BitSet(new ulong[]{0x2UL,0x10000UL});
		public static readonly BitSet _SHORTAND_in_expression103963 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression09_in_expression103967 = new BitSet(new ulong[]{0x2UL,0x10000UL});
		public static readonly BitSet _expression08_in_expression093993 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _OR_in_expression094010 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression08_in_expression094014 = new BitSet(new ulong[]{0x2UL,0x1UL});
		public static readonly BitSet _expression07_in_expression084040 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _AND_in_expression084057 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression07_in_expression084061 = new BitSet(new ulong[]{0x12UL});
		public static readonly BitSet _expression06_in_expression074087 = new BitSet(new ulong[]{0x40C000C100000002UL});
		public static readonly BitSet _operator06_in_expression074106 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression06_in_expression074110 = new BitSet(new ulong[]{0x40C000C100000002UL});
		public static readonly BitSet _LT_in_operator064134 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LTEQ_in_operator064147 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GT_in_operator064160 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GTEQ_in_operator064173 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EQ_in_operator064186 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOTEQ_in_operator064199 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression05_in_expression064220 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _COLON_in_expression064246 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression05_in_expression064250 = new BitSet(new ulong[]{0x2002UL});
		public static readonly BitSet _expression04_in_expression054277 = new BitSet(new ulong[]{0x100000000000002UL,0x10UL});
		public static readonly BitSet _operator04_in_expression054299 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression04_in_expression054303 = new BitSet(new ulong[]{0x100000000000002UL,0x10UL});
		public static readonly BitSet _PLUS_in_operator044327 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_operator044340 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression03_in_expression044361 = new BitSet(new ulong[]{0x1A00200000000002UL,0x2000400UL});
		public static readonly BitSet _operator03_in_expression044380 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression03_in_expression044384 = new BitSet(new ulong[]{0x1A00200000000002UL,0x2000400UL});
		public static readonly BitSet _TIMES_in_operator034408 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RDIV_in_operator034421 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LDIV_in_operator034434 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MTIMES_in_operator034447 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MRDIV_in_operator034460 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MLDIV_in_operator034473 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _operator02_in_expression034493 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression03_in_expression034497 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression02_in_expression034518 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PLUS_in_operator024537 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_operator024551 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_operator024565 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression00_in_expression024586 = new BitSet(new ulong[]{0x400000000040002UL,0x4000040UL});
		public static readonly BitSet _operator01_in_expression024623 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression01_in_expression024627 = new BitSet(new ulong[]{0x400000000040002UL,0x4000040UL});
		public static readonly BitSet _TRANS_in_expression024652 = new BitSet(new ulong[]{0x400000000040002UL,0x4000040UL});
		public static readonly BitSet _CTRANS_in_expression024673 = new BitSet(new ulong[]{0x400000000040002UL,0x4000040UL});
		public static readonly BitSet _POW_in_operator014702 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MPOW_in_operator014715 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _operator02_in_expression014735 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression01_in_expression014739 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression00_in_expression014760 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _atom_in_expression004779 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _chain_in_atom4794 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _real_in_atom4808 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _imaginary_in_atom4819 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _string_in_atom4830 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _regularArray_in_atom4841 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _cellArray_in_atom4852 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parenthesized_in_atom4863 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _end_in_atom4874 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionHandle_in_atom4885 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _anonymousFunction_in_atom4896 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _metaclass_in_atom4907 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _var_in_chain4936 = new BitSet(new ulong[]{0x10100004000042UL});
		public static readonly BitSet _dotExpressionOperator_in_chain4957 = new BitSet(new ulong[]{0x10100004000042UL});
		public static readonly BitSet _dotNameOperator_in_chain4979 = new BitSet(new ulong[]{0x10100004000042UL});
		public static readonly BitSet _parenthesisOperator_in_chain5001 = new BitSet(new ulong[]{0x10100004000042UL});
		public static readonly BitSet _curlyBraceOperator_in_chain5026 = new BitSet(new ulong[]{0x10100004000042UL});
		public static readonly BitSet _atBaseOperator_in_chain5048 = new BitSet(new ulong[]{0x10100004000042UL});
		public static readonly BitSet _name_in_var5078 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_dotExpressionOperator5106 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _LPAREN_in_dotExpressionOperator5108 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_dotExpressionOperator5110 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _RPAREN_in_dotExpressionOperator5112 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_dotNameOperator5133 = new BitSet(new ulong[]{0x33870021E00UL,0x2910100EUL});
		public static readonly BitSet _anyName_in_dotNameOperator5135 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xANYID_in_anyName5152 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_parenthesisOperator5182 = new BitSet(new ulong[]{0x2130150040002040UL,0x402890UL});
		public static readonly BitSet _arguments_in_parenthesisOperator5185 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _RPAREN_in_parenthesisOperator5189 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _argument_in_arguments5209 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _COMMA_in_arguments5212 = new BitSet(new ulong[]{0x2130150040002040UL,0x400890UL});
		public static readonly BitSet _argument_in_arguments5214 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _expression_in_argument5232 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_argument5245 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_curlyBraceOperator5276 = new BitSet(new ulong[]{0x2130150040002040UL,0x400890UL});
		public static readonly BitSet _arguments_in_curlyBraceOperator5278 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _RCURLY_in_curlyBraceOperator5280 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _AT_in_atBaseOperator5303 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _classReference_in_atBaseOperator5305 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _REAL_in_real5324 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IMAGINARY_in_imaginary5339 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_in_string5354 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LSQUARE_in_regularArray5378 = new BitSet(new ulong[]{0x21301500C0004040UL,0x408890UL});
		public static readonly BitSet _rows_in_regularArray5380 = new BitSet(new ulong[]{0x0UL,0x4000UL});
		public static readonly BitSet _RSQUARE_in_regularArray5382 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _row_in_rows5409 = new BitSet(new ulong[]{0x80000002UL,0x8000UL});
		public static readonly BitSet _SEMICOLON_in_rows5413 = new BitSet(new ulong[]{0x21301500C0004040UL,0x408890UL});
		public static readonly BitSet _EOL_in_rows5417 = new BitSet(new ulong[]{0x21301500C0004040UL,0x408890UL});
		public static readonly BitSet _row_in_rows5420 = new BitSet(new ulong[]{0x80000002UL,0x8000UL});
		public static readonly BitSet _COMMA_in_row5439 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _columns_in_row5443 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _COMMA_in_row5446 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMA_in_row5463 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _column_in_columns5490 = new BitSet(new ulong[]{0x2130150040004042UL,0x400890UL});
		public static readonly BitSet _COMMA_in_columns5497 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _column_in_columns5501 = new BitSet(new ulong[]{0x2130150040004042UL,0x400890UL});
		public static readonly BitSet _NOT_in_column5540 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_column5563 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_cellArray5590 = new BitSet(new ulong[]{0x21301500C0004040UL,0x408890UL});
		public static readonly BitSet _rows_in_cellArray5592 = new BitSet(new ulong[]{0x0UL,0x200UL});
		public static readonly BitSet _RCURLY_in_cellArray5594 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_parenthesized5630 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_parenthesized5632 = new BitSet(new ulong[]{0x0UL,0x2000UL});
		public static readonly BitSet _RPAREN_in_parenthesized5634 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _END_in_end5656 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _AT_in_functionHandle5671 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _functionReference_in_functionHandle5673 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _fullFunctioName_in_functionReference5691 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xID_in_fullFunctioName5709 = new BitSet(new ulong[]{0x4000002UL});
		public static readonly BitSet _DOT_in_fullFunctioName5712 = new BitSet(new ulong[]{0x33870021E00UL,0x2910100EUL});
		public static readonly BitSet _xANYID_in_fullFunctioName5714 = new BitSet(new ulong[]{0x4000002UL});
		public static readonly BitSet _AT_in_anonymousFunction5741 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _inputPortion_in_anonymousFunction5743 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_anonymousFunction5745 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _QUESTION_in_metaclass5770 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _classReference_in_metaclass5772 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMICOLON_in_xEOS5791 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMA_in_xEOS5802 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOL_in_xEOS5814 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOL_in_xEOL5831 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_xID5845 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_xANYID5858 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BREAK_in_xANYID5871 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CASE_in_xANYID5885 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CATCH_in_xANYID5899 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CLASSDEF_in_xANYID5913 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONTINUE_in_xANYID5927 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELSE_in_xANYID5941 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELSEIF_in_xANYID5955 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _END_in_xANYID5969 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_xANYID5983 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_in_xANYID5997 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GLOBAL_in_xANYID6011 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_xANYID6025 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OTHERWISE_in_xANYID6039 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PARFOR_in_xANYID6053 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PERSISTENT_in_xANYID6067 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_xANYID6081 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SPMD_in_xANYID6095 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SWITCH_in_xANYID6109 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRY_in_xANYID6123 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_xANYID6137 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_xFUNCTIONID6156 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _END_in_xFUNCTIONID6168 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_xPARAMETERID6186 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_xPARAMETERID6200 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_xEVENTS6223 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_xPROPERTIES6239 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_xMETHODS6255 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_xENUMERATION6271 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _openFunctionFile_in_synpred1_MatlabParser388 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignment_in_synpred2_MatlabParser2114 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _action_in_synpred3_MatlabParser2139 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _simpleCommand_in_synpred4_MatlabParser2158 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _abortCommand_in_synpred5_MatlabParser2177 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_synpred6_MatlabParser3393 = new BitSet(new ulong[]{0x10000000000UL});
		public static readonly BitSet _var_in_synpred6_MatlabParser3395 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_synpred6_MatlabParser3397 = new BitSet(new ulong[]{0x2130150040000040UL,0x400890UL});
		public static readonly BitSet _expression_in_synpred6_MatlabParser3399 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _COMMA_in_synpred6_MatlabParser3401 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_synpred7_MatlabParser4949 = new BitSet(new ulong[]{0x10000000000000UL});
		public static readonly BitSet _LPAREN_in_synpred7_MatlabParser4951 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_synpred8_MatlabParser5520 = new BitSet(new ulong[]{0x80004000UL,0xC000UL});
		public static readonly BitSet _set_in_synpred8_MatlabParser5522 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace Matlab.Recognizer
